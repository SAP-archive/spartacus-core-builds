import { Observable } from 'rxjs';
import { Page, PageMeta } from '../model/page.model';
import { PageMetaResolver } from '../page/page-meta.resolver';
import { CmsService } from './cms.service';
import { UnifiedInjector } from '../../lazy-loading/unified-injector';
import * as ɵngcc0 from '@angular/core';
export declare class PageMetaService {
    protected resolvers: PageMetaResolver[];
    protected cms: CmsService;
    protected unifiedInjector?: UnifiedInjector;
    private resolvers$;
    constructor(resolvers: PageMetaResolver[], cms: CmsService, unifiedInjector?: UnifiedInjector);
    /**
     * The list of resolver interfaces will be evaluated for the pageResolvers.
     *
     * TOOD: optimize browser vs SSR resolvers; image, robots and description
     *       aren't needed during browsing.
     * TODO: we can make the list of resolver types configurable
     */
    protected resolverMethods: {
        [key: string]: string;
    };
    getMeta(): Observable<PageMeta | null>;
    /**
     * If a `PageResolver` has implemented a resolver interface, the resolved data
     * is merged into the `PageMeta` object.
     * @param metaResolver
     */
    protected resolve(metaResolver: PageMetaResolver): Observable<PageMeta>;
    /**
     * Return the resolver with the best match, based on a score
     * generated by the resolver.
     *
     * Resolvers match by default on `PageType` and `page.template`.
     */
    protected getMetaResolver(page: Page): Observable<PageMetaResolver>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PageMetaService, [{ optional: true; }, null, { optional: true; }]>;
}

//# sourceMappingURL=page-meta.service.d.ts.map