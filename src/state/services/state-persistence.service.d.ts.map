{"version":3,"file":"state-persistence.service.d.ts","sources":["state-persistence.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Observable, Subscription } from 'rxjs';\nimport { StorageSyncType } from '../../state/config/state-config';\nimport { WindowRef } from '../../window/window-ref';\nexport declare class StatePersistenceService {\n    protected winRef: WindowRef;\n    constructor(winRef: WindowRef);\n    /**\n     * Helper to synchronize state to more persistent storage (localStorage, sessionStorage).\n     * It is context aware, so you can keep different state for te same feature based on specified context.\n     *\n     * Eg. cart is valid only under the same base site. So you want to synchronize cart only with the same base site.\n     * Usage for that case: `syncWithStorage({ key: 'cart', state$: activeCartSelector$, context$: this.siteContextParamsService.getValues([BASE_SITE_CONTEXT_ID]), onRead: (state) => setCorrectStateInStore(state) })`.\n     * Active cart for the `electronics` base site will be stored under `spartacus⚿electronics⚿cart` and for apparel under `spartacus⚿apparel⚿cart`.\n     *\n     * On each context change onRead function will be executed with state from storage provided as a parameter.\n     *\n     * Omitting context$ will trigger onRead only once at initialization.\n     *\n     * @param key Key to use in storage for the synchronized state. Should be unique for each feature.\n     * @param state$ State to be saved and later restored.\n     * @param context$ Context for state\n     * @param storageType Storage type to be used to persist state\n     * @param onRead Function to be executed on each storage read after context change\n     *\n     * @returns Subscriptions for reading/writing in storage on context/state change\n     */\n    syncWithStorage<T>({ key, state$, context$, storageType, onRead, }: {\n        key: string;\n        state$: Observable<T>;\n        context$?: Observable<string | Array<string>>;\n        storageType?: StorageSyncType;\n        onRead?: (stateFromStorage: T) => void;\n    }): Subscription;\n    protected generateKeyWithContext(context: string | Array<string>, key: string): string;\n}\n"]}