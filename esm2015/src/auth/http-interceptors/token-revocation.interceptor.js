import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { EMPTY, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { InterceptorUtil, TOKEN_REVOCATION_HEADER, } from '../../occ/utils/interceptor-util';
import * as i0 from "@angular/core";
let TokenRevocationInterceptor = class TokenRevocationInterceptor {
    constructor() { }
    intercept(request, next) {
        const isTokenRevocationRequest = this.isTokenRevocationRequest(request);
        if (isTokenRevocationRequest) {
            request = InterceptorUtil.removeHeader(TOKEN_REVOCATION_HEADER, request);
        }
        return next.handle(request).pipe(catchError((error) => {
            if (isTokenRevocationRequest) {
                return EMPTY;
            }
            return throwError(error);
        }));
    }
    isTokenRevocationRequest(request) {
        const isTokenRevocationHeaderPresent = InterceptorUtil.getInterceptorParam(TOKEN_REVOCATION_HEADER, request.headers);
        return Boolean(isTokenRevocationHeaderPresent);
    }
};
TokenRevocationInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function TokenRevocationInterceptor_Factory() { return new TokenRevocationInterceptor(); }, token: TokenRevocationInterceptor, providedIn: "root" });
TokenRevocationInterceptor = __decorate([
    Injectable({ providedIn: 'root' })
], TokenRevocationInterceptor);
export { TokenRevocationInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4tcmV2b2NhdGlvbi5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9hdXRoL2h0dHAtaW50ZXJjZXB0b3JzL3Rva2VuLXJldm9jYXRpb24uaW50ZXJjZXB0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQU1BLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLEtBQUssRUFBYyxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDckQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFDTCxlQUFlLEVBQ2YsdUJBQXVCLEdBQ3hCLE1BQU0sa0NBQWtDLENBQUM7O0FBRzFDLElBQWEsMEJBQTBCLEdBQXZDLE1BQWEsMEJBQTBCO0lBQ3JDLGdCQUFlLENBQUM7SUFFaEIsU0FBUyxDQUNQLE9BQXlCLEVBQ3pCLElBQWlCO1FBRWpCLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hFLElBQUksd0JBQXdCLEVBQUU7WUFDNUIsT0FBTyxHQUFHLGVBQWUsQ0FBQyxZQUFZLENBQUMsdUJBQXVCLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDMUU7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUM5QixVQUFVLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtZQUN4QixJQUFJLHdCQUF3QixFQUFFO2dCQUM1QixPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsT0FBTyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFUyx3QkFBd0IsQ0FBQyxPQUF5QjtRQUMxRCxNQUFNLDhCQUE4QixHQUFHLGVBQWUsQ0FBQyxtQkFBbUIsQ0FFeEUsdUJBQXVCLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVDLE9BQU8sT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7SUFDakQsQ0FBQztDQUNGLENBQUE7O0FBNUJZLDBCQUEwQjtJQUR0QyxVQUFVLENBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUM7R0FDdEIsMEJBQTBCLENBNEJ0QztTQTVCWSwwQkFBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIdHRwRXZlbnQsXG4gIEh0dHBIYW5kbGVyLFxuICBIdHRwSW50ZXJjZXB0b3IsXG4gIEh0dHBSZXF1ZXN0LFxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFTVBUWSwgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIEludGVyY2VwdG9yVXRpbCxcbiAgVE9LRU5fUkVWT0NBVElPTl9IRUFERVIsXG59IGZyb20gJy4uLy4uL29jYy91dGlscy9pbnRlcmNlcHRvci11dGlsJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUb2tlblJldm9jYXRpb25JbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKCkge31cblxuICBpbnRlcmNlcHQoXG4gICAgcmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55PixcbiAgICBuZXh0OiBIdHRwSGFuZGxlclxuICApOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgY29uc3QgaXNUb2tlblJldm9jYXRpb25SZXF1ZXN0ID0gdGhpcy5pc1Rva2VuUmV2b2NhdGlvblJlcXVlc3QocmVxdWVzdCk7XG4gICAgaWYgKGlzVG9rZW5SZXZvY2F0aW9uUmVxdWVzdCkge1xuICAgICAgcmVxdWVzdCA9IEludGVyY2VwdG9yVXRpbC5yZW1vdmVIZWFkZXIoVE9LRU5fUkVWT0NBVElPTl9IRUFERVIsIHJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KS5waXBlKFxuICAgICAgY2F0Y2hFcnJvcigoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICBpZiAoaXNUb2tlblJldm9jYXRpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpc1Rva2VuUmV2b2NhdGlvblJlcXVlc3QocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzVG9rZW5SZXZvY2F0aW9uSGVhZGVyUHJlc2VudCA9IEludGVyY2VwdG9yVXRpbC5nZXRJbnRlcmNlcHRvclBhcmFtPFxuICAgICAgc3RyaW5nXG4gICAgPihUT0tFTl9SRVZPQ0FUSU9OX0hFQURFUiwgcmVxdWVzdC5oZWFkZXJzKTtcbiAgICByZXR1cm4gQm9vbGVhbihpc1Rva2VuUmV2b2NhdGlvbkhlYWRlclByZXNlbnQpO1xuICB9XG59XG4iXX0=