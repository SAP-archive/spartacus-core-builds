{"version":3,"sources":["/home/travis/build/SAP/cloud-commerce-spartacus-storefront/dist/core/fesm2015/spartacus-core.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgJE,0JAMe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsDf,2IAGmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4MA6HnB;;;;;;uCAMqC,AAIpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuCD,0JAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BxB,YAO0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qHA66B1B;;;;yKAIuK,AAKzJ;;;;;;;;;;;;;;;;;;;;;8IAmBd;;;EAGA,AAG6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2GA+B7B;;;;;wBAKsB,AAIrB;;;;;;;;;;;;;;;;;;;wIAkBD;;;;kMAIgM,AAG5K;;;;;;;;;;;;;;;;;;;;;;;;;;;;iJA2BpB;;;;qNAImN,AAG5L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yLAmHvB;;;;;qPAKmP,AAG7N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gMAoJtB;;;;;;yOAMuO,AAKtN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIAwCjB;;;;EAIA,AAG2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uOAiE3B;;;;;;6RAM2R,AAGpQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAoRvB;;;;EAIA,AAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+KA0GlB;;;;;;kCAMgC,AAI/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;2LA2BD;;;;;0PAKwP,AAG/N;;;;;;;;;;;;;;;;;;;;;;;;;qLAwBzB;;;;;kPAKgP,AAGzN;;;;;;;;;;;;;;;;;;;;;;qIAqBvB;sNACoN,AAGvL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gKA0C7B;;;;;EAKA,AAGmC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0JAgDnC;;;;;EAKA,AAGiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuNjC,4HAGc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAsDd;;;;;;;4DAO0D,AAGtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHA4BpB;;;;;;;;;;;;;;;;2DAgByD,AAGtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+DnB,YAakB;;;;;;;;;;;;;;;;;;;;;EAclB,YAUa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+KA2Db;;;;;oOAKkO,AAK5M;;;;;;;;;;;;;;;;;;;qNAkBtB;;;;;;;kPAOgP,AAKpO;;;;;;;;;;;;;;;;;;;8LAkBZ;;;;;;4OAM0O,AAK3N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0LAmbf;;;;;oPAKkP,AAGvN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kJAqD3B;;;;sNAIoN,AAK7L;;;;;;;;;;;;;;;;;;;;;8KAmBvB;;;;;;;;4DAQ0D,AAKlC;;;;;;;;;;;;;;;;;;;;;qJAmBxB;;;;;;;;kDAQgD,AAK7B;;;;;;;;;;;;;;;;;;;;;;EAoBnB,uJAMuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uIA2FvB;;;;gMAI8L,AAK3K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uGA6BnB;;;;;;;EAOA,AAGgB;;;;;;;;;;;;;;EAGhB,YAee;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2IAuDf;;;;4MAI0M,AAGtL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yHA4IpB;;;;;;EAMA,AAGsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HAsCtB;;;;;EAKA,AAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GA4IxB;;;;;;EAMA,AAGiB;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAyBjB;;;;;EAKA,AAGqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAGrB,YAgCgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAiDhB;;;;;EAKA,AAGqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8IA8CrB;;;;;EAKA,AAG6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2IA6J7B;;;;;EAKA,AAG4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;8IA2B5B;;;;gNAI8M,AAGzL;;;;;;;;;;;;;;;;;;;;;;;;;EASrB,oDAoBoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAgDpB;;;;;EAKA,AAGoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kIAyEpB;;;;;EAKA,AAGyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAmFzB;8LAC4L,AAGrK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAavB,oDAoBe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mJA+Df;;;;yNAIuN,AAG9L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BzB,4IAG6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kLA+D7B;;;;gQAI8P,AAG7N;;;;;;;;;;;;;;;;8LAejC;;;;gRAI8Q,AAGzO;;;;;;;;;;;;;;;;;;;;gJAmBrC;;;;qNAImN,AAG3L;;;;;;;;;;;;;;;;;;;;;;iJAoBxB;;;;;EAKA,AAG8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIAiC9B;;;;;EAKA,AAG2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qIAmC3B;;;;;EAKA,AAG0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yIA6L1B;;;;kMAIgM,AAK7K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6MAsCnB;;;;;0QAKwQ,AAK1O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHA4B9B;;;;;;EAMA,AAGoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuDpB,YA+CmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GA+CnB;;;;;EAKA,AAGiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAsEjB;;;;;EAKA,AAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAsDlB;;;;;EAKA,AAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qQA4BlB;;;;;;;sTAOoT,AAG3R;;;;;;;;;;;;;;;;;;;EAGzB,YAoBuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sJA8BvB;;;;0NAIwN,AAGjM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HA8CvB;;;;;EAKA,AAGwB;;;;;EAGxB,ySAMuB;;;;;;;;;;;;;;;;yKAcvB;;;;;EAKA,AAGsC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HA6DtC;;;;;EAKA,AAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HAoCxB;;;;;EAKA,AAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yHAuKxB;;;;;;EAMA,AAGsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HAyCtB;;;;;EAKA,AAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GA6FxB;;;;;EAKA,AAGiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIAkHjB;;;;;EAKA,AAG2B;;;;;;;;;;;;;;;;;;;kNAkB3B;;;;qSAImS,AAK7P;;;;;;;;;;;;;;;;;;;;;;;;;;4KAwBtC;;;;;EAKA,AAGuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qIA4DvC;;;;;;EAMA,AAG0B;;;;;;;;;;;;;;;;;;;sKAkB1B;;;;gPAI8O,AAGjN;;;;;;;;;;;;;;;;;;;sKAkB7B;;;;gPAI8O,AAGjN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAG7B,YAuCgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHA+ChB;0LACwL,AAGlK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mKA0FtB;;;;2OAIyO,AAG9M;;;;;;;;;;;;;;;;;;;;;;;iLAsB3B;;;;;uOAKqO,AAG9M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6WAqFvB;;;;;;;;;;;qCAWmC,AAElC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyCD,0JAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAunCxB,YAeY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6IAwDZ;;;;iNAI+M,AAKxL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kSAiEvB;;;;;;;yVAOuV,AAGxT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wKA61D/B;;;;;4NAK0N,AAKrM;;;;;;;;;;8MASrB;;;;gSAI8R,AAKzP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIA0ErC;;;;;;;;;;;;;;;;;8EAiB4E,AAGjD;;;;;;;;;;;;;;;;;;;;;;;;0HAuB3B;;;;uLAIqL,AAKrK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIA4GhB;;;;;EAKA,AAG2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIAqE3B;;;EAGA,AAG2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qPA0D3B;;;;;;wSAMsS,AAK3Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAgH3B;;;;;;;;;;;4DAW0D,AAGvC;;;;;;;;;;;;;;;;;;mHAgBnB;;;;;;;;;;;6DAW2D,AAGvC;;;;;;;;;;;;6GAUpB;;;;;;;uDAOqD,AAGnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2FlB,YAYyB;;;;;;;;;;;;;;;;;;;;;;;EAiBzB,YASoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0FpB,YAe+B;;;;;;;;;;;;;;;;;;;EAc/B,YAQ0B;;;;;;;;;;;;;;;;;;;;;;;;;sHAwB1B;;;;kLAIgL,AAKjK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAuGf;;;;;;;yDAOuD,AAGrC;;;;;;;;;;;;;;;gKAalB;;;;;;;yFAOuF,AAGpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8DnC,YAaiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4JA+FjB;;;;;4MAK0M,AAKzL;;;;;;;;;;;;;;;;;;;;;;;;;kMAwBjB;;;;sRAIoR,AAG7O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HA4GvC;;;EAGA,AAGuB;;;;;;;;;;;;;;;;;;;4IAkBvB;;;;4MAI0M,AAKvL;;;;;;;;;;;kIAUnB;gNAC8M,AAK1L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kIAsDpB;gNAC8M,AAK1L;;;;;;;;;;;0HAUpB;wMACsM,AAKpL;;;;;;;;;;;8HAUlB;4MAC0M,AAKvL;;;;;;;;;;;kJAUnB;gOAC8N,AAKtM;;;;;;;;;;;sKAUxB;oPACkP,AAKrN;;;;;;;;;;0HAS7B;wMACsM,AAKpL;;;;;;;;;;;;;;qJAalB;;;;wNAIsN,AAKhM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oJAmCtB;;;;;mCAKiC,AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiGD,YAS2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yHAoG3B;;;;;;;;;;;;;kCAagC,AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8BD,YAasB;;;;;;;;;;;;;;qPAatB;;;;;sUAKoU,AAGzR;;;;;;;;;;;;;;;;;;;;;;;;;;;wOA0B3C;;;;gUAI8T,AAGnR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuB3C,YAUY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kHA2CZ;;;;qKAImK,AAKtJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAs5Bb;;;EAGA,AAGmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAyRnB;;;;;EAKA,AAGoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wFA4GpB;0JACwJ,AAG1I;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAqFd;;;;EAIA,AAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHA+ClB;;;;EAIA,AAGqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iGAoQrB;;;;;;EAMA,AAGc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iGA4Pd;;;;EAIA,AAGc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HAmGd;;;;;;;EAOA,AAGuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAyDvB;;;;;;EAMA,AAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mJAmclB;;;;;+LAK6L,AAKhL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8IA2Cb;;;;kNAIgN,AAKzL;;;;;;;;;;;;;;;;8IAevB;;;;gNAI8M,AAKzL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAyDrB;;;;;;;;;;;;;uDAaqD,AAGlC;;;;;;;;;;;;;sJAYnB;;;;0NAIwN,AAKjM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAsDvB;;;;;;;;;;;+DAW6D,AAGxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0HAodrB;;;;uLAIqL,AAKrK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iGAmNhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDA8B+C,AAGjC;;;;;;;;;;0IASd;;;;2MAIyM,AAKrL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAkEpB;;;;;;;;;;;;;;;;wDAgBsD,AAGpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAoPlB,YAakB;;;;;;;;;;;;;;;;;;;gHAiBlB;;;;;;;;;;;;;;;;;;;;;;;;8DAwB4D,AAGzC;;;;;;;;;;;;;;;;;;;;;;;;;EAenB,YAcuB;;;;;;;;;;;;;;;;;;;;;;;;;EAuBvB,6KAKa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GAkMb;;;;EAIA,AAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gMAwClB;;;;;iQAK+P,AAKpO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sJAkH3B;;;;0NAIwN,AAKjM;;;;;;;;;;2IAQvB;;;;;;;kEAOgE,AAGpC;;;;;;;;;;;;;;;;sKAe5B;;;;8OAI4O,AAKjN;;;;;;;;;;;;gHAU3B;;;;;;;yDAOuD,AAGpC;;;;;;;;;;;;;;;;;;;0IAkBnB;;;;2MAIyM,AAKrL;;;;;;;;;;;;;;;;;;;;;;0KAqBpB;;;;mPAIiP,AAKrN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6GA+I5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oEAmDkE,AAGhD;;;;;;;;;;;;;;;;EASlB,YAWsB;;;;;;;;;;;;;;;;;;;EAiBtB,uKAKiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2LAqLjB;;;;;oPAKkP,AAKxN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wLAyE1B;;;;;gPAK8O,AAKrN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4LA6EzB;;;;;4PAK0P,AAKhO;;;;;;;;;;;EAG1B,OAWqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qKAiJrB;;;;8OAI4O,AAKhN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kOAqC5B;;;;;;yRAMuR,AAK/P;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mHAkCxB;;;;;EAKA,AAGoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2JA2GpB;;;;mOAIiO,AAGtM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oPA4E3B;;;;;;wSAMsS,AAG1Q;;;;;;;;;;;kFAS5B;;;EAGA,AAKU;;;;;;;;;;;uGASV;;;EAGA,AAKiB;;;;;EAGjB,iJAOY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wKA4BZ;;;;;;kCAMgC,AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HAuDD;;;;;EAKA,AAGwB;;;;;;;;;;;;;;;;;;;;;;;;EAsBxB,uJAGuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uJA2EvB;;;;6NAI2N,AAGlM;;;;;;;;;;;;;;;;;;;;sLAmBzB;;;;;mPAKiP,AAG1N;;;;;;;;;;;;;;;;;;;;;;;;uGAsBvB;;;;;;;;;;;;;;;;;;;;wDAoBsD,AAGtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4IhB,YAYgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8IAsDhB;;;;;;;;yEAQuE,AAG1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kLAyC7B;;;;;2OAKyO,AAKtN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iGA4BnB;;;;;;;;;;;mDAWiD,AAGnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgJd,YAaiB;;;;;;;;;;;;;;;;;EAejB,uKAKY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4MAoEZ;;;;;;;8BAO4B,AAI3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HAuCD;0MACwM,AAK9K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yFAmC1B;;;EAGA,AAGa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qGAwCb;;;;EAIA,AAGgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qIA4ChB;;;EAGA,AAG0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2IA6J1B;;;;EAIA,AAG4B;;;;;;;;;;;;;;;;;;EAgB5B,yHAMa;;;;;;;;;;;;;;;;;;;;;;;EAqBb,0GAGoB;;;;;;;;;;;;;;;EAapB,gIAGyB;;;;;;;;EAMzB,2FAGe;;;;;;;EAGf,OASoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qHAsFpB;;;;yKAIuK,AAKzJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gKAmCd;;;;EAIA,AAGmC;;;;;;;;;;;;;;;;;;;mHAiBnC;;;;;;;;;;;4DAW0D,AAGtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsCpB,YAakB;;;;;;;;;;EAGlB,YAWa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0RAgEb;;;;;;;;8CAQ4C,AAE3C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gSAgDD;;;;;;;;gDAQ8C,AAE7C;;;;;;;;;;;;;;;;;;;;;;;;;;EAwBD,oSAMwB;;;;;;;;;;;;;;;;;;;;;;;iNAsBxB;;;;;uRAKqR,AAKrP;;;;;;;;;;;;;;EAYhC,oQAMqB;;;;;;;;;;;;EAUrB,mKAKgB;;;;;;;;;;;;;;;;sIAehB;;;;sMAIoM,AAKjL;;;;;;;;;;8KASnB;;;;wPAIsP,AAKzN;;;;;;;;;;;;;kKAY7B;;;;yOAIuO,AAK7M;;;;;;;;;;;;;8JAY1B;;;;oOAIkO,AAKzM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qIAwYzB;;;EAGA,AAG0B;;;;;;;;;;;;;;;;;;;;;4HAmB1B;;;EAGA,AAGuB;;;;;;;;;;;;;;;;;;;;;;4HAoBvB;;;EAGA,AAGuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yPAwGvB;;;;;;;;oCAQkC,AAIjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GAmED;;;;EAIA,AAGiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8HAgCjB;6LAC2L,AAKxK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uQA6FnB;;;;;;;0TAOwT,AAK7R;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wQA2H3B;;;;;;;0TAOwT,AAK9R;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oOAsC1B;;;;;;4RAM0R,AAKjQ;;;;;;;;;;;;;;;;;;;;;wIAmBzB;;;;;;;yEAOuE,AAG5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HA4B3B;;;;;;;;;;;;;;4FAc0F,AAGlE;;;;;;;;;;;;;;;;;;;;;;;;;;+HAwBxB;;;;;;;;;;sEAUoE,AAG5C;;;;;;;;;;;;;;;;;;;;;;;;;0GAuBxB;;;;EAIA,AAGiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4HjB,YAYqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiCrB,mKAKgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iQAqHhB;;;;;;;;8RAQ4R,AAKzQ;;;;;;;;;;;;;;;;;oJAgBnB;;;;wNAIsN,AAG/L;;;;;;;;;;;;;;;;;;;;EAkBvB,wIAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sHAwRlB;;;;;;EAMA,AAGqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuErB,8GAGmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HA4CnB;;;;mCAIiC,AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIA+FD;;;;;EAKA,AAG2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHAsC3B;;;;;;;;;;yDAUuD,AAGpC;;;;;;;;;;;;;;;yHAanB;;;;;;;4DAO0D,AAGpC;;;;;;;;;;;;EAKtB,YAWyB;;;;;;;;;;;;;;EAGzB,YAewB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0HAoCxB;;;;uLAIqL,AAKrK;;;;;;;;;;;;;;;;sJAehB;;;;0NAIwN,AAKjM;;;;;;;;;;;;;;;;sJAevB;;;;0NAIwN,AAKjM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8IA8BvB;;;;gNAI8M,AAKzL;;;;;;;;;;;;;;;;;;;kKAkBrB;;;;yOAIuO,AAK7M;;;;;;;;;;;;;;;;8JAe1B;;;;oOAIkO,AAKzM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+KAyFzB;;;;;sOAKoO,AAGnN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wKA+IjB;;;;;4NAK0N,AAKrM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kKA2IrB;;;;;oNAKkN,AAK/L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mJAsHnB;;;;iNAI+M,AAKvL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wKA6ExB;;;;;4NAK0N,AAKrM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6LAyIrB;;;;;wPAKsP,AAK1N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uLA2D5B;;;;iQAI+P,AAK3N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gJAmHpC;;;;6MAI2M,AAKpL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kIAsTvB;;;;;;;sEAOoE,AAG3C;;;;;;;;;;;4HASzB;;;;;;8DAM4D,AAGrC;;;;;;;;;;;;;;8IAYvB;;;;;;;6EAO2E,AAG9C;;;;;;;;;;;;wIAU7B;;;;;;;yEAOuE,AAG5C;;;;;;;;;;;;;;;;;;;;;;+HAoB3B;;;;;;;2EAOyE,AAGjD;;;;;;;;;;;uJASxB;;;;;;;;;;0EAUwE,AAGxC;;;;;;;;;;;;;;;;;;;sHAiBhC;;;;;;;;;;yDAUuD,AAGlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wIA2BrB;;;;;;;;;;;;;;;;yEAgBuE,AAG5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2IA4B3B;;;;;;;;;;;;;4EAa0E,AAG9C;;;;;;;;;;;;;;;;;;;;0GAkB5B;;;;;;;;;;sDAUoD,AAGnC;;;;;;;;;;;;;;;;;;4HAgBjB;;;;;;;6DAO2D,AAGpC;;;;;;;;;;;;;;uGAYvB;;;;;;;mDAOiD,AAGjC;;;;;;;;;;;;sHAUhB;;;;;;;yDAOuD,AAGlC;;;;;;;;;;;;+HAUrB;;;;;;;+DAO6D,AAGrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4HAyExB;;;;;;;;;;;;;;;;;;;;;;;;;;;gFA2B8E,AAGvD;;;;;;;;;;;;;;;;;;;;;;;;sHAsBvB;;;;;;;;;;;;;;;;6DAgB2D,AAGtC;;;;;;;;;;;;;;;sHAarB;;;;;;;;;;+DAU6D,AAGxC;;;;;;;;;;;;;;;;;;;gHAiBrB;;;;;;;;;;2DAUyD,AAGtC;;;;;;;;;;;;;;;;;;;;;;;yHAqBnB;;;;;;;;;;;;;yDAauD,AAGjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+HAmCtB;;;;;;;;;;;;;;;;oEAgBkE,AAG1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kIAoCxB;;;;;;;;;;;;;oEAakE,AAGzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2BzB,YAakB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iRAgElB;;;;;;;uUAOqU,AAKvS;;;;;;;;;;;;;;;;;;;EAiB9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAKa","file":"spartacus-core.js","sourcesContent":["import { __decorate, __awaiter, __param, __rest } from 'tslib';\nimport { InjectionToken, isDevMode, Optional, NgModule, PLATFORM_ID, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, APP_INITIALIZER, TemplateRef, ViewContainerRef, Input, Directive, Injector, INJECTOR, Pipe, ChangeDetectorRef, NgZone } from '@angular/core';\nimport { CommonModule, isPlatformBrowser, DOCUMENT, isPlatformServer, Location, DatePipe, getLocaleId } from '@angular/common';\nimport { BehaviorSubject, of, fromEvent, throwError, EMPTY, iif, combineLatest, forkJoin, Subscription, timer, queueScheduler, using, from, merge, Observable, defer } from 'rxjs';\nimport { filter, take, mapTo, map, switchMap, debounceTime, startWith, distinctUntilChanged, tap, catchError, exhaustMap, mergeMap, withLatestFrom, pluck, shareReplay, concatMap, delay, debounce, switchMapTo, observeOn, groupBy, auditTime, takeWhile } from 'rxjs/operators';\nimport { createFeatureSelector, createSelector, select, Store, INIT, UPDATE, META_REDUCERS, combineReducers, StoreModule } from '@ngrx/store';\nimport { HttpHeaders, HttpErrorResponse, HttpParams, HTTP_INTERCEPTORS, HttpClient, HttpClientModule, HttpResponse } from '@angular/common/http';\nimport { PRIMARY_OUTLET, Router, DefaultUrlSerializer, NavigationStart, NavigationEnd, NavigationError, NavigationCancel, UrlSerializer, RouterModule } from '@angular/router';\nimport { ofType, Actions, Effect, EffectsModule, createEffect } from '@ngrx/effects';\nimport { makeStateKey, TransferState, Meta } from '@angular/platform-browser';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { ROUTER_NAVIGATED, ROUTER_CANCEL, ROUTER_ERROR, ROUTER_NAVIGATION, RouterStateSerializer, StoreRouterConnectingModule } from '@ngrx/router-store';\nimport i18next from 'i18next';\nimport i18nextXhrBackend from 'i18next-xhr-backend';\n\nconst ConfigValidatorToken = new InjectionToken('ConfigurationValidator');\n/**\n * Use to probide config validation at app bootstrap (when all config chunks are merged)\n *\n * @param configValidator\n */\nfunction provideConfigValidator(configValidator) {\n    return {\n        provide: ConfigValidatorToken,\n        useValue: configValidator,\n        multi: true,\n    };\n}\nfunction validateConfig(config, configValidators) {\n    for (const validate of configValidators) {\n        const warning = validate(config);\n        if (warning) {\n            console.warn(warning);\n        }\n    }\n}\n\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction deepMerge(target = {}, ...sources) {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift() || {};\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (source[key] instanceof Date) {\n                Object.assign(target, { [key]: source[key] });\n            }\n            else if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, { [key]: {} });\n                }\n                deepMerge(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    return deepMerge(target, ...sources);\n}\n\nconst CONFIG_INITIALIZER = new InjectionToken('ConfigInitializer');\nconst CONFIG_INITIALIZER_FORROOT_GUARD = new InjectionToken('CONFIG_INITIALIZER_FORROOT_GUARD');\n\nvar ConfigModule_1;\n/**\n * Global Configuration injection token, can be used to inject configuration to any part of the app\n */\nconst Config = new InjectionToken('Configuration');\n/**\n * Config chunk token, can be used to provide configuration chunk and contribute to the global configuration object.\n * Should not be used directly, use `provideConfig` or import `ConfigModule.withConfig` instead.\n */\nconst ConfigChunk = new InjectionToken('ConfigurationChunk');\n/**\n * Helper function to provide configuration chunk using ConfigChunk token\n *\n * @param config Config object to merge with the global configuration\n */\nfunction provideConfig(config = {}) {\n    return { provide: ConfigChunk, useValue: config, multi: true };\n}\n/**\n * Helper function to provide configuration with factory function, using ConfigChunk token\n *\n * @param configFactory Factory Function that will generate config object\n * @param deps Optional dependencies to a factory function\n */\nfunction provideConfigFactory(configFactory, deps) {\n    return {\n        provide: ConfigChunk,\n        useFactory: configFactory,\n        multi: true,\n        deps: deps,\n    };\n}\n/**\n * Factory function that merges all configurations chunks. Should not be used directly without explicit reason.\n *\n */\nfunction configurationFactory(configChunks, configValidators, // TODO: remove, deprecated since 1.3, issue #5279\nconfigInitializerGuard // TODO: remove, deprecated since 1.3, issue #5279\n) {\n    const config = deepMerge({}, ...configChunks);\n    // TODO: remove as validators should run independently, deprecated since 1.3, issue #5279\n    if (isDevMode() && !configInitializerGuard) {\n        validateConfig(config, configValidators || []);\n    }\n    return config;\n}\nlet ConfigModule = ConfigModule_1 = class ConfigModule {\n    /**\n     * Import ConfigModule and contribute config to the global configuration\n     *\n     * @param config Config object to merge with the global configuration\n     */\n    static withConfig(config) {\n        return {\n            ngModule: ConfigModule_1,\n            providers: [provideConfig(config)],\n        };\n    }\n    /**\n     * Import ConfigModule and contribute config to the global configuration using factory function\n     *\n     * @param configFactory Factory function that will generate configuration\n     * @param deps Optional dependencies to factory function\n     */\n    static withConfigFactory(configFactory, deps) {\n        return {\n            ngModule: ConfigModule_1,\n            providers: [provideConfigFactory(configFactory, deps)],\n        };\n    }\n    /**\n     * Module with providers, should be imported only once, if possible, at the root of the app.\n     *\n     * @param config\n     */\n    static forRoot(config = {}) {\n        return {\n            ngModule: ConfigModule_1,\n            providers: [\n                provideConfig(config),\n                {\n                    provide: Config,\n                    useFactory: configurationFactory,\n                    deps: [\n                        ConfigChunk,\n                        [new Optional(), ConfigValidatorToken],\n                        [new Optional(), CONFIG_INITIALIZER_FORROOT_GUARD],\n                    ],\n                },\n            ],\n        };\n    }\n};\nConfigModule = ConfigModule_1 = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [],\n    })\n], ConfigModule);\n\nfunction getCookie(cookie, name) {\n    const regExp = new RegExp('(?:^|;\\\\s*)' + name + '=([^;]*)', 'g');\n    const result = regExp.exec(cookie);\n    return (result && decodeURIComponent(result[1])) || '';\n}\n\nvar TestConfigModule_1;\nconst TEST_CONFIG_COOKIE_NAME = new InjectionToken('TEST_CONFIG_COOKIE_NAME');\nfunction parseConfigJSON(config) {\n    try {\n        return JSON.parse(decodeURIComponent(config));\n    }\n    catch (_) {\n        return {};\n    }\n}\nfunction configFromCookieFactory(cookieName, platform, document) {\n    if (isPlatformBrowser(platform) && cookieName) {\n        const config = getCookie(document.cookie, cookieName);\n        return parseConfigJSON(config);\n    }\n    return {};\n}\n/**\n * Designed/intended to provide dynamic configuration for testing scenarios ONLY (e.g. e2e tests).\n *\n * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.\n */\nlet TestConfigModule = TestConfigModule_1 = class TestConfigModule {\n    /**\n     * Injects JSON config from the cookie of the given name.\n     *\n     * Be aware of the cookie limitations (4096 bytes).\n     *\n     * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.\n     */\n    static forRoot(options) {\n        return {\n            ngModule: TestConfigModule_1,\n            providers: [\n                {\n                    provide: TEST_CONFIG_COOKIE_NAME,\n                    useValue: options && options.cookie,\n                },\n                provideConfigFactory(configFromCookieFactory, [\n                    TEST_CONFIG_COOKIE_NAME,\n                    PLATFORM_ID,\n                    DOCUMENT,\n                ]),\n            ],\n        };\n    }\n};\nTestConfigModule = TestConfigModule_1 = __decorate([\n    NgModule({})\n], TestConfigModule);\n\n/**\n * Provides support for CONFIG_INITIALIZERS\n */\nlet ConfigInitializerService = class ConfigInitializerService {\n    constructor(config, initializerGuard) {\n        this.config = config;\n        this.initializerGuard = initializerGuard;\n        this.ongoingScopes$ = new BehaviorSubject(undefined);\n    }\n    /**\n     * Returns true if config is stable, i.e. all CONFIG_INITIALIZERS resolved correctly\n     */\n    get isStable() {\n        return (!this.initializerGuard ||\n            (this.ongoingScopes$.value && this.ongoingScopes$.value.length === 0));\n    }\n    /**\n     * Recommended way to get config for code that can run before app will finish\n     * initialization (APP_INITIALIZERS, selected service constructors)\n     *\n     * Used without parameters waits for the whole config to become stable\n     *\n     * Parameters allow to describe which part of the config should be stable using\n     * string describing config part, e.g.:\n     * 'siteContext', 'siteContext.language', etc.\n     *\n     * @param scopes String describing parts of the config we want to be sure are stable\n     */\n    getStableConfig(...scopes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isStable) {\n                return this.config;\n            }\n            return this.ongoingScopes$\n                .pipe(filter(ongoingScopes => ongoingScopes && this.areReady(scopes, ongoingScopes)), take(1), mapTo(this.config))\n                .toPromise();\n        });\n    }\n    /**\n     * Removes provided scopes from currently ongoingScopes\n     *\n     * @param scopes\n     */\n    finishScopes(scopes) {\n        const newScopes = [...this.ongoingScopes$.value];\n        for (const scope of scopes) {\n            newScopes.splice(newScopes.indexOf(scope), 1);\n        }\n        this.ongoingScopes$.next(newScopes);\n    }\n    /**\n     * Return true if provided scopes are not part of ongoingScopes\n     *\n     * @param scopes\n     * @param ongoingScopes\n     */\n    areReady(scopes, ongoingScopes) {\n        if (!scopes.length) {\n            return !ongoingScopes.length;\n        }\n        for (const scope of scopes) {\n            for (const ongoingScope of ongoingScopes) {\n                if (this.scopesOverlap(scope, ongoingScope)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if two scopes overlap.\n     *\n     * Example of scopes that overlap:\n     * 'test' and 'test', 'test.a' and 'test', 'test' and 'test.a'\n     *\n     * Example of scopes that do not overlap:\n     * 'test' and 'testA', 'test.a' and 'test.b', 'test.nested' and 'test.nest'\n     *\n     * @param a ScopeA\n     * @param b ScopeB\n     */\n    scopesOverlap(a, b) {\n        if (b.length > a.length) {\n            [a, b] = [b, a];\n        }\n        return a.startsWith(b) && (a[b.length] || '.') === '.';\n    }\n    /**\n     * @internal\n     *\n     * Not a part of a public API, used by APP_INITIALIZER to initialize all provided CONFIG_INITIALIZERS\n     *\n     */\n    initialize(initializers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.ongoingScopes$.value) {\n                // guard for double initialization\n                return;\n            }\n            const ongoingScopes = [];\n            const asyncConfigs = [];\n            for (const initializer of initializers || []) {\n                if (!initializer) {\n                    continue;\n                }\n                if (!initializer.scopes || !initializer.scopes.length) {\n                    throw new Error('CONFIG_INITIALIZER should provide scope!');\n                }\n                if (isDevMode() && !this.areReady(initializer.scopes, ongoingScopes)) {\n                    console.warn('More than one CONFIG_INITIALIZER is initializing the same config scope.');\n                }\n                ongoingScopes.push(...initializer.scopes);\n                asyncConfigs.push((() => __awaiter(this, void 0, void 0, function* () {\n                    deepMerge(this.config, yield initializer.configFactory());\n                    this.finishScopes(initializer.scopes);\n                }))());\n            }\n            this.ongoingScopes$.next(ongoingScopes);\n            if (asyncConfigs.length) {\n                yield Promise.all(asyncConfigs);\n            }\n        });\n    }\n};\nConfigInitializerService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG_INITIALIZER_FORROOT_GUARD,] }] }\n];\nConfigInitializerService.ɵprov = ɵɵdefineInjectable({ factory: function ConfigInitializerService_Factory() { return new ConfigInitializerService(ɵɵinject(Config), ɵɵinject(CONFIG_INITIALIZER_FORROOT_GUARD, 8)); }, token: ConfigInitializerService, providedIn: \"root\" });\nConfigInitializerService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    }),\n    __param(0, Inject(Config)),\n    __param(1, Optional()),\n    __param(1, Inject(CONFIG_INITIALIZER_FORROOT_GUARD))\n], ConfigInitializerService);\n\nvar ConfigValidatorModule_1;\nfunction configValidatorFactory(configInitializer, validators) {\n    const validate = () => {\n        if (isDevMode()) {\n            configInitializer\n                .getStableConfig()\n                .then(config => validateConfig(config, validators || []));\n        }\n    };\n    return validate;\n}\n/**\n * Should stay private in 1.x\n * as forRoot() is used internally by ConfigInitializerModule\n *\n * issue: #5279\n */\nlet ConfigValidatorModule = ConfigValidatorModule_1 = class ConfigValidatorModule {\n    static forRoot() {\n        return {\n            ngModule: ConfigValidatorModule_1,\n            providers: [\n                {\n                    provide: APP_INITIALIZER,\n                    multi: true,\n                    useFactory: configValidatorFactory,\n                    deps: [\n                        ConfigInitializerService,\n                        [new Optional(), ConfigValidatorToken],\n                    ],\n                },\n            ],\n        };\n    }\n};\nConfigValidatorModule = ConfigValidatorModule_1 = __decorate([\n    NgModule()\n], ConfigValidatorModule);\n\nvar ConfigInitializerModule_1;\nfunction configInitializerFactory(configInitializer, initializers) {\n    const isReady = () => configInitializer.initialize(initializers);\n    return isReady;\n}\nlet ConfigInitializerModule = ConfigInitializerModule_1 = class ConfigInitializerModule {\n    static forRoot() {\n        return {\n            ngModule: ConfigInitializerModule_1,\n            providers: [\n                {\n                    provide: CONFIG_INITIALIZER_FORROOT_GUARD,\n                    useValue: true,\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    multi: true,\n                    useFactory: configInitializerFactory,\n                    deps: [\n                        ConfigInitializerService,\n                        [new Optional(), CONFIG_INITIALIZER],\n                    ],\n                },\n            ],\n        };\n    }\n};\nConfigInitializerModule = ConfigInitializerModule_1 = __decorate([\n    NgModule({\n        imports: [\n            ConfigValidatorModule.forRoot(),\n        ],\n    })\n], ConfigInitializerModule);\n\nclass SiteContextConfig {\n}\n\nclass OccConfig extends SiteContextConfig {\n}\n\nclass AnonymousConsentsConfig extends OccConfig {\n}\n\nconst defaultAnonymousConsentsConfig = {\n    anonymousConsents: {\n        registerConsent: 'MARKETING_NEWSLETTER',\n        showLegalDescriptionInDialog: true,\n        requiredConsents: [],\n        consentManagementPage: {\n            showAnonymousConsents: true,\n            hideConsents: [],\n        },\n    },\n};\n\nclass AuthConfig extends OccConfig {\n}\n\nconst defaultAuthConfig = {\n    authentication: {\n        client_id: 'mobile_android',\n        client_secret: 'secret',\n    },\n    backend: {\n        occ: {\n            endpoints: {\n                login: '/authorizationserver/oauth/token',\n                revoke: '/authorizationserver/oauth/revoke',\n            },\n        },\n    },\n};\n\nconst USE_CLIENT_TOKEN = 'cx-use-client-token';\nconst USE_CUSTOMER_SUPPORT_AGENT_TOKEN = 'cx-use-csagent-token';\nconst TOKEN_REVOCATION_HEADER = 'cx-token-revocation';\nclass InterceptorUtil {\n    static createHeader(headerName, interceptorParam, headers) {\n        if (headers) {\n            return headers.append(headerName, JSON.stringify(interceptorParam));\n        }\n        headers = new HttpHeaders().set(headerName, JSON.stringify(interceptorParam));\n        return headers;\n    }\n    static removeHeader(headerName, request) {\n        const updatedHeaders = request.headers.delete(headerName);\n        return request.clone({ headers: updatedHeaders });\n    }\n    static getInterceptorParam(headerName, headers) {\n        const rawValue = headers.get(headerName);\n        if (rawValue) {\n            return JSON.parse(rawValue);\n        }\n        return undefined;\n    }\n}\n\nconst OCC_USER_ID_CURRENT = 'current';\nconst OCC_USER_ID_ANONYMOUS = 'anonymous';\nconst OCC_USER_ID_GUEST = 'guest';\nconst OCC_CART_ID_CURRENT = 'current';\n\nconst ENTITY_REMOVE_ACTION = '[ENTITY] REMOVE';\nconst ENTITY_REMOVE_ALL_ACTION = '[ENTITY] REMOVE ALL';\nfunction entityMeta(type, id) {\n    return {\n        entityType: type,\n        entityId: id,\n    };\n}\nfunction entityRemoveMeta(type, id) {\n    return {\n        entityId: id,\n        entityType: type,\n        entityRemove: true,\n    };\n}\nfunction entityRemoveAllMeta(type) {\n    return {\n        entityId: null,\n        entityType: type,\n        entityRemove: true,\n    };\n}\nclass EntityRemoveAction {\n    constructor(entityType, id) {\n        this.type = ENTITY_REMOVE_ACTION;\n        this.meta = entityRemoveMeta(entityType, id);\n    }\n}\nclass EntityRemoveAllAction {\n    constructor(entityType) {\n        this.type = ENTITY_REMOVE_ALL_ACTION;\n        this.meta = entityRemoveAllMeta(entityType);\n    }\n}\n\nvar entity_action = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ENTITY_REMOVE_ACTION: ENTITY_REMOVE_ACTION,\n    ENTITY_REMOVE_ALL_ACTION: ENTITY_REMOVE_ALL_ACTION,\n    entityMeta: entityMeta,\n    entityRemoveMeta: entityRemoveMeta,\n    entityRemoveAllMeta: entityRemoveAllMeta,\n    EntityRemoveAction: EntityRemoveAction,\n    EntityRemoveAllAction: EntityRemoveAllAction\n});\n\nconst LOADER_LOAD_ACTION = '[LOADER] LOAD';\nconst LOADER_FAIL_ACTION = '[LOADER] FAIL';\nconst LOADER_SUCCESS_ACTION = '[LOADER] SUCCESS';\nconst LOADER_RESET_ACTION = '[LOADER] RESET';\nfunction loadMeta(entityType) {\n    return {\n        entityType: entityType,\n        loader: {\n            load: true,\n        },\n    };\n}\nfunction failMeta(entityType, error) {\n    return {\n        entityType: entityType,\n        loader: {\n            error: error ? error : true,\n        },\n    };\n}\nfunction successMeta(entityType) {\n    return {\n        entityType: entityType,\n        loader: {\n            success: true,\n        },\n    };\n}\nfunction resetMeta(entityType) {\n    return {\n        entityType: entityType,\n        loader: {},\n    };\n}\nclass LoaderLoadAction {\n    constructor(entityType) {\n        this.type = LOADER_LOAD_ACTION;\n        this.meta = loadMeta(entityType);\n    }\n}\nclass LoaderFailAction {\n    constructor(entityType, error) {\n        this.type = LOADER_FAIL_ACTION;\n        this.meta = failMeta(entityType, error);\n    }\n}\nclass LoaderSuccessAction {\n    constructor(entityType) {\n        this.type = LOADER_SUCCESS_ACTION;\n        this.meta = successMeta(entityType);\n    }\n}\nclass LoaderResetAction {\n    constructor(entityType) {\n        this.type = LOADER_RESET_ACTION;\n        this.meta = resetMeta(entityType);\n    }\n}\n\nvar loader_action = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOADER_LOAD_ACTION: LOADER_LOAD_ACTION,\n    LOADER_FAIL_ACTION: LOADER_FAIL_ACTION,\n    LOADER_SUCCESS_ACTION: LOADER_SUCCESS_ACTION,\n    LOADER_RESET_ACTION: LOADER_RESET_ACTION,\n    loadMeta: loadMeta,\n    failMeta: failMeta,\n    successMeta: successMeta,\n    resetMeta: resetMeta,\n    LoaderLoadAction: LoaderLoadAction,\n    LoaderFailAction: LoaderFailAction,\n    LoaderSuccessAction: LoaderSuccessAction,\n    LoaderResetAction: LoaderResetAction\n});\n\nconst ENTITY_LOAD_ACTION = '[ENTITY] LOAD';\nconst ENTITY_FAIL_ACTION = '[ENTITY] LOAD FAIL';\nconst ENTITY_SUCCESS_ACTION = '[ENTITY] LOAD SUCCESS';\nconst ENTITY_RESET_ACTION = '[ENTITY] RESET';\nfunction entityLoadMeta(entityType, id) {\n    return Object.assign(Object.assign({}, loadMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityFailMeta(entityType, id, error) {\n    return Object.assign(Object.assign({}, failMeta(entityType, error)), entityMeta(entityType, id));\n}\nfunction entitySuccessMeta(entityType, id) {\n    return Object.assign(Object.assign({}, successMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityResetMeta(entityType, id) {\n    return Object.assign(Object.assign({}, resetMeta(entityType)), entityMeta(entityType, id));\n}\nclass EntityLoadAction {\n    constructor(entityType, id) {\n        this.type = ENTITY_LOAD_ACTION;\n        this.meta = entityLoadMeta(entityType, id);\n    }\n}\nclass EntityFailAction {\n    constructor(entityType, id, error) {\n        this.type = ENTITY_FAIL_ACTION;\n        this.meta = entityFailMeta(entityType, id, error);\n    }\n}\nclass EntitySuccessAction {\n    constructor(entityType, id, payload) {\n        this.payload = payload;\n        this.type = ENTITY_SUCCESS_ACTION;\n        this.meta = entitySuccessMeta(entityType, id);\n    }\n}\nclass EntityResetAction {\n    constructor(entityType, id) {\n        this.type = ENTITY_RESET_ACTION;\n        this.meta = entityResetMeta(entityType, id);\n    }\n}\n\nvar entityLoader_action = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ENTITY_LOAD_ACTION: ENTITY_LOAD_ACTION,\n    ENTITY_FAIL_ACTION: ENTITY_FAIL_ACTION,\n    ENTITY_SUCCESS_ACTION: ENTITY_SUCCESS_ACTION,\n    ENTITY_RESET_ACTION: ENTITY_RESET_ACTION,\n    entityLoadMeta: entityLoadMeta,\n    entityFailMeta: entityFailMeta,\n    entitySuccessMeta: entitySuccessMeta,\n    entityResetMeta: entityResetMeta,\n    EntityLoadAction: EntityLoadAction,\n    EntityFailAction: EntityFailAction,\n    EntitySuccessAction: EntitySuccessAction,\n    EntityResetAction: EntityResetAction\n});\n\nconst initialLoaderState = {\n    loading: false,\n    error: false,\n    success: false,\n    value: undefined,\n};\n/**\n * Higher order reducer that adds generic loading flag to chunk of the state\n *\n * Utilizes \"loader\" meta field of actions to set specific flags for specific\n * action (LOAD, SUCCESS, FAIL, RESET)\n */\nfunction loaderReducer(entityType, reducer) {\n    return (state = initialLoaderState, action) => {\n        if (action.meta &&\n            action.meta.loader &&\n            action.meta.entityType === entityType) {\n            const entity = action.meta.loader;\n            if (entity.load) {\n                return Object.assign(Object.assign({}, state), { loading: true, value: reducer ? reducer(state.value, action) : state.value });\n            }\n            else if (entity.error) {\n                return Object.assign(Object.assign({}, state), { loading: false, error: true, success: false, value: reducer ? reducer(state.value, action) : undefined });\n            }\n            else if (entity.success) {\n                return Object.assign(Object.assign({}, state), { value: reducer ? reducer(state.value, action) : action.payload, loading: false, error: false, success: true });\n            }\n            else {\n                // reset state action\n                return Object.assign(Object.assign({}, initialLoaderState), { value: reducer\n                        ? reducer(initialLoaderState.value, action)\n                        : initialLoaderState.value });\n            }\n        }\n        if (reducer) {\n            const newValue = reducer(state.value, action);\n            if (newValue !== state.value) {\n                return Object.assign(Object.assign({}, state), { value: newValue });\n            }\n        }\n        return state;\n    };\n}\n\nfunction entityStateSelector(state, id) {\n    return state.entities[id] || initialLoaderState;\n}\nfunction entityValueSelector(state, id) {\n    const entityState = entityStateSelector(state, id);\n    return entityState.value;\n}\nfunction entityLoadingSelector(state, id) {\n    const entityState = entityStateSelector(state, id);\n    return entityState.loading;\n}\nfunction entityErrorSelector(state, id) {\n    const entityState = entityStateSelector(state, id);\n    return entityState.error;\n}\nfunction entitySuccessSelector(state, id) {\n    const entityState = entityStateSelector(state, id);\n    return entityState.success;\n}\n\nvar entityLoader_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    entityStateSelector: entityStateSelector,\n    entityValueSelector: entityValueSelector,\n    entityLoadingSelector: entityLoadingSelector,\n    entityErrorSelector: entityErrorSelector,\n    entitySuccessSelector: entitySuccessSelector\n});\n\nconst initialEntityState = { entities: {} };\n/**\n * Higher order reducer for reusing reducer logic for multiple entities\n *\n * Utilizes entityId meta field to target entity by id in actions\n */\nfunction entityReducer(entityType, reducer) {\n    return (state = initialEntityState, action) => {\n        let ids;\n        let partitionPayload = false;\n        if (action.meta &&\n            action.meta.entityType === entityType &&\n            action.meta.entityId !== undefined) {\n            ids = [].concat(action.meta.entityId);\n            // remove selected entities\n            if (action.meta.entityRemove) {\n                if (action.meta.entityId === null) {\n                    return initialEntityState;\n                }\n                else {\n                    let removed = false;\n                    const newEntities = Object.keys(state.entities).reduce((acc, cur) => {\n                        if (ids.includes(cur)) {\n                            removed = true;\n                        }\n                        else {\n                            acc[cur] = state.entities[cur];\n                        }\n                        return acc;\n                    }, {});\n                    return removed ? { entities: newEntities } : state;\n                }\n            }\n            partitionPayload =\n                Array.isArray(action.meta.entityId) && Array.isArray(action.payload);\n        }\n        else {\n            ids = Object.keys(state.entities);\n        }\n        const entityUpdates = {};\n        for (let i = 0; i < ids.length; i++) {\n            const id = ids[i];\n            const subAction = partitionPayload\n                ? Object.assign(Object.assign({}, action), { payload: action.payload[i] }) : action;\n            const newState = reducer(state.entities[id], subAction);\n            if (newState) {\n                entityUpdates[id] = newState;\n            }\n        }\n        if (Object.keys(entityUpdates).length > 0) {\n            return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), entityUpdates) });\n        }\n        return state;\n    };\n}\n\n/**\n * Higher order reducer that wraps LoaderReducer and EntityReducer enhancing\n * single state reducer to support multiple entities with generic loading flags\n */\nfunction entityLoaderReducer(entityType, reducer) {\n    return entityReducer(entityType, loaderReducer(entityType, reducer));\n}\n\nconst PROCESSES_INCREMENT_ACTION = '[PROCESSES LOADER] INCREMENT';\nconst PROCESSES_DECREMENT_ACTION = '[PROCESSES LOADER] DECREMENT';\nconst PROCESSES_LOADER_RESET_ACTION = '[PROCESSES LOADER] RESET';\nfunction processesIncrementMeta(entityType) {\n    return {\n        entityType: entityType,\n        loader: undefined,\n        processesCountDiff: 1,\n    };\n}\nfunction processesDecrementMeta(entityType) {\n    return {\n        entityType: entityType,\n        loader: undefined,\n        processesCountDiff: -1,\n    };\n}\nfunction processesLoaderResetMeta(entityType) {\n    // processes reset action is a reset action for loader reducer, but not the other way around\n    return Object.assign(Object.assign({}, resetMeta(entityType)), { processesCountDiff: null });\n}\nclass ProcessesLoaderResetAction {\n    constructor(entityType) {\n        this.type = PROCESSES_LOADER_RESET_ACTION;\n        this.meta = processesLoaderResetMeta(entityType);\n    }\n}\nclass ProcessesIncrementAction {\n    constructor(entityType) {\n        this.type = PROCESSES_INCREMENT_ACTION;\n        this.meta = processesIncrementMeta(entityType);\n    }\n}\nclass ProcessesDecrementAction {\n    constructor(entityType) {\n        this.type = PROCESSES_DECREMENT_ACTION;\n        this.meta = processesDecrementMeta(entityType);\n    }\n}\n\nvar processesLoader_action = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    PROCESSES_INCREMENT_ACTION: PROCESSES_INCREMENT_ACTION,\n    PROCESSES_DECREMENT_ACTION: PROCESSES_DECREMENT_ACTION,\n    PROCESSES_LOADER_RESET_ACTION: PROCESSES_LOADER_RESET_ACTION,\n    processesIncrementMeta: processesIncrementMeta,\n    processesDecrementMeta: processesDecrementMeta,\n    processesLoaderResetMeta: processesLoaderResetMeta,\n    ProcessesLoaderResetAction: ProcessesLoaderResetAction,\n    ProcessesIncrementAction: ProcessesIncrementAction,\n    ProcessesDecrementAction: ProcessesDecrementAction\n});\n\nconst ENTITY_PROCESSES_LOADER_RESET_ACTION = '[ENTITY] PROCESSES LOADER RESET';\nconst ENTITY_PROCESSES_INCREMENT_ACTION = '[ENTITY] PROCESSES INCREMENT';\nconst ENTITY_PROCESSES_DECREMENT_ACTION = '[ENTITY] PROCESSES DECREMENT';\nfunction entityProcessesLoaderResetMeta(entityType, id) {\n    return Object.assign(Object.assign({}, processesLoaderResetMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityProcessesIncrementMeta(entityType, id) {\n    return Object.assign(Object.assign({}, processesIncrementMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityProcessesDecrementMeta(entityType, id) {\n    return Object.assign(Object.assign({}, processesDecrementMeta(entityType)), entityMeta(entityType, id));\n}\nclass EntityProcessesLoaderResetAction {\n    constructor(entityType, id) {\n        this.type = ENTITY_PROCESSES_LOADER_RESET_ACTION;\n        this.meta = entityProcessesLoaderResetMeta(entityType, id);\n    }\n}\nclass EntityProcessesIncrementAction {\n    constructor(entityType, id) {\n        this.type = ENTITY_PROCESSES_INCREMENT_ACTION;\n        this.meta = entityProcessesIncrementMeta(entityType, id);\n    }\n}\nclass EntityProcessesDecrementAction {\n    constructor(entityType, id) {\n        this.type = ENTITY_PROCESSES_DECREMENT_ACTION;\n        this.meta = entityProcessesDecrementMeta(entityType, id);\n    }\n}\n\nvar entityProcessesLoader_action = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ENTITY_PROCESSES_LOADER_RESET_ACTION: ENTITY_PROCESSES_LOADER_RESET_ACTION,\n    ENTITY_PROCESSES_INCREMENT_ACTION: ENTITY_PROCESSES_INCREMENT_ACTION,\n    ENTITY_PROCESSES_DECREMENT_ACTION: ENTITY_PROCESSES_DECREMENT_ACTION,\n    entityProcessesLoaderResetMeta: entityProcessesLoaderResetMeta,\n    entityProcessesIncrementMeta: entityProcessesIncrementMeta,\n    entityProcessesDecrementMeta: entityProcessesDecrementMeta,\n    EntityProcessesLoaderResetAction: EntityProcessesLoaderResetAction,\n    EntityProcessesIncrementAction: EntityProcessesIncrementAction,\n    EntityProcessesDecrementAction: EntityProcessesDecrementAction\n});\n\nfunction isStableSelector(state) {\n    return state.processesCount === 0 && !state.loading;\n}\nfunction hasPendingProcessesSelector(state) {\n    return state.processesCount > 0;\n}\n\nvar processesLoader_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isStableSelector: isStableSelector,\n    hasPendingProcessesSelector: hasPendingProcessesSelector\n});\n\nconst initialProcessesState = {\n    processesCount: 0,\n};\n/**\n * Higher order reducer that adds processes count\n */\nfunction processesLoaderReducer(entityType, reducer) {\n    return (state = Object.assign(Object.assign({}, initialProcessesState), initialLoaderState), action) => {\n        const loaderState = loaderReducer(entityType, reducer)(state, action);\n        if (action.meta && action.meta.entityType === entityType) {\n            const processesCountDiff = action.meta.processesCountDiff;\n            if (isDevMode() && state.processesCount + processesCountDiff < 0) {\n                console.error(`Action '${action.type}' sets processesCount to value < 0!\\n` +\n                    'Make sure to keep processesCount in sync.\\n' +\n                    'There should always be only one decrement action for each increment action.\\n' +\n                    \"Make sure that you don't reset state in between those actions.\\n\", action);\n            }\n            if (processesCountDiff) {\n                return Object.assign(Object.assign({}, loaderState), { processesCount: state.processesCount\n                        ? state.processesCount + processesCountDiff\n                        : processesCountDiff });\n            }\n            else if (processesCountDiff === null) {\n                // reset action\n                return Object.assign(Object.assign({}, loaderState), initialProcessesState);\n            }\n        }\n        return loaderState;\n    };\n}\n\nconst initialProcessesLoaderState = Object.assign(Object.assign({}, initialLoaderState), initialProcessesState);\nfunction entityHasPendingProcessesSelector(state, id) {\n    const entityState = entityStateSelector(state, id);\n    return hasPendingProcessesSelector(entityState);\n}\nfunction entityIsStableSelector(state, id) {\n    const entityState = entityStateSelector(state, id);\n    return isStableSelector(entityState);\n}\nfunction entityProcessesLoaderStateSelector(state, id) {\n    return state.entities[id] || initialProcessesLoaderState;\n}\n\nvar entityProcessesLoader_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    entityHasPendingProcessesSelector: entityHasPendingProcessesSelector,\n    entityIsStableSelector: entityIsStableSelector,\n    entityProcessesLoaderStateSelector: entityProcessesLoaderStateSelector\n});\n\n/**\n * Higher order reducer that wraps ProcessesLoaderReducer and EntityReducer enhancing\n * single state reducer to support multiple entities with generic processesCount flag\n */\nfunction entityProcessesLoaderReducer(entityType, reducer) {\n    return entityReducer(entityType, processesLoaderReducer(entityType, reducer));\n}\n\nfunction entitySelector(state, id) {\n    return state.entities[id] || undefined;\n}\n\nvar entity_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    entitySelector: entitySelector\n});\n\nconst OBJECT_SEPARATOR = '.';\nfunction getStateSliceValue(keys, state) {\n    return keys\n        .split(OBJECT_SEPARATOR)\n        .reduce((previous, current) => (previous ? previous[current] : undefined), state);\n}\nfunction createShellObject(key, excludeKeys, value) {\n    if (!key || !value || Object.keys(value).length === 0) {\n        return {};\n    }\n    const shell = key.split(OBJECT_SEPARATOR).reduceRight((acc, previous) => {\n        return { [previous]: acc };\n    }, value);\n    return handleExclusions(key, excludeKeys, shell);\n}\nfunction getStateSlice(keys, excludeKeys, state) {\n    if (keys && keys.length === 0) {\n        return {};\n    }\n    let stateSlices = {};\n    for (const currentKey of keys) {\n        const stateValue = getStateSliceValue(currentKey, state);\n        const shell = createShellObject(currentKey, excludeKeys, stateValue);\n        stateSlices = deepMerge(stateSlices, shell);\n    }\n    return stateSlices;\n}\nfunction handleExclusions(key, excludeKeys, value) {\n    const exclusionKeys = getExclusionKeys(key, excludeKeys);\n    if (exclusionKeys.length === 0) {\n        return value;\n    }\n    const finalValue = deepMerge({}, value);\n    for (const currentExclusionKey of exclusionKeys) {\n        const exclusionChunksSplit = currentExclusionKey.split(OBJECT_SEPARATOR);\n        let nestedTemp = finalValue;\n        for (let i = 0; i < exclusionChunksSplit.length; i++) {\n            const currentChunk = exclusionChunksSplit[i];\n            // last iteration\n            if (i === exclusionChunksSplit.length - 1) {\n                if (nestedTemp && nestedTemp[currentChunk]) {\n                    delete nestedTemp[currentChunk];\n                }\n            }\n            else {\n                nestedTemp = nestedTemp[currentChunk];\n            }\n        }\n    }\n    return finalValue;\n}\nfunction getExclusionKeys(key, excludeKeys) {\n    if (!key || !excludeKeys) {\n        return [];\n    }\n    const exclusionKeys = [];\n    for (const exclusionKey of excludeKeys) {\n        if (exclusionKey.includes(key)) {\n            exclusionKeys.push(exclusionKey);\n        }\n    }\n    return exclusionKeys;\n}\nfunction filterKeysByType(keys, type) {\n    if (!keys) {\n        return [];\n    }\n    return Object.keys(keys).filter(key => keys[key] === type);\n}\n\nfunction loaderValueSelector(state) {\n    return state.value;\n}\nfunction loaderLoadingSelector(state) {\n    return state.loading;\n}\nfunction loaderErrorSelector(state) {\n    return state.error;\n}\nfunction loaderSuccessSelector(state) {\n    return state.success;\n}\n\nvar loader_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    loaderValueSelector: loaderValueSelector,\n    loaderLoadingSelector: loaderLoadingSelector,\n    loaderErrorSelector: loaderErrorSelector,\n    loaderSuccessSelector: loaderSuccessSelector\n});\n\nfunction ofLoaderLoad(entityType) {\n    return filter((action) => action.meta &&\n        action.meta.loader &&\n        action.meta.entityType === entityType &&\n        action.meta.loader.load);\n}\nfunction ofLoaderFail(entityType) {\n    return filter((action) => action.meta &&\n        action.meta.loader &&\n        action.meta.entityType === entityType &&\n        action.meta.loader.error);\n}\nfunction ofLoaderSuccess(entityType) {\n    return filter((action) => action.meta &&\n        action.meta.loader &&\n        action.meta.entityType === entityType &&\n        !action.meta.loader.load &&\n        !action.meta.loader.error);\n}\n\nconst AUTH_FEATURE = 'auth';\nconst CLIENT_TOKEN_DATA = '[Auth] Client Token Data';\n\nconst LOAD_CLIENT_TOKEN = '[Token] Load Client Token';\nconst LOAD_CLIENT_TOKEN_FAIL = '[Token] Load Client Token Fail';\nconst LOAD_CLIENT_TOKEN_SUCCESS = '[Token] Load Client Token Success';\nclass LoadClientToken extends LoaderLoadAction {\n    constructor() {\n        super(CLIENT_TOKEN_DATA);\n        this.type = LOAD_CLIENT_TOKEN;\n    }\n}\nclass LoadClientTokenFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CLIENT_TOKEN_DATA, payload);\n        this.payload = payload;\n        this.type = LOAD_CLIENT_TOKEN_FAIL;\n    }\n}\nclass LoadClientTokenSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CLIENT_TOKEN_DATA);\n        this.payload = payload;\n        this.type = LOAD_CLIENT_TOKEN_SUCCESS;\n    }\n}\n\nconst LOGIN = '[Auth] Login';\nconst LOGOUT = '[Auth] Logout';\nconst LOGOUT_CUSTOMER_SUPPORT_AGENT = '[Auth] Logout Customer Support Agent';\nclass Login {\n    constructor() {\n        this.type = LOGIN;\n    }\n}\nclass Logout {\n    constructor() {\n        this.type = LOGOUT;\n    }\n}\n\nconst LOAD_USER_TOKEN = '[Auth] Load User Token';\nconst LOAD_USER_TOKEN_FAIL = '[Auth] Load User Token Fail';\nconst LOAD_USER_TOKEN_SUCCESS = '[Auth] Load User Token Success';\nconst REFRESH_USER_TOKEN = '[Auth] Refresh User Token';\nconst REFRESH_USER_TOKEN_FAIL = '[Auth] Refresh User Token Fail';\nconst REFRESH_USER_TOKEN_SUCCESS = '[Auth] Refresh User Token Success';\nconst REVOKE_USER_TOKEN = '[Auth] Revoke User Token';\nconst REVOKE_USER_TOKEN_FAIL = '[Auth] Revoke User Token Fail';\nconst REVOKE_USER_TOKEN_SUCCESS = '[Auth] Revoke User Token Success';\nclass LoadUserToken {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_USER_TOKEN;\n    }\n}\nclass LoadUserTokenFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_USER_TOKEN_FAIL;\n    }\n}\nclass LoadUserTokenSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_USER_TOKEN_SUCCESS;\n    }\n}\nclass RefreshUserToken {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REFRESH_USER_TOKEN;\n    }\n}\nclass RefreshUserTokenSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REFRESH_USER_TOKEN_SUCCESS;\n    }\n}\nclass RefreshUserTokenFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REFRESH_USER_TOKEN_FAIL;\n    }\n}\nclass RevokeUserToken {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REVOKE_USER_TOKEN;\n    }\n}\nclass RevokeUserTokenSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REVOKE_USER_TOKEN_SUCCESS;\n    }\n}\nclass RevokeUserTokenFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REVOKE_USER_TOKEN_FAIL;\n    }\n}\n\n\n\nvar authGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_CLIENT_TOKEN: LOAD_CLIENT_TOKEN,\n    LOAD_CLIENT_TOKEN_FAIL: LOAD_CLIENT_TOKEN_FAIL,\n    LOAD_CLIENT_TOKEN_SUCCESS: LOAD_CLIENT_TOKEN_SUCCESS,\n    LoadClientToken: LoadClientToken,\n    LoadClientTokenFail: LoadClientTokenFail,\n    LoadClientTokenSuccess: LoadClientTokenSuccess,\n    LOGIN: LOGIN,\n    LOGOUT: LOGOUT,\n    LOGOUT_CUSTOMER_SUPPORT_AGENT: LOGOUT_CUSTOMER_SUPPORT_AGENT,\n    Login: Login,\n    Logout: Logout,\n    LOAD_USER_TOKEN: LOAD_USER_TOKEN,\n    LOAD_USER_TOKEN_FAIL: LOAD_USER_TOKEN_FAIL,\n    LOAD_USER_TOKEN_SUCCESS: LOAD_USER_TOKEN_SUCCESS,\n    REFRESH_USER_TOKEN: REFRESH_USER_TOKEN,\n    REFRESH_USER_TOKEN_FAIL: REFRESH_USER_TOKEN_FAIL,\n    REFRESH_USER_TOKEN_SUCCESS: REFRESH_USER_TOKEN_SUCCESS,\n    REVOKE_USER_TOKEN: REVOKE_USER_TOKEN,\n    REVOKE_USER_TOKEN_FAIL: REVOKE_USER_TOKEN_FAIL,\n    REVOKE_USER_TOKEN_SUCCESS: REVOKE_USER_TOKEN_SUCCESS,\n    LoadUserToken: LoadUserToken,\n    LoadUserTokenFail: LoadUserTokenFail,\n    LoadUserTokenSuccess: LoadUserTokenSuccess,\n    RefreshUserToken: RefreshUserToken,\n    RefreshUserTokenSuccess: RefreshUserTokenSuccess,\n    RefreshUserTokenFail: RefreshUserTokenFail,\n    RevokeUserToken: RevokeUserToken,\n    RevokeUserTokenSuccess: RevokeUserTokenSuccess,\n    RevokeUserTokenFail: RevokeUserTokenFail\n});\n\nconst getAuthState = createFeatureSelector(AUTH_FEATURE);\n\nconst ɵ0 = (state) => state.clientToken;\nconst getClientTokenState = createSelector(getAuthState, ɵ0);\n\nconst getUserTokenSelector = (state) => state.token;\nconst ɵ0$1 = getUserTokenSelector;\nconst ɵ1 = (state) => state.userToken;\nconst getUserTokenState = createSelector(getAuthState, ɵ1);\nconst getUserToken = createSelector(getUserTokenState, getUserTokenSelector);\n\n\n\nvar authGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getClientTokenState: getClientTokenState,\n    ɵ0: ɵ0,\n    getAuthState: getAuthState,\n    getUserTokenState: getUserTokenState,\n    getUserToken: getUserToken,\n    ɵ1: ɵ1\n});\n\nlet AuthService = class AuthService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Loads a new user token\n     * @param userId\n     * @param password\n     */\n    authorize(userId, password) {\n        this.store.dispatch(new LoadUserToken({\n            userId: userId,\n            password: password,\n        }));\n    }\n    /**\n     * This function provides the userId the OCC calls should use, depending\n     * on whether there is an active storefront session or not.\n     *\n     * It returns the userId of the current storefront user or 'anonymous'\n     * in the case there are no signed in user in the storefront.\n     *\n     * The user id of a regular customer session is 'current'.  In the case of an\n     * asm customer emulation session, the userId will be the customerId.\n     */\n    getOccUserId() {\n        return this.getUserToken().pipe(map(userToken => {\n            if (!!userToken && !!userToken.userId) {\n                return userToken.userId;\n            }\n            else {\n                return OCC_USER_ID_ANONYMOUS;\n            }\n        }));\n    }\n    /**\n     * Returns the user's token\n     */\n    getUserToken() {\n        return this.store.pipe(select(getUserToken));\n    }\n    /**\n     * Refreshes the user token\n     * @param token a user token to refresh\n     */\n    refreshUserToken(token) {\n        this.store.dispatch(new RefreshUserToken({\n            refreshToken: token.refresh_token,\n        }));\n    }\n    /**\n     * Store the provided token\n     */\n    authorizeWithToken(token) {\n        this.store.dispatch(new LoadUserTokenSuccess(token));\n    }\n    /**\n     * Logout a storefront customer\n     */\n    logout() {\n        this.getUserToken()\n            .pipe(take(1))\n            .subscribe(userToken => {\n            this.store.dispatch(new Logout());\n            if (Boolean(userToken) && userToken.userId === OCC_USER_ID_CURRENT) {\n                this.store.dispatch(new RevokeUserToken(userToken));\n            }\n        });\n    }\n    /**\n     * Returns a client token.  The client token from the store is returned if there is one.\n     * Otherwise, an new token is fetched from the backend and saved in the store.\n     */\n    getClientToken() {\n        return this.store.pipe(select(getClientTokenState), filter((state) => {\n            if (this.isClientTokenLoaded(state)) {\n                return true;\n            }\n            else {\n                if (!state.loading) {\n                    this.store.dispatch(new LoadClientToken());\n                }\n                return false;\n            }\n        }), map((state) => state.value));\n    }\n    /**\n     * Fetches a clientToken from the backend ans saves it in the store where getClientToken can use it.\n     * The new clientToken is returned.\n     */\n    refreshClientToken() {\n        this.store.dispatch(new LoadClientToken());\n        return this.store.pipe(select(getClientTokenState), filter((state) => this.isClientTokenLoaded(state)), map((state) => state.value));\n    }\n    isClientTokenLoaded(state) {\n        return (state.success || state.error) && !state.loading;\n    }\n    /**\n     * Returns `true` if the user is logged in; and `false` if the user is anonymous.\n     */\n    isUserLoggedIn() {\n        return this.getUserToken().pipe(map(userToken => Boolean(userToken) && Boolean(userToken.access_token)));\n    }\n};\nAuthService.ctorParameters = () => [\n    { type: Store }\n];\nAuthService.ɵprov = ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(ɵɵinject(Store)); }, token: AuthService, providedIn: \"root\" });\nAuthService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AuthService);\n\nlet ClientErrorHandlingService = class ClientErrorHandlingService {\n    constructor(authService) {\n        this.authService = authService;\n    }\n    handleExpiredClientToken(request, next) {\n        return this.authService.refreshClientToken().pipe(take(1), switchMap((token) => {\n            return next.handle(this.createNewRequestWithNewToken(request, token));\n        }));\n    }\n    createNewRequestWithNewToken(request, token) {\n        request = request.clone({\n            setHeaders: {\n                Authorization: `${token.token_type} ${token.access_token}`,\n            },\n        });\n        return request;\n    }\n};\nClientErrorHandlingService.ctorParameters = () => [\n    { type: AuthService }\n];\nClientErrorHandlingService = __decorate([\n    Injectable()\n], ClientErrorHandlingService);\n\nlet WindowRef = class WindowRef {\n    constructor(document) {\n        // it's a workaround to have document property properly typed\n        // see: https://github.com/angular/angular/issues/15640\n        this.document = document;\n    }\n    get nativeWindow() {\n        return typeof window !== 'undefined' ? window : undefined;\n    }\n    get sessionStorage() {\n        return this.nativeWindow ? this.nativeWindow.sessionStorage : undefined;\n    }\n    get localStorage() {\n        return this.nativeWindow ? this.nativeWindow.localStorage : undefined;\n    }\n    /**\n     * Returns an observable for the window resize event and emits an event\n     * every 300ms in case of resizing. An event is simulated initially.\n     *\n     * If there's no window object availale (i.e. in SSR), a null value is emitted.\n     */\n    get resize$() {\n        if (!this.nativeWindow) {\n            return of(null);\n        }\n        else {\n            return fromEvent(this.nativeWindow, 'resize').pipe(debounceTime(300), startWith({ target: this.nativeWindow }), distinctUntilChanged());\n        }\n    }\n};\nWindowRef.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nWindowRef.ɵprov = ɵɵdefineInjectable({ factory: function WindowRef_Factory() { return new WindowRef(ɵɵinject(DOCUMENT)); }, token: WindowRef, providedIn: \"root\" });\nWindowRef = __decorate([\n    Injectable({\n        providedIn: 'root',\n    }),\n    __param(0, Inject(DOCUMENT))\n], WindowRef);\n\nlet UrlParsingService = class UrlParsingService {\n    constructor(router) {\n        this.router = router;\n    }\n    getPrimarySegments(url) {\n        const urlTree = this.router.parseUrl(url);\n        return this._getPrimarySegmentsFromUrlTree(urlTree.root);\n    }\n    _getPrimarySegmentsFromUrlTree(tree) {\n        const segments = tree.segments.map(s => s.path);\n        const childrenSegments = tree.children[PRIMARY_OUTLET]\n            ? this._getPrimarySegmentsFromUrlTree(tree.children[PRIMARY_OUTLET])\n            : [];\n        return segments.concat(childrenSegments);\n    }\n};\nUrlParsingService.ctorParameters = () => [\n    { type: Router }\n];\nUrlParsingService.ɵprov = ɵɵdefineInjectable({ factory: function UrlParsingService_Factory() { return new UrlParsingService(ɵɵinject(Router)); }, token: UrlParsingService, providedIn: \"root\" });\nUrlParsingService = __decorate([\n    Injectable({ providedIn: 'root' })\n], UrlParsingService);\n\nconst isParam = (segment) => segment.startsWith(':');\nconst getParamName = (segment) => segment.slice(1); // it just removes leading ':'\nconst ensureLeadingSlash = (path) => path.startsWith('/') ? path : '/' + path;\nconst removeLeadingSlash = (path) => path.startsWith('/') ? path.slice(1) : path;\n\nclass RoutingConfig {\n}\n\nlet RoutingConfigService = class RoutingConfigService {\n    constructor(config) {\n        this.config = config;\n    }\n    getRouteConfig(routeName) {\n        const routeConfig = this.config && this.config.routing && this.config.routing.routes;\n        const result = routeConfig && routeConfig[routeName];\n        if (!routeConfig || result === undefined) {\n            this.warn(`No path was configured for the named route '${routeName}'!`);\n        }\n        return result;\n    }\n    warn(...args) {\n        if (isDevMode()) {\n            console.warn(...args);\n        }\n    }\n};\nRoutingConfigService.ctorParameters = () => [\n    { type: RoutingConfig }\n];\nRoutingConfigService.ɵprov = ɵɵdefineInjectable({ factory: function RoutingConfigService_Factory() { return new RoutingConfigService(ɵɵinject(RoutingConfig)); }, token: RoutingConfigService, providedIn: \"root\" });\nRoutingConfigService = __decorate([\n    Injectable({ providedIn: 'root' })\n], RoutingConfigService);\n\nlet SemanticPathService = class SemanticPathService {\n    constructor(routingConfigService, urlParser) {\n        this.routingConfigService = routingConfigService;\n        this.urlParser = urlParser;\n        this.ROOT_URL = ['/'];\n    }\n    /**\n     * Returns the first path alias configured for a given route name. It adds `/` at the beginning.\n     */\n    get(routeName) {\n        const routeConfig = this.routingConfigService.getRouteConfig(routeName);\n        return routeConfig && Array.isArray(routeConfig.paths)\n            ? '/' + routeConfig.paths[0]\n            : undefined;\n    }\n    /**\n     * Transforms the array of url commands. Each command can be:\n     * a) string - will be left untouched\n     * b) object { cxRoute: <route name> } - will be replaced with semantic path\n     * c) object { cxRoute: <route name>, params: { ... } } - same as above, but with passed params\n     *\n     * If the first command is the object with the `cxRoute` property, returns an absolute url (with the first element of the array `'/'`)\n     */\n    transform(commands) {\n        if (!Array.isArray(commands)) {\n            commands = [commands];\n        }\n        const result = [];\n        for (const command of commands) {\n            if (!this.isRouteCommand(command)) {\n                // don't modify segment that is not route command:\n                result.push(command);\n            }\n            else {\n                // generate array with url segments for given route command:\n                const partialResult = this.generateUrlPart(command);\n                if (partialResult === null) {\n                    return this.ROOT_URL;\n                }\n                result.push(...partialResult);\n            }\n        }\n        if (this.shouldOutputAbsolute(commands)) {\n            result.unshift('/');\n        }\n        return result;\n    }\n    isRouteCommand(command) {\n        return command && Boolean(command.cxRoute);\n    }\n    shouldOutputAbsolute(commands) {\n        return this.isRouteCommand(commands[0]);\n    }\n    generateUrlPart(command) {\n        this.standarizeRouteCommand(command);\n        if (!command.cxRoute) {\n            return null;\n        }\n        const routeConfig = this.routingConfigService.getRouteConfig(command.cxRoute);\n        // if no route translation was configured, return null:\n        if (!routeConfig || !routeConfig.paths) {\n            return null;\n        }\n        // find first path that can satisfy it's parameters with given parameters\n        const path = this.findPathWithFillableParams(routeConfig, command.params);\n        // if there is no configured path that can be satisfied with given params, return null\n        if (!path) {\n            return null;\n        }\n        const result = this.provideParamsValues(path, command.params, routeConfig.paramsMapping);\n        return result;\n    }\n    standarizeRouteCommand(command) {\n        command.params = command.params || {};\n    }\n    provideParamsValues(path, params, paramsMapping) {\n        return this.urlParser.getPrimarySegments(path).map(segment => {\n            if (isParam(segment)) {\n                const paramName = getParamName(segment);\n                const mappedParamName = this.getMappedParamName(paramName, paramsMapping);\n                return params[mappedParamName];\n            }\n            return segment;\n        });\n    }\n    findPathWithFillableParams(routeConfig, params) {\n        const foundPath = routeConfig.paths.find(path => this.getParams(path).every(paramName => {\n            const mappedParamName = this.getMappedParamName(paramName, routeConfig.paramsMapping);\n            return params[mappedParamName] !== undefined;\n        }));\n        if (foundPath === undefined || foundPath === null) {\n            this.warn(`No configured path matches all its params to given object. `, `Route config: `, routeConfig, `Params object: `, params);\n            return null;\n        }\n        return foundPath;\n    }\n    getParams(path) {\n        return this.urlParser\n            .getPrimarySegments(path)\n            .filter(isParam)\n            .map(getParamName);\n    }\n    getMappedParamName(paramName, paramsMapping) {\n        if (paramsMapping) {\n            return paramsMapping[paramName] || paramName;\n        }\n        return paramName;\n    }\n    warn(...args) {\n        if (isDevMode()) {\n            console.warn(...args);\n        }\n    }\n};\nSemanticPathService.ctorParameters = () => [\n    { type: RoutingConfigService },\n    { type: UrlParsingService }\n];\nSemanticPathService.ɵprov = ɵɵdefineInjectable({ factory: function SemanticPathService_Factory() { return new SemanticPathService(ɵɵinject(RoutingConfigService), ɵɵinject(UrlParsingService)); }, token: SemanticPathService, providedIn: \"root\" });\nSemanticPathService = __decorate([\n    Injectable({ providedIn: 'root' })\n], SemanticPathService);\n\nconst ROUTER_GO = '[Router] Go';\nconst ROUTER_GO_BY_URL = '[Router] Go By Url';\nconst ROUTER_BACK = '[Router] Back';\nconst ROUTER_FORWARD = '[Router] Forward';\nclass RouteGoAction {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ROUTER_GO;\n    }\n}\nclass RouteGoByUrlAction {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ROUTER_GO_BY_URL;\n    }\n}\nclass RouteBackAction {\n    constructor() {\n        this.type = ROUTER_BACK;\n    }\n}\nclass RouteForwardAction {\n    constructor() {\n        this.type = ROUTER_FORWARD;\n    }\n}\n\n\n\nvar routingGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ROUTER_GO: ROUTER_GO,\n    ROUTER_GO_BY_URL: ROUTER_GO_BY_URL,\n    ROUTER_BACK: ROUTER_BACK,\n    ROUTER_FORWARD: ROUTER_FORWARD,\n    RouteGoAction: RouteGoAction,\n    RouteGoByUrlAction: RouteGoByUrlAction,\n    RouteBackAction: RouteBackAction,\n    RouteForwardAction: RouteForwardAction\n});\n\nconst ROUTING_FEATURE = 'router';\n\nconst getRouterFeatureState = createFeatureSelector(ROUTING_FEATURE);\nconst ɵ0$2 = state => state.router;\nconst getRouterState = createSelector(getRouterFeatureState, ɵ0$2);\nconst ɵ1$1 = (routingState) => (routingState.state && routingState.state.context) || { id: '' };\nconst getPageContext = createSelector(getRouterState, ɵ1$1);\nconst ɵ2 = (routingState) => routingState.nextState && routingState.nextState.context;\nconst getNextPageContext = createSelector(getRouterState, ɵ2);\nconst ɵ3 = context => !!context;\nconst isNavigating = createSelector(getNextPageContext, ɵ3);\n\n\n\nvar routingGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getRouterFeatureState: getRouterFeatureState,\n    getRouterState: getRouterState,\n    getPageContext: getPageContext,\n    getNextPageContext: getNextPageContext,\n    isNavigating: isNavigating,\n    ɵ0: ɵ0$2,\n    ɵ1: ɵ1$1,\n    ɵ2: ɵ2,\n    ɵ3: ɵ3\n});\n\nlet RoutingService = class RoutingService {\n    constructor(store, winRef, semanticPathService) {\n        this.store = store;\n        this.winRef = winRef;\n        this.semanticPathService = semanticPathService;\n    }\n    /**\n     * Get the current router state\n     */\n    getRouterState() {\n        return this.store.pipe(select(getRouterState));\n    }\n    /**\n     * Get the `PageContext` from the state\n     */\n    getPageContext() {\n        return this.store.pipe(select(getPageContext));\n    }\n    /**\n     * Get the next `PageContext` from the state\n     */\n    getNextPageContext() {\n        return this.store.pipe(select(getNextPageContext));\n    }\n    /**\n     * Get the `isNavigating` info from the state\n     */\n    isNavigating() {\n        return this.store.pipe(select(isNavigating));\n    }\n    /**\n     * Navigation with a new state into history\n     * @param commands: url commands\n     * @param query\n     * @param extras: Represents the extra options used during navigation.\n     */\n    go(commands, query, extras) {\n        const path = this.semanticPathService.transform(commands);\n        return this.navigate(path, query, extras);\n    }\n    /**\n     * Navigation using URL\n     * @param url\n     */\n    goByUrl(url) {\n        this.store.dispatch(new RouteGoByUrlAction(url));\n    }\n    /**\n     * Navigating back\n     */\n    back() {\n        const isLastPageInApp = this.winRef.document.referrer.includes(this.winRef.nativeWindow.location.origin);\n        if (isLastPageInApp) {\n            this.store.dispatch(new RouteBackAction());\n            return;\n        }\n        this.go(['/']);\n        return;\n    }\n    /**\n     * Navigating forward\n     */\n    forward() {\n        this.store.dispatch(new RouteForwardAction());\n    }\n    /**\n     * Navigation with a new state into history\n     * @param path\n     * @param query\n     * @param extras: Represents the extra options used during navigation.\n     */\n    navigate(path, query, extras) {\n        this.store.dispatch(new RouteGoAction({\n            path,\n            query,\n            extras,\n        }));\n    }\n};\nRoutingService.ctorParameters = () => [\n    { type: Store },\n    { type: WindowRef },\n    { type: SemanticPathService }\n];\nRoutingService.ɵprov = ɵɵdefineInjectable({ factory: function RoutingService_Factory() { return new RoutingService(ɵɵinject(Store), ɵɵinject(WindowRef), ɵɵinject(SemanticPathService)); }, token: RoutingService, providedIn: \"root\" });\nRoutingService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], RoutingService);\n\nlet UserErrorHandlingService = class UserErrorHandlingService {\n    constructor(authService, routingService) {\n        this.authService = authService;\n        this.routingService = routingService;\n    }\n    handleExpiredUserToken(request, next) {\n        return this.handleExpiredToken().pipe(switchMap((token) => {\n            return next.handle(this.createNewRequestWithNewToken(request, token));\n        }));\n    }\n    handleExpiredRefreshToken() {\n        // Logout user\n        this.authService.logout();\n    }\n    handleExpiredToken() {\n        let oldToken;\n        return this.authService.getUserToken().pipe(tap((token) => {\n            if (token.access_token && token.refresh_token && !oldToken) {\n                this.authService.refreshUserToken(token);\n            }\n            else if (!token.access_token && !token.refresh_token) {\n                this.routingService.go({ cxRoute: 'login' });\n            }\n            else if (!token.refresh_token) {\n                this.authService.logout();\n                this.routingService.go({ cxRoute: 'login' });\n            }\n            oldToken = oldToken || token;\n        }), filter((token) => oldToken.access_token !== token.access_token), take(1));\n    }\n    createNewRequestWithNewToken(request, token) {\n        request = request.clone({\n            setHeaders: {\n                Authorization: `${token.token_type} ${token.access_token}`,\n            },\n        });\n        return request;\n    }\n};\nUserErrorHandlingService.ctorParameters = () => [\n    { type: AuthService },\n    { type: RoutingService }\n];\nUserErrorHandlingService = __decorate([\n    Injectable()\n], UserErrorHandlingService);\n\nconst OAUTH_ENDPOINT = '/authorizationserver/oauth/token';\nlet AuthErrorInterceptor = class AuthErrorInterceptor {\n    constructor(userErrorHandlingService, clientErrorHandlingService, authService) {\n        this.userErrorHandlingService = userErrorHandlingService;\n        this.clientErrorHandlingService = clientErrorHandlingService;\n        this.authService = authService;\n    }\n    intercept(request, next) {\n        const isClientTokenRequest = this.isClientTokenRequest(request);\n        if (isClientTokenRequest) {\n            request = InterceptorUtil.removeHeader(USE_CLIENT_TOKEN, request);\n        }\n        return next.handle(request).pipe(catchError((errResponse) => {\n            if (errResponse instanceof HttpErrorResponse) {\n                switch (errResponse.status) {\n                    case 401: // Unauthorized\n                        if (isClientTokenRequest) {\n                            if (this.isExpiredToken(errResponse)) {\n                                return this.clientErrorHandlingService.handleExpiredClientToken(request, next);\n                            }\n                            // user token request\n                        }\n                        else {\n                            if (this.isExpiredToken(errResponse)) {\n                                return this.userErrorHandlingService.handleExpiredUserToken(request, next);\n                            }\n                            else if (\n                            // Refresh expired token\n                            // Check that the OAUTH endpoint was called and the error is for refresh token is expired\n                            errResponse.url.includes(OAUTH_ENDPOINT) &&\n                                errResponse.error.error === 'invalid_token') {\n                                this.userErrorHandlingService.handleExpiredRefreshToken();\n                                return of();\n                            }\n                        }\n                        break;\n                    case 400: // Bad Request\n                        if (errResponse.url.includes(OAUTH_ENDPOINT) &&\n                            errResponse.error.error === 'invalid_grant') {\n                            if (request.body.get('grant_type') === 'refresh_token') {\n                                // refresh token fail, force user logout\n                                this.authService.logout();\n                            }\n                        }\n                        break;\n                }\n            }\n            return throwError(errResponse);\n        }));\n    }\n    isClientTokenRequest(request) {\n        const isRequestMapping = InterceptorUtil.getInterceptorParam(USE_CLIENT_TOKEN, request.headers);\n        return Boolean(isRequestMapping);\n    }\n    isExpiredToken(resp) {\n        if (resp.error &&\n            resp.error.errors &&\n            resp.error.errors instanceof Array &&\n            resp.error.errors[0]) {\n            return resp.error.errors[0].type === 'InvalidTokenError';\n        }\n        return false;\n    }\n};\nAuthErrorInterceptor.ctorParameters = () => [\n    { type: UserErrorHandlingService },\n    { type: ClientErrorHandlingService },\n    { type: AuthService }\n];\nAuthErrorInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function AuthErrorInterceptor_Factory() { return new AuthErrorInterceptor(ɵɵinject(UserErrorHandlingService), ɵɵinject(ClientErrorHandlingService), ɵɵinject(AuthService)); }, token: AuthErrorInterceptor, providedIn: \"root\" });\nAuthErrorInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], AuthErrorInterceptor);\n\nclass DynamicTemplate {\n    static resolve(templateString, templateVariables) {\n        for (const variableLabel of Object.keys(templateVariables)) {\n            const placeholder = new RegExp('\\\\${' + variableLabel + '}', 'g');\n            templateString = templateString.replace(placeholder, templateVariables[variableLabel]);\n        }\n        return templateString;\n    }\n}\n\n/**\n * Helper function for safely getting context parameter config\n *\n * @param config\n * @param parameter\n */\nfunction getContextParameterValues(config, parameter) {\n    return (config.context && config.context[parameter]) || [];\n}\n/**\n * Helper function for calculating default value for context parameter from config\n *\n * @param config\n * @param parameter\n */\nfunction getContextParameterDefault(config, parameter) {\n    const param = getContextParameterValues(config, parameter);\n    return param && param.length ? param[0] : undefined;\n}\n\nconst LOAD_BASE_SITE = '[Site-context] Load BaseSite';\nconst LOAD_BASE_SITE_FAIL = '[Site-context] Load BaseSite Fail';\nconst LOAD_BASE_SITE_SUCCESS = '[Site-context] Load BaseSite Success';\nconst SET_ACTIVE_BASE_SITE = '[Site-context] Set Active BaseSite';\nconst BASE_SITE_CHANGE = '[Site-context] BaseSite Change';\nclass LoadBaseSite {\n    constructor() {\n        this.type = LOAD_BASE_SITE;\n    }\n}\nclass LoadBaseSiteFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_BASE_SITE_FAIL;\n    }\n}\nclass LoadBaseSiteSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_BASE_SITE_SUCCESS;\n    }\n}\nclass SetActiveBaseSite {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = SET_ACTIVE_BASE_SITE;\n    }\n}\nclass BaseSiteChange {\n    constructor() {\n        this.type = BASE_SITE_CHANGE;\n    }\n}\n\nconst LOAD_CURRENCIES = '[Site-context] Load Currencies';\nconst LOAD_CURRENCIES_FAIL = '[Site-context] Load Currencies Fail';\nconst LOAD_CURRENCIES_SUCCESS = '[Site-context] Load Currencies Success';\nconst SET_ACTIVE_CURRENCY = '[Site-context] Set Active Currency';\nconst CURRENCY_CHANGE = '[Site-context] Currency Change';\nclass LoadCurrencies {\n    constructor() {\n        this.type = LOAD_CURRENCIES;\n    }\n}\nclass LoadCurrenciesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CURRENCIES_FAIL;\n    }\n}\nclass LoadCurrenciesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CURRENCIES_SUCCESS;\n    }\n}\nclass SetActiveCurrency {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = SET_ACTIVE_CURRENCY;\n    }\n}\nclass CurrencyChange {\n    constructor() {\n        this.type = CURRENCY_CHANGE;\n    }\n}\n\nconst LOAD_LANGUAGES = '[Site-context] Load Languages';\nconst LOAD_LANGUAGES_FAIL = '[Site-context] Load Languages Fail';\nconst LOAD_LANGUAGES_SUCCESS = '[Site-context] Load Languages Success';\nconst SET_ACTIVE_LANGUAGE = '[Site-context] Set Active Language';\nconst LANGUAGE_CHANGE = '[Site-context] Language Change';\nclass LoadLanguages {\n    constructor() {\n        this.type = LOAD_LANGUAGES;\n    }\n}\nclass LoadLanguagesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_LANGUAGES_FAIL;\n    }\n}\nclass LoadLanguagesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_LANGUAGES_SUCCESS;\n    }\n}\nclass SetActiveLanguage {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = SET_ACTIVE_LANGUAGE;\n    }\n}\nclass LanguageChange {\n    constructor() {\n        this.type = LANGUAGE_CHANGE;\n    }\n}\n\n\n\nvar siteContextGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_BASE_SITE: LOAD_BASE_SITE,\n    LOAD_BASE_SITE_FAIL: LOAD_BASE_SITE_FAIL,\n    LOAD_BASE_SITE_SUCCESS: LOAD_BASE_SITE_SUCCESS,\n    SET_ACTIVE_BASE_SITE: SET_ACTIVE_BASE_SITE,\n    BASE_SITE_CHANGE: BASE_SITE_CHANGE,\n    LoadBaseSite: LoadBaseSite,\n    LoadBaseSiteFail: LoadBaseSiteFail,\n    LoadBaseSiteSuccess: LoadBaseSiteSuccess,\n    SetActiveBaseSite: SetActiveBaseSite,\n    BaseSiteChange: BaseSiteChange,\n    LOAD_CURRENCIES: LOAD_CURRENCIES,\n    LOAD_CURRENCIES_FAIL: LOAD_CURRENCIES_FAIL,\n    LOAD_CURRENCIES_SUCCESS: LOAD_CURRENCIES_SUCCESS,\n    SET_ACTIVE_CURRENCY: SET_ACTIVE_CURRENCY,\n    CURRENCY_CHANGE: CURRENCY_CHANGE,\n    LoadCurrencies: LoadCurrencies,\n    LoadCurrenciesFail: LoadCurrenciesFail,\n    LoadCurrenciesSuccess: LoadCurrenciesSuccess,\n    SetActiveCurrency: SetActiveCurrency,\n    CurrencyChange: CurrencyChange,\n    LOAD_LANGUAGES: LOAD_LANGUAGES,\n    LOAD_LANGUAGES_FAIL: LOAD_LANGUAGES_FAIL,\n    LOAD_LANGUAGES_SUCCESS: LOAD_LANGUAGES_SUCCESS,\n    SET_ACTIVE_LANGUAGE: SET_ACTIVE_LANGUAGE,\n    LANGUAGE_CHANGE: LANGUAGE_CHANGE,\n    LoadLanguages: LoadLanguages,\n    LoadLanguagesFail: LoadLanguagesFail,\n    LoadLanguagesSuccess: LoadLanguagesSuccess,\n    SetActiveLanguage: SetActiveLanguage,\n    LanguageChange: LanguageChange\n});\n\nconst SITE_CONTEXT_FEATURE = 'siteContext';\n\nconst getSiteContextState = createFeatureSelector(SITE_CONTEXT_FEATURE);\n\nconst ɵ0$3 = (state) => state && state.baseSite && state.baseSite.activeSite;\nconst getActiveBaseSite = createSelector(getSiteContextState, ɵ0$3);\nconst ɵ1$2 = (state) => state && state.baseSite && state.baseSite.details;\nconst getBaseSiteData = createSelector(getSiteContextState, ɵ1$2);\n\nconst currenciesEntitiesSelector = (state) => state.entities;\nconst ɵ0$4 = currenciesEntitiesSelector;\nconst activeCurrencySelector = (state) => state.activeCurrency;\nconst ɵ1$3 = activeCurrencySelector;\nconst ɵ2$1 = (state) => state.currencies;\nconst getCurrenciesState = createSelector(getSiteContextState, ɵ2$1);\nconst getCurrenciesEntities = createSelector(getCurrenciesState, currenciesEntitiesSelector);\nconst getActiveCurrency = createSelector(getCurrenciesState, activeCurrencySelector);\nconst ɵ3$1 = entities => {\n    return entities\n        ? Object.keys(entities).map(isocode => entities[isocode])\n        : null;\n};\nconst getAllCurrencies = createSelector(getCurrenciesEntities, ɵ3$1);\n\nconst activeLanguageSelector = (state) => state.activeLanguage;\nconst ɵ0$5 = activeLanguageSelector;\nconst languagesEntitiesSelector = (state) => state.entities;\nconst ɵ1$4 = languagesEntitiesSelector;\nconst ɵ2$2 = (state) => state.languages;\nconst getLanguagesState = createSelector(getSiteContextState, ɵ2$2);\nconst getLanguagesEntities = createSelector(getLanguagesState, languagesEntitiesSelector);\nconst getActiveLanguage = createSelector(getLanguagesState, activeLanguageSelector);\nconst ɵ3$2 = entities => {\n    return entities\n        ? Object.keys(entities).map(isocode => entities[isocode])\n        : null;\n};\nconst getAllLanguages = createSelector(getLanguagesEntities, ɵ3$2);\n\n\n\nvar siteContextGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getActiveBaseSite: getActiveBaseSite,\n    getBaseSiteData: getBaseSiteData,\n    ɵ0: ɵ0$3,\n    ɵ1: ɵ1$2,\n    getCurrenciesState: getCurrenciesState,\n    getCurrenciesEntities: getCurrenciesEntities,\n    getActiveCurrency: getActiveCurrency,\n    getAllCurrencies: getAllCurrencies,\n    ɵ2: ɵ2$1,\n    ɵ3: ɵ3$1,\n    getLanguagesState: getLanguagesState,\n    getLanguagesEntities: getLanguagesEntities,\n    getActiveLanguage: getActiveLanguage,\n    getAllLanguages: getAllLanguages,\n    getSiteContextState: getSiteContextState\n});\n\nconst LANGUAGE_CONTEXT_ID = 'language';\nconst CURRENCY_CONTEXT_ID = 'currency';\nconst BASE_SITE_CONTEXT_ID = 'baseSite';\n\nlet BaseSiteService = class BaseSiteService {\n    constructor(store, config) {\n        this.store = store;\n        this.config = config;\n    }\n    /**\n     * Represents the current baseSite uid.\n     */\n    getActive() {\n        return this.store.pipe(select(getActiveBaseSite), filter(active => Boolean(active)));\n    }\n    /**\n     * We currently don't support switching baseSite at run time\n     */\n    getAll() {\n        return this.getActive().pipe(map(baseSite => [baseSite]));\n    }\n    setActive(baseSite) {\n        return this.store\n            .pipe(select(getActiveBaseSite), take(1))\n            .subscribe(activeBaseSite => {\n            if (baseSite && activeBaseSite !== baseSite) {\n                this.store.dispatch(new SetActiveBaseSite(baseSite));\n            }\n        });\n    }\n    /**\n     * Initializes the active baseSite.\n     */\n    initialize() {\n        this.setActive(getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID));\n    }\n    /**\n     * Get the base site details data\n     */\n    getBaseSiteData() {\n        return this.store.pipe(select(getBaseSiteData), tap(baseSite => {\n            if (Object.keys(baseSite).length === 0) {\n                this.store.dispatch(new LoadBaseSite());\n            }\n        }));\n    }\n};\nBaseSiteService.ctorParameters = () => [\n    { type: Store },\n    { type: SiteContextConfig }\n];\nBaseSiteService = __decorate([\n    Injectable()\n], BaseSiteService);\n\nlet OccEndpointsService = class OccEndpointsService {\n    constructor(config, baseSiteService) {\n        this.config = config;\n        this.baseSiteService = baseSiteService;\n        this.SCOPE_SUFFIX = '_scopes';\n        this.activeBaseSite =\n            getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID) || '';\n        if (this.baseSiteService) {\n            this.baseSiteService\n                .getActive()\n                .subscribe(value => (this.activeBaseSite = value));\n        }\n    }\n    /**\n     * Returns and endpoint starting from the OCC baseUrl (no baseSite)\n     * @param endpoint Endpoint suffix\n     */\n    getRawEndpoint(endpoint) {\n        if (!this.config || !this.config.backend || !this.config.backend.occ) {\n            return '';\n        }\n        endpoint = this.config.backend.occ.endpoints[endpoint];\n        if (!endpoint.startsWith('/')) {\n            endpoint = '/' + endpoint;\n        }\n        return this.config.backend.occ.baseUrl + endpoint;\n    }\n    /**\n     * Returns base OCC endpoint (baseUrl + prefix + baseSite)\n     */\n    getBaseEndpoint() {\n        if (!this.config || !this.config.backend || !this.config.backend.occ) {\n            return '';\n        }\n        return ((this.config.backend.occ.baseUrl || '') +\n            this.config.backend.occ.prefix +\n            this.activeBaseSite);\n    }\n    /**\n     * Returns an OCC endpoint including baseUrl and baseSite\n     * @param endpoint Endpoint suffix\n     */\n    getEndpoint(endpoint) {\n        if (!endpoint.startsWith('/')) {\n            endpoint = '/' + endpoint;\n        }\n        return this.getBaseEndpoint() + endpoint;\n    }\n    /**\n     * Returns a fully qualified OCC Url (including baseUrl and baseSite)\n     * @param endpoint Name of the OCC endpoint key config\n     * @param urlParams  URL parameters\n     * @param queryParams Query parameters\n     * @param scope\n     */\n    getUrl(endpoint, urlParams, queryParams, scope = '') {\n        endpoint = this.getEndpointForScope(endpoint, scope);\n        if (urlParams) {\n            Object.keys(urlParams).forEach(key => {\n                urlParams[key] = encodeURIComponent(urlParams[key]);\n            });\n            endpoint = DynamicTemplate.resolve(endpoint, urlParams);\n        }\n        if (queryParams) {\n            let httpParamsOptions;\n            if (endpoint.includes('?')) {\n                let queryParamsFromEndpoint;\n                [endpoint, queryParamsFromEndpoint] = endpoint.split('?');\n                httpParamsOptions = { fromString: queryParamsFromEndpoint };\n            }\n            let httpParams = new HttpParams(httpParamsOptions);\n            Object.keys(queryParams).forEach(key => {\n                const value = queryParams[key];\n                if (value !== undefined) {\n                    if (value === null) {\n                        httpParams = httpParams.delete(key);\n                    }\n                    else {\n                        httpParams = httpParams.set(key, value);\n                    }\n                }\n            });\n            const params = httpParams.toString();\n            if (params.length) {\n                endpoint += '?' + params;\n            }\n        }\n        return this.getEndpoint(endpoint);\n    }\n    getEndpointForScope(endpoint, scope) {\n        const endpointsConfig = this.config.backend &&\n            this.config.backend.occ &&\n            this.config.backend.occ.endpoints;\n        if (scope) {\n            const endpointConfig = endpointsConfig[`${endpoint}${this.SCOPE_SUFFIX}`];\n            if (endpointConfig && endpointConfig[scope]) {\n                return endpointConfig[scope];\n            }\n            if (isDevMode()) {\n                console.warn(`${endpoint} endpoint configuration missing for scope \"${scope}\"`);\n            }\n        }\n        return endpointsConfig[endpoint] || endpoint;\n    }\n};\nOccEndpointsService.ctorParameters = () => [\n    { type: OccConfig },\n    { type: BaseSiteService, decorators: [{ type: Optional }] }\n];\nOccEndpointsService.ɵprov = ɵɵdefineInjectable({ factory: function OccEndpointsService_Factory() { return new OccEndpointsService(ɵɵinject(OccConfig), ɵɵinject(BaseSiteService, 8)); }, token: OccEndpointsService, providedIn: \"root\" });\nOccEndpointsService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    }),\n    __param(1, Optional())\n], OccEndpointsService);\n\nlet ClientTokenInterceptor = class ClientTokenInterceptor {\n    constructor(authService, occEndpoints) {\n        this.authService = authService;\n        this.occEndpoints = occEndpoints;\n    }\n    intercept(request, next) {\n        return this.getClientToken(request).pipe(take(1), switchMap((token) => {\n            if (token &&\n                request.url.includes(this.occEndpoints.getBaseEndpoint())) {\n                request = request.clone({\n                    setHeaders: {\n                        Authorization: `${token.token_type} ${token.access_token}`,\n                    },\n                });\n            }\n            return next.handle(request);\n        }));\n    }\n    getClientToken(request) {\n        if (InterceptorUtil.getInterceptorParam(USE_CLIENT_TOKEN, request.headers)) {\n            return this.authService.getClientToken();\n        }\n        return of(null);\n    }\n};\nClientTokenInterceptor.ctorParameters = () => [\n    { type: AuthService },\n    { type: OccEndpointsService }\n];\nClientTokenInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function ClientTokenInterceptor_Factory() { return new ClientTokenInterceptor(ɵɵinject(AuthService), ɵɵinject(OccEndpointsService)); }, token: ClientTokenInterceptor, providedIn: \"root\" });\nClientTokenInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], ClientTokenInterceptor);\n\nlet UserTokenInterceptor = class UserTokenInterceptor {\n    constructor(authService, occEndpoints) {\n        this.authService = authService;\n        this.occEndpoints = occEndpoints;\n    }\n    intercept(request, next) {\n        return this.authService.getUserToken().pipe(take(1), switchMap(token => {\n            if (token &&\n                this.isOccUrl(request.url) &&\n                !request.headers.get('Authorization')) {\n                request = request.clone({\n                    setHeaders: {\n                        Authorization: `${token.token_type} ${token.access_token}`,\n                    },\n                });\n            }\n            return next.handle(request);\n        }));\n    }\n    isOccUrl(url) {\n        return url.includes(this.occEndpoints.getBaseEndpoint());\n    }\n};\nUserTokenInterceptor.ctorParameters = () => [\n    { type: AuthService },\n    { type: OccEndpointsService }\n];\nUserTokenInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function UserTokenInterceptor_Factory() { return new UserTokenInterceptor(ɵɵinject(AuthService), ɵɵinject(OccEndpointsService)); }, token: UserTokenInterceptor, providedIn: \"root\" });\nUserTokenInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], UserTokenInterceptor);\n\nlet TokenRevocationInterceptor = class TokenRevocationInterceptor {\n    constructor() {\n    }\n    intercept(request, next) {\n        const isTokenRevocationRequest = this.isTokenRevocationRequest(request);\n        if (isTokenRevocationRequest) {\n            request = InterceptorUtil.removeHeader(TOKEN_REVOCATION_HEADER, request);\n        }\n        return next.handle(request).pipe(catchError((error) => {\n            if (isTokenRevocationRequest) {\n                return EMPTY;\n            }\n            return throwError(error);\n        }));\n    }\n    isTokenRevocationRequest(request) {\n        const isTokenRevocationHeaderPresent = InterceptorUtil.getInterceptorParam(TOKEN_REVOCATION_HEADER, request.headers);\n        return Boolean(isTokenRevocationHeaderPresent);\n    }\n};\nTokenRevocationInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function TokenRevocationInterceptor_Factory() { return new TokenRevocationInterceptor(); }, token: TokenRevocationInterceptor, providedIn: \"root\" });\nTokenRevocationInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], TokenRevocationInterceptor);\n\nconst interceptors = [\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: ClientTokenInterceptor,\n        multi: true,\n    },\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: UserTokenInterceptor,\n        multi: true,\n    },\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: AuthErrorInterceptor,\n        multi: true,\n    },\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: TokenRevocationInterceptor,\n        multi: true,\n    },\n];\n\nlet ClientAuthenticationTokenService = class ClientAuthenticationTokenService {\n    constructor(config, http, occEndpointsService) {\n        this.config = config;\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n    }\n    loadClientAuthenticationToken() {\n        const url = this.occEndpointsService.getRawEndpoint('login');\n        const params = new HttpParams()\n            .set('client_id', encodeURIComponent(this.config.authentication.client_id))\n            .set('client_secret', encodeURIComponent(this.config.authentication.client_secret))\n            .set('grant_type', 'client_credentials');\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http.post(url, params, { headers });\n    }\n};\nClientAuthenticationTokenService.ctorParameters = () => [\n    { type: AuthConfig },\n    { type: HttpClient },\n    { type: OccEndpointsService }\n];\nClientAuthenticationTokenService = __decorate([\n    Injectable()\n], ClientAuthenticationTokenService);\n\nlet UserAuthenticationTokenService = class UserAuthenticationTokenService {\n    constructor(http, config, occEndpointsService) {\n        this.http = http;\n        this.config = config;\n        this.occEndpointsService = occEndpointsService;\n    }\n    loadToken(userId, password) {\n        const url = this.occEndpointsService.getRawEndpoint('login');\n        const params = new HttpParams()\n            .set('client_id', this.config.authentication.client_id)\n            .set('client_secret', this.config.authentication.client_secret)\n            .set('grant_type', 'password')\n            .set('username', userId)\n            .set('password', password);\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http\n            .post(url, params, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n    refreshToken(refreshToken) {\n        const url = this.occEndpointsService.getRawEndpoint('login');\n        const params = new HttpParams()\n            .set('client_id', encodeURIComponent(this.config.authentication.client_id))\n            .set('client_secret', encodeURIComponent(this.config.authentication.client_secret))\n            .set('refresh_token', encodeURI(refreshToken))\n            .set('grant_type', 'refresh_token');\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http\n            .post(url, params, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n    revoke(userToken) {\n        const url = this.occEndpointsService.getRawEndpoint('revoke');\n        const headers = InterceptorUtil.createHeader(TOKEN_REVOCATION_HEADER, true, new HttpHeaders({\n            Authorization: `${userToken.token_type} ${userToken.access_token}`,\n            'Content-Type': 'application/x-www-form-urlencoded',\n        }));\n        const params = new HttpParams().set('token', userToken.access_token);\n        return this.http\n            .post(url, params, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nUserAuthenticationTokenService.ctorParameters = () => [\n    { type: HttpClient },\n    { type: AuthConfig },\n    { type: OccEndpointsService }\n];\nUserAuthenticationTokenService = __decorate([\n    Injectable()\n], UserAuthenticationTokenService);\n\nconst AuthServices = [\n    ClientAuthenticationTokenService,\n    ClientErrorHandlingService,\n    UserAuthenticationTokenService,\n    UserErrorHandlingService,\n];\n\nvar StorageSyncType;\n(function (StorageSyncType) {\n    StorageSyncType[\"NO_STORAGE\"] = \"NO_STORAGE\";\n    StorageSyncType[\"LOCAL_STORAGE\"] = \"LOCAL_STORAGE\";\n    StorageSyncType[\"SESSION_STORAGE\"] = \"SESSION_STORAGE\";\n})(StorageSyncType || (StorageSyncType = {}));\nvar StateTransferType;\n(function (StateTransferType) {\n    StateTransferType[\"TRANSFER_STATE\"] = \"SSR\";\n})(StateTransferType || (StateTransferType = {}));\nclass StateConfig {\n}\n\nconst DEFAULT_LOCAL_STORAGE_KEY = 'spartacus-local-data';\nconst DEFAULT_SESSION_STORAGE_KEY = 'spartacus-session-data';\nconst defaultStateConfig = {\n    state: {\n        storageSync: {\n            localStorageKeyName: DEFAULT_LOCAL_STORAGE_KEY,\n            sessionStorageKeyName: DEFAULT_SESSION_STORAGE_KEY,\n            keys: {},\n            excludeKeys: {},\n        },\n    },\n};\n\nfunction getStorageSyncReducer(winRef, config) {\n    if (!winRef.nativeWindow ||\n        !config ||\n        !config.state ||\n        !config.state.storageSync ||\n        !config.state.storageSync.keys) {\n        return reducer => reducer;\n    }\n    const storageSyncConfig = config.state.storageSync;\n    return (reducer) => {\n        return (state, action) => {\n            const newState = reducer(state, action);\n            if (action.type === INIT || action.type === UPDATE) {\n                const rehydratedState = rehydrate(config, winRef);\n                return deepMerge({}, newState, rehydratedState);\n            }\n            if (action.type !== INIT) {\n                // handle local storage\n                const localStorageKeys = filterKeysByType(storageSyncConfig.keys, StorageSyncType.LOCAL_STORAGE);\n                const localStorageExclusionKeys = filterKeysByType(storageSyncConfig.excludeKeys, StorageSyncType.LOCAL_STORAGE);\n                const localStorageStateSlices = getStateSlice(localStorageKeys, localStorageExclusionKeys, newState);\n                persistToStorage(config.state.storageSync.localStorageKeyName, localStorageStateSlices, winRef.localStorage);\n                // handle session storage\n                const sessionStorageKeys = filterKeysByType(storageSyncConfig.keys, StorageSyncType.SESSION_STORAGE);\n                const sessionStorageExclusionKeys = filterKeysByType(storageSyncConfig.excludeKeys, StorageSyncType.SESSION_STORAGE);\n                const sessionStorageStateSlices = getStateSlice(sessionStorageKeys, sessionStorageExclusionKeys, newState);\n                persistToStorage(config.state.storageSync.sessionStorageKeyName, sessionStorageStateSlices, winRef.sessionStorage);\n            }\n            return newState;\n        };\n    };\n}\nfunction rehydrate(config, winRef) {\n    const localStorageValue = readFromStorage(winRef.localStorage, config.state.storageSync.localStorageKeyName);\n    const sessionStorageValue = readFromStorage(winRef.sessionStorage, config.state.storageSync.sessionStorageKeyName);\n    return deepMerge(localStorageValue, sessionStorageValue);\n}\nfunction exists(value) {\n    if (value != null) {\n        if (typeof value === 'object') {\n            return Object.keys(value).length !== 0;\n        }\n        return value !== '';\n    }\n    return false;\n}\nfunction getStorage(storageType, winRef) {\n    let storage;\n    switch (storageType) {\n        case StorageSyncType.LOCAL_STORAGE: {\n            storage = winRef.localStorage;\n            break;\n        }\n        case StorageSyncType.SESSION_STORAGE: {\n            storage = winRef.sessionStorage;\n            break;\n        }\n        case StorageSyncType.NO_STORAGE: {\n            storage = undefined;\n            break;\n        }\n        default: {\n            storage = winRef.sessionStorage;\n        }\n    }\n    return storage;\n}\nfunction persistToStorage(configKey, value, storage) {\n    if (!isSsr(storage) && value) {\n        storage.setItem(configKey, JSON.stringify(value));\n    }\n}\nfunction readFromStorage(storage, key) {\n    if (isSsr(storage)) {\n        return;\n    }\n    const storageValue = storage.getItem(key);\n    if (!storageValue) {\n        return;\n    }\n    return JSON.parse(storageValue);\n}\nfunction isSsr(storage) {\n    return !Boolean(storage);\n}\n\nconst CX_KEY = makeStateKey('cx-state');\nfunction getTransferStateReducer(platformId, transferState, config) {\n    if (transferState &&\n        config &&\n        config.state &&\n        config.state.ssrTransfer &&\n        config.state.ssrTransfer.keys) {\n        if (isPlatformBrowser(platformId)) {\n            return getBrowserTransferStateReducer(transferState, config.state.ssrTransfer.keys);\n        }\n        else if (isPlatformServer(platformId)) {\n            return getServerTransferStateReducer(transferState, config.state.ssrTransfer.keys);\n        }\n    }\n    return reducer => reducer;\n}\nfunction getServerTransferStateReducer(transferState, keys) {\n    const transferStateKeys = filterKeysByType(keys, StateTransferType.TRANSFER_STATE);\n    return function (reducer) {\n        return function (state, action) {\n            const newState = reducer(state, action);\n            if (newState) {\n                const stateSlice = getStateSlice(transferStateKeys, [], newState);\n                transferState.set(CX_KEY, stateSlice);\n            }\n            return newState;\n        };\n    };\n}\nfunction getBrowserTransferStateReducer(transferState, keys) {\n    const transferStateKeys = filterKeysByType(keys, StateTransferType.TRANSFER_STATE);\n    return function (reducer) {\n        return function (state, action) {\n            if (action.type === INIT) {\n                if (!state) {\n                    state = reducer(state, action);\n                }\n                // we should not utilize transfer state if user is logged in\n                const authState = state[AUTH_FEATURE];\n                const isLoggedIn = authState && authState.userToken && authState.userToken.token;\n                if (!isLoggedIn && transferState.hasKey(CX_KEY)) {\n                    const cxKey = transferState.get(CX_KEY, {});\n                    const transferredStateSlice = getStateSlice(transferStateKeys, [], cxKey);\n                    state = deepMerge({}, state, transferredStateSlice);\n                }\n                return state;\n            }\n            return reducer(state, action);\n        };\n    };\n}\n\nconst TRANSFER_STATE_META_REDUCER = new InjectionToken('TransferStateMetaReducer');\nconst STORAGE_SYNC_META_REDUCER = new InjectionToken('StorageSyncMetaReducer');\nconst ɵ0$6 = getTransferStateReducer, ɵ1$5 = getStorageSyncReducer;\nconst stateMetaReducers = [\n    {\n        provide: TRANSFER_STATE_META_REDUCER,\n        useFactory: ɵ0$6,\n        deps: [\n            PLATFORM_ID,\n            [new Optional(), TransferState],\n            [new Optional(), Config],\n        ],\n    },\n    {\n        provide: STORAGE_SYNC_META_REDUCER,\n        useFactory: ɵ1$5,\n        deps: [WindowRef, [new Optional(), Config]],\n    },\n    {\n        provide: META_REDUCERS,\n        useExisting: TRANSFER_STATE_META_REDUCER,\n        multi: true,\n    },\n    {\n        provide: META_REDUCERS,\n        useExisting: STORAGE_SYNC_META_REDUCER,\n        multi: true,\n    },\n];\n\nvar StateModule_1;\nlet StateModule = StateModule_1 = class StateModule {\n    static forRoot() {\n        return {\n            ngModule: StateModule_1,\n            providers: [\n                ...stateMetaReducers,\n                provideConfig(defaultStateConfig),\n                { provide: StateConfig, useExisting: Config },\n            ],\n        };\n    }\n};\nStateModule = StateModule_1 = __decorate([\n    NgModule({})\n], StateModule);\n\nconst UNKNOWN_ERROR = {\n    error: 'unknown error',\n};\nconst circularReplacer = () => {\n    const seen = new WeakSet();\n    return (_key, value) => {\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n};\nconst ɵ0$7 = circularReplacer;\nfunction makeErrorSerializable(error) {\n    if (error instanceof Error) {\n        return {\n            message: error.message,\n            type: error.name,\n            reason: error.stack,\n        };\n    }\n    if (error instanceof HttpErrorResponse) {\n        let serializableError = error.error;\n        if (isObject(error.error)) {\n            serializableError = JSON.stringify(error.error, circularReplacer());\n        }\n        return {\n            message: error.message,\n            error: serializableError,\n            status: error.status,\n            statusText: error.statusText,\n            url: error.url,\n        };\n    }\n    return isObject(error) ? UNKNOWN_ERROR : error;\n}\n\nlet ClientTokenEffect = class ClientTokenEffect {\n    constructor(actions$, clientAuthenticationTokenService) {\n        this.actions$ = actions$;\n        this.clientAuthenticationTokenService = clientAuthenticationTokenService;\n        this.loadClientToken$ = this.actions$.pipe(ofType(LOAD_CLIENT_TOKEN), exhaustMap(() => {\n            return this.clientAuthenticationTokenService\n                .loadClientAuthenticationToken()\n                .pipe(map((token) => {\n                return new LoadClientTokenSuccess(token);\n            }), catchError(error => of(new LoadClientTokenFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nClientTokenEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: ClientAuthenticationTokenService }\n];\n__decorate([\n    Effect()\n], ClientTokenEffect.prototype, \"loadClientToken$\", void 0);\nClientTokenEffect = __decorate([\n    Injectable()\n], ClientTokenEffect);\n\nlet UserTokenEffects = class UserTokenEffects {\n    constructor(actions$, userTokenService) {\n        this.actions$ = actions$;\n        this.userTokenService = userTokenService;\n        this.loadUserToken$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN), map((action) => action.payload), mergeMap(({ userId, password }) => this.userTokenService.loadToken(userId, password).pipe(map((token) => {\n            const date = new Date();\n            date.setSeconds(date.getSeconds() + token.expires_in);\n            token.expiration_time = date.toJSON();\n            token.userId = OCC_USER_ID_CURRENT;\n            return new LoadUserTokenSuccess(token);\n        }), catchError(error => of(new LoadUserTokenFail(makeErrorSerializable(error)))))));\n        this.login$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), map(() => new Login()));\n        this.refreshUserToken$ = this.actions$.pipe(ofType(REFRESH_USER_TOKEN), map((action) => action.payload), exhaustMap(({ refreshToken }) => {\n            return this.userTokenService.refreshToken(refreshToken).pipe(map((token) => {\n                const date = new Date();\n                date.setSeconds(date.getSeconds() + token.expires_in);\n                token.expiration_time = date.toJSON();\n                return new RefreshUserTokenSuccess(token);\n            }, catchError(error => of(new RefreshUserTokenFail(makeErrorSerializable(error))))));\n        }));\n        this.revokeUserToken$ = this.actions$.pipe(ofType(REVOKE_USER_TOKEN), map((action) => {\n            return action.payload;\n        }), mergeMap((userToken) => {\n            return this.userTokenService.revoke(userToken).pipe(map(() => new RevokeUserTokenSuccess(userToken)), catchError(error => of(new RevokeUserTokenFail(error))));\n        }));\n    }\n};\nUserTokenEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserAuthenticationTokenService }\n];\n__decorate([\n    Effect()\n], UserTokenEffects.prototype, \"loadUserToken$\", void 0);\n__decorate([\n    Effect()\n], UserTokenEffects.prototype, \"login$\", void 0);\n__decorate([\n    Effect()\n], UserTokenEffects.prototype, \"refreshUserToken$\", void 0);\n__decorate([\n    Effect()\n], UserTokenEffects.prototype, \"revokeUserToken$\", void 0);\nUserTokenEffects = __decorate([\n    Injectable()\n], UserTokenEffects);\n\nconst effects = [UserTokenEffects, ClientTokenEffect];\n\nconst initialState = {};\nfunction reducer(state = initialState, action) {\n    switch (action.type) {\n        case LOAD_USER_TOKEN:\n        case REFRESH_USER_TOKEN: {\n            return Object.assign({}, state);\n        }\n        case LOAD_USER_TOKEN_SUCCESS:\n        case REFRESH_USER_TOKEN_SUCCESS: {\n            return Object.assign(Object.assign({}, state), action.payload);\n        }\n        case LOAD_USER_TOKEN_FAIL:\n        case REFRESH_USER_TOKEN_FAIL: {\n            return Object.assign({}, state);\n        }\n    }\n    return state;\n}\n\nfunction getReducers() {\n    return {\n        userToken: combineReducers({ token: reducer }),\n        clientToken: loaderReducer(CLIENT_TOKEN_DATA),\n    };\n}\nconst reducerToken = new InjectionToken('AuthReducers');\nconst reducerProvider = {\n    provide: reducerToken,\n    useFactory: getReducers,\n};\nfunction clearAuthState(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT) {\n            state = Object.assign(Object.assign({}, state), { userToken: undefined });\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers = [clearAuthState];\n\nfunction authStoreConfigFactory() {\n    // if we want to reuse AUTH_FEATURE const in config, we have to use factory instead of plain object\n    const config = {\n        state: {\n            storageSync: {\n                keys: {\n                    'auth.userToken.token.access_token': StorageSyncType.LOCAL_STORAGE,\n                    'auth.userToken.token.token_type': StorageSyncType.LOCAL_STORAGE,\n                    'auth.userToken.token.expires_in': StorageSyncType.LOCAL_STORAGE,\n                    'auth.userToken.token.expiration_time': StorageSyncType.LOCAL_STORAGE,\n                    'auth.userToken.token.scope': StorageSyncType.LOCAL_STORAGE,\n                    'auth.userToken.token.userId': StorageSyncType.LOCAL_STORAGE,\n                },\n            },\n        },\n    };\n    return config;\n}\nlet AuthStoreModule = class AuthStoreModule {\n};\nAuthStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StateModule,\n            StoreModule.forFeature(AUTH_FEATURE, reducerToken, { metaReducers }),\n            EffectsModule.forFeature(effects),\n            ConfigModule.withConfigFactory(authStoreConfigFactory),\n        ],\n        providers: [reducerProvider],\n    })\n], AuthStoreModule);\n\nvar AuthModule_1;\nlet AuthModule = AuthModule_1 = class AuthModule {\n    static forRoot() {\n        return {\n            ngModule: AuthModule_1,\n            providers: [\n                ...interceptors,\n                ...AuthServices,\n                { provide: AuthConfig, useExisting: Config },\n            ],\n        };\n    }\n};\nAuthModule = AuthModule_1 = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            AuthStoreModule,\n            ConfigModule.withConfig(defaultAuthConfig),\n        ],\n    })\n], AuthModule);\n\nlet AuthRedirectService = class AuthRedirectService {\n    /**\n     * This service is responsible for redirecting to the last page before authorization. \"The last page\" can be:\n     * 1. Just the previously opened page; or\n     * 2. The page that we just tried to open, but AuthGuard cancelled it\n     *\n     * For example:\n     * 1. The user opens the product page, then clicks /login link and signs in\n     *    -> Then we should redirect to the product page; or\n     * 2. The user opens the product page, then he clicks /my-account link,\n     *    but is automatically redirected to the login page by the AuthGuard, and he signs in\n     *    -> Then we should redirect to the my-account page, not the product page\n     */\n    constructor(routing, router) {\n        this.routing = routing;\n        this.router = router;\n        this.ignoredUrls = new Set();\n    }\n    redirect() {\n        if (this.redirectUrl === undefined) {\n            this.routing.go('/');\n        }\n        else {\n            this.routing.goByUrl(this.redirectUrl);\n        }\n        this.redirectUrl = undefined;\n        this.lastAuthGuardNavigation = undefined;\n    }\n    reportAuthGuard() {\n        const { url, navigationId } = this.getCurrentNavigation();\n        this.lastAuthGuardNavigation = { url, navigationId };\n        this.redirectUrl = url;\n    }\n    reportNotAuthGuard() {\n        const { url, initialUrl, navigationId } = this.getCurrentNavigation();\n        this.ignoredUrls.add(url);\n        // Don't save redirect url if you've already come from page with NotAuthGuard (i.e. user has come from login to register)\n        if (!this.ignoredUrls.has(initialUrl)) {\n            // We compare the navigation id to find out if the url cancelled by AuthGuard (i.e. my-account) is more recent\n            // than the last opened page\n            if (!this.lastAuthGuardNavigation ||\n                this.lastAuthGuardNavigation.navigationId < navigationId - 1) {\n                this.redirectUrl = initialUrl;\n                this.lastAuthGuardNavigation = undefined;\n            }\n        }\n    }\n    getCurrentNavigation() {\n        const initialUrl = this.router.url;\n        const navigation = this.router.getCurrentNavigation();\n        const url = this.router.serializeUrl(navigation.finalUrl);\n        return {\n            navigationId: navigation.id,\n            url,\n            initialUrl,\n        };\n    }\n};\nAuthRedirectService.ctorParameters = () => [\n    { type: RoutingService },\n    { type: Router }\n];\nAuthRedirectService.ɵprov = ɵɵdefineInjectable({ factory: function AuthRedirectService_Factory() { return new AuthRedirectService(ɵɵinject(RoutingService), ɵɵinject(Router)); }, token: AuthRedirectService, providedIn: \"root\" });\nAuthRedirectService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AuthRedirectService);\n\nlet AuthGuard = class AuthGuard {\n    constructor(routingService, authService, authRedirectService, router) {\n        this.routingService = routingService;\n        this.authService = authService;\n        this.authRedirectService = authRedirectService;\n        this.router = router;\n    }\n    canActivate() {\n        return this.authService.getUserToken().pipe(map((token) => {\n            if (!token.access_token) {\n                this.authRedirectService.reportAuthGuard();\n                this.routingService.go({ cxRoute: 'login' });\n            }\n            return !!token.access_token;\n        }));\n    }\n};\nAuthGuard.ctorParameters = () => [\n    { type: RoutingService },\n    { type: AuthService },\n    { type: AuthRedirectService },\n    { type: Router }\n];\nAuthGuard.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(ɵɵinject(RoutingService), ɵɵinject(AuthService), ɵɵinject(AuthRedirectService), ɵɵinject(Router)); }, token: AuthGuard, providedIn: \"root\" });\nAuthGuard = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AuthGuard);\n\nlet NotAuthGuard = class NotAuthGuard {\n    constructor(routingService, authService, authRedirectService) {\n        this.routingService = routingService;\n        this.authService = authService;\n        this.authRedirectService = authRedirectService;\n    }\n    canActivate() {\n        this.authRedirectService.reportNotAuthGuard();\n        // redirect, if user is already logged in:\n        return this.authService.getUserToken().pipe(map(token => {\n            if (token.access_token) {\n                this.routingService.go({ cxRoute: 'home' });\n            }\n            return !token.access_token;\n        }));\n    }\n};\nNotAuthGuard.ctorParameters = () => [\n    { type: RoutingService },\n    { type: AuthService },\n    { type: AuthRedirectService }\n];\nNotAuthGuard.ɵprov = ɵɵdefineInjectable({ factory: function NotAuthGuard_Factory() { return new NotAuthGuard(ɵɵinject(RoutingService), ɵɵinject(AuthService), ɵɵinject(AuthRedirectService)); }, token: NotAuthGuard, providedIn: \"root\" });\nNotAuthGuard = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], NotAuthGuard);\n\nvar CountryType;\n(function (CountryType) {\n    CountryType[\"BILLING\"] = \"BILLING\";\n    CountryType[\"SHIPPING\"] = \"SHIPPING\";\n})(CountryType || (CountryType = {}));\n\nvar PromotionLocation;\n(function (PromotionLocation) {\n    PromotionLocation[\"ActiveCart\"] = \"CART\";\n    PromotionLocation[\"Checkout\"] = \"CHECKOUT\";\n    PromotionLocation[\"Order\"] = \"ORDER\";\n})(PromotionLocation || (PromotionLocation = {}));\n\nvar PageType;\n(function (PageType) {\n    PageType[\"CONTENT_PAGE\"] = \"ContentPage\";\n    PageType[\"PRODUCT_PAGE\"] = \"ProductPage\";\n    PageType[\"CATEGORY_PAGE\"] = \"CategoryPage\";\n    PageType[\"CATALOG_PAGE\"] = \"CatalogPage\";\n})(PageType || (PageType = {}));\nvar CmsBannerCarouselEffect;\n(function (CmsBannerCarouselEffect) {\n    CmsBannerCarouselEffect[\"FADE\"] = \"FADE\";\n    CmsBannerCarouselEffect[\"ZOOM\"] = \"ZOOM\";\n    CmsBannerCarouselEffect[\"CURTAIN\"] = \"CURTAINX\";\n    CmsBannerCarouselEffect[\"TURNDOWN\"] = \"TURNDOWN\";\n})(CmsBannerCarouselEffect || (CmsBannerCarouselEffect = {}));\n\nvar ANONYMOUS_CONSENT_STATUS;\n(function (ANONYMOUS_CONSENT_STATUS) {\n    ANONYMOUS_CONSENT_STATUS[\"GIVEN\"] = \"GIVEN\";\n    ANONYMOUS_CONSENT_STATUS[\"WITHDRAWN\"] = \"WITHDRAWN\";\n})(ANONYMOUS_CONSENT_STATUS || (ANONYMOUS_CONSENT_STATUS = {}));\n\nvar ImageType;\n(function (ImageType) {\n    ImageType[\"PRIMARY\"] = \"PRIMARY\";\n    ImageType[\"GALLERY\"] = \"GALLERY\";\n})(ImageType || (ImageType = {}));\n\nvar VariantType;\n(function (VariantType) {\n    VariantType[\"SIZE\"] = \"ApparelSizeVariantProduct\";\n    VariantType[\"STYLE\"] = \"ApparelStyleVariantProduct\";\n    VariantType[\"COLOR\"] = \"ElectronicsColorVariantProduct\";\n})(VariantType || (VariantType = {}));\nvar PriceType;\n(function (PriceType) {\n    PriceType[\"BUY\"] = \"BUY\";\n    PriceType[\"FROM\"] = \"FROM\";\n})(PriceType || (PriceType = {}));\nvar VariantQualifier;\n(function (VariantQualifier) {\n    VariantQualifier[\"SIZE\"] = \"size\";\n    VariantQualifier[\"STYLE\"] = \"style\";\n    VariantQualifier[\"COLOR\"] = \"color\";\n    VariantQualifier[\"THUMBNAIL\"] = \"thumbnail\";\n    VariantQualifier[\"PRODUCT\"] = \"product\";\n    VariantQualifier[\"ROLLUP_PROPERTY\"] = \"rollupProperty\";\n})(VariantQualifier || (VariantQualifier = {}));\n\nconst testestsd = 'sare';\n\nvar NotificationType;\n(function (NotificationType) {\n    NotificationType[\"BACK_IN_STOCK\"] = \"BACK_IN_STOCK\";\n})(NotificationType || (NotificationType = {}));\n\nconst ANONYMOUS_CONSENTS_STORE_FEATURE = 'anonymous-consents';\nconst ANONYMOUS_CONSENTS = '[Anonymous Consents] Anonymous Consents';\n\nconst LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Load Anonymous Consent Templates';\nconst LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS = '[Anonymous Consents] Load Anonymous Consent Templates Success';\nconst LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL = '[Anonymous Consents] Load Anonymous Consent Templates Fail';\nconst RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Reset Load Anonymous Consent Templates';\nconst GET_ALL_ANONYMOUS_CONSENTS = '[Anonymous Consents] Get All Anonymous Consents';\nconst GET_ANONYMOUS_CONSENT = '[Anonymous Consents] Get Anonymous Consent';\nconst SET_ANONYMOUS_CONSENTS = '[Anonymous Consents] Set Anonymous Consents';\nconst GIVE_ANONYMOUS_CONSENT = '[Anonymous Consents] Give Anonymous Consent';\nconst WITHDRAW_ANONYMOUS_CONSENT = '[Anonymous Consents] Withdraw Anonymous Consent';\nconst TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED = '[Anonymous Consents] Toggle Anonymous Consents Banner Dismissed';\nconst TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED = '[Anonymous Consents] Anonymous Consent Templates Updated';\nclass LoadAnonymousConsentTemplates extends LoaderLoadAction {\n    constructor() {\n        super(ANONYMOUS_CONSENTS);\n        this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES;\n    }\n}\nclass LoadAnonymousConsentTemplatesSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(ANONYMOUS_CONSENTS);\n        this.payload = payload;\n        this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS;\n    }\n}\nclass LoadAnonymousConsentTemplatesFail extends LoaderFailAction {\n    constructor(payload) {\n        super(ANONYMOUS_CONSENTS, payload);\n        this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL;\n    }\n}\nclass ResetLoadAnonymousConsentTemplates extends LoaderResetAction {\n    constructor() {\n        super(ANONYMOUS_CONSENTS);\n        this.type = RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES;\n    }\n}\nclass GetAllAnonymousConsents {\n    constructor() {\n        this.type = GET_ALL_ANONYMOUS_CONSENTS;\n    }\n}\nclass GetAnonymousConsent {\n    constructor(templateCode) {\n        this.templateCode = templateCode;\n        this.type = GET_ANONYMOUS_CONSENT;\n    }\n}\nclass SetAnonymousConsents {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = SET_ANONYMOUS_CONSENTS;\n    }\n}\nclass GiveAnonymousConsent {\n    constructor(templateCode) {\n        this.templateCode = templateCode;\n        this.type = GIVE_ANONYMOUS_CONSENT;\n    }\n}\nclass WithdrawAnonymousConsent {\n    constructor(templateCode) {\n        this.templateCode = templateCode;\n        this.type = WITHDRAW_ANONYMOUS_CONSENT;\n    }\n}\nclass ToggleAnonymousConsentsBannerDissmissed {\n    constructor(dismissed) {\n        this.dismissed = dismissed;\n        this.type = TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED;\n    }\n}\nclass ToggleAnonymousConsentTemplatesUpdated {\n    constructor(updated) {\n        this.updated = updated;\n        this.type = TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED;\n    }\n}\n\n\n\nvar anonymousConsentsGroup = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_ANONYMOUS_CONSENT_TEMPLATES: LOAD_ANONYMOUS_CONSENT_TEMPLATES,\n    LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS: LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS,\n    LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL: LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL,\n    RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES: RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES,\n    GET_ALL_ANONYMOUS_CONSENTS: GET_ALL_ANONYMOUS_CONSENTS,\n    GET_ANONYMOUS_CONSENT: GET_ANONYMOUS_CONSENT,\n    SET_ANONYMOUS_CONSENTS: SET_ANONYMOUS_CONSENTS,\n    GIVE_ANONYMOUS_CONSENT: GIVE_ANONYMOUS_CONSENT,\n    WITHDRAW_ANONYMOUS_CONSENT: WITHDRAW_ANONYMOUS_CONSENT,\n    TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED,\n    TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED,\n    LoadAnonymousConsentTemplates: LoadAnonymousConsentTemplates,\n    LoadAnonymousConsentTemplatesSuccess: LoadAnonymousConsentTemplatesSuccess,\n    LoadAnonymousConsentTemplatesFail: LoadAnonymousConsentTemplatesFail,\n    ResetLoadAnonymousConsentTemplates: ResetLoadAnonymousConsentTemplates,\n    GetAllAnonymousConsents: GetAllAnonymousConsents,\n    GetAnonymousConsent: GetAnonymousConsent,\n    SetAnonymousConsents: SetAnonymousConsents,\n    GiveAnonymousConsent: GiveAnonymousConsent,\n    WithdrawAnonymousConsent: WithdrawAnonymousConsent,\n    ToggleAnonymousConsentsBannerDissmissed: ToggleAnonymousConsentsBannerDissmissed,\n    ToggleAnonymousConsentTemplatesUpdated: ToggleAnonymousConsentTemplatesUpdated\n});\n\nconst getAnonymousConsentState = createFeatureSelector(ANONYMOUS_CONSENTS_STORE_FEATURE);\n\nconst ɵ0$8 = state => state.templates;\nconst getAnonymousConsentTemplatesState = createSelector(getAnonymousConsentState, ɵ0$8);\nconst getAnonymousConsentTemplatesValue = createSelector(getAnonymousConsentTemplatesState, loaderValueSelector);\nconst getAnonymousConsentTemplatesLoading = createSelector(getAnonymousConsentTemplatesState, loaderLoadingSelector);\nconst getAnonymousConsentTemplatesSuccess = createSelector(getAnonymousConsentTemplatesState, loaderSuccessSelector);\nconst getAnonymousConsentTemplatesError = createSelector(getAnonymousConsentTemplatesState, loaderErrorSelector);\nconst getAnonymousConsentTemplate = (templateCode) => {\n    return createSelector(getAnonymousConsentTemplatesValue, templates => {\n        return templates\n            ? templates.find(template => template.id === templateCode)\n            : null;\n    });\n};\n\nconst ɵ0$9 = state => state.ui.updated;\nconst getAnonymousConsentTemplatesUpdate = createSelector(getAnonymousConsentState, ɵ0$9);\nconst ɵ1$6 = state => state.ui.bannerDismissed;\nconst getAnonymousConsentsBannerDismissed = createSelector(getAnonymousConsentState, ɵ1$6);\n\nconst ɵ0$a = state => state.consents;\nconst getAnonymousConsents = createSelector(getAnonymousConsentState, ɵ0$a);\nconst getAnonymousConsentByTemplateCode = (templateCode) => createSelector(getAnonymousConsents, consents => consents.find(consent => consent.templateCode === templateCode));\n\n\n\nvar anonymousConsentsGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getAnonymousConsentTemplatesState: getAnonymousConsentTemplatesState,\n    getAnonymousConsentTemplatesValue: getAnonymousConsentTemplatesValue,\n    getAnonymousConsentTemplatesLoading: getAnonymousConsentTemplatesLoading,\n    getAnonymousConsentTemplatesSuccess: getAnonymousConsentTemplatesSuccess,\n    getAnonymousConsentTemplatesError: getAnonymousConsentTemplatesError,\n    getAnonymousConsentTemplate: getAnonymousConsentTemplate,\n    ɵ0: ɵ0$8,\n    getAnonymousConsentTemplatesUpdate: getAnonymousConsentTemplatesUpdate,\n    getAnonymousConsentsBannerDismissed: getAnonymousConsentsBannerDismissed,\n    ɵ1: ɵ1$6,\n    getAnonymousConsents: getAnonymousConsents,\n    getAnonymousConsentByTemplateCode: getAnonymousConsentByTemplateCode,\n    getAnonymousConsentState: getAnonymousConsentState\n});\n\nlet AnonymousConsentsService = class AnonymousConsentsService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Retrieves the anonymous consent templates.\n     */\n    loadTemplates() {\n        this.store.dispatch(new LoadAnonymousConsentTemplates());\n    }\n    /**\n     * Conditionally triggers the load of the anonymous consent templates if:\n     *   - `loadIfMissing` parameter is set to `true`\n     *   - the `templates` in the store are `undefined`\n     *\n     * Othewise it just returns the value from the store.\n     *\n     * @param loadIfMissing setting to `true` will trigger the load of the templates if the currently stored templates are `undefined`\n     */\n    getTemplates(loadIfMissing = false) {\n        return iif(() => loadIfMissing, this.store.pipe(select(getAnonymousConsentTemplatesValue), withLatestFrom(this.getLoadTemplatesLoading()), filter(([_templates, loading]) => !loading), tap(([templates, _loading]) => {\n            if (!Boolean(templates)) {\n                this.loadTemplates();\n            }\n        }), filter(([templates, _loading]) => Boolean(templates)), map(([templates, _loading]) => templates)), this.store.pipe(select(getAnonymousConsentTemplatesValue)));\n    }\n    /**\n     * Returns the anonymous consent templates with the given template code.\n     * @param templateCode a template code by which to filter anonymous consent templates.\n     */\n    getTemplate(templateCode) {\n        return this.store.pipe(select(getAnonymousConsentTemplate(templateCode)));\n    }\n    /**\n     * Returns an indicator for the loading status for the anonymous consent templates.\n     */\n    getLoadTemplatesLoading() {\n        return this.store.pipe(select(getAnonymousConsentTemplatesLoading));\n    }\n    /**\n     * Returns an indicator for the success status for the anonymous consent templates.\n     */\n    getLoadTemplatesSuccess() {\n        return this.store.pipe(select(getAnonymousConsentTemplatesSuccess));\n    }\n    /**\n     * Returns an indicator for the error status for the anonymous consent templates.\n     */\n    getLoadTemplatesError() {\n        return this.store.pipe(select(getAnonymousConsentTemplatesError));\n    }\n    /**\n     * Resets the loading, success and error indicators for the anonymous consent templates.\n     */\n    resetLoadTemplatesState() {\n        this.store.dispatch(new ResetLoadAnonymousConsentTemplates());\n    }\n    /**\n     * Returns all the anonymous consents.\n     */\n    getConsents() {\n        return this.store.pipe(select(getAnonymousConsents));\n    }\n    /**\n     * Puts the provided anonymous consents into the store.\n     */\n    setConsents(consents) {\n        return this.store.dispatch(new SetAnonymousConsents(consents));\n    }\n    /**\n     * Returns the anonymous consent for the given template ID.\n     *\n     * As a side-effect, the method will call `getTemplates(true)` to load the templates if those are not present.\n     *\n     * @param templateId a template ID by which to filter anonymous consent templates.\n     */\n    getConsent(templateId) {\n        return this.authService.isUserLoggedIn().pipe(filter(authenticated => !authenticated), tap(_ => this.getTemplates(true)), switchMap(_ => this.store.pipe(select(getAnonymousConsentByTemplateCode(templateId)))));\n    }\n    /**\n     * Give a consent for the given `templateCode`\n     * @param templateCode for which to give the consent\n     */\n    giveConsent(templateCode) {\n        this.store.dispatch(new GiveAnonymousConsent(templateCode));\n    }\n    /**\n     * Sets all the anonymous consents' state to given.\n     */\n    giveAllConsents() {\n        return this.getTemplates(true).pipe(tap(templates => templates.forEach(template => this.giveConsent(template.id))));\n    }\n    /**\n     * Returns `true` if the provided `consent` is given.\n     * @param consent a consent to test\n     */\n    isConsentGiven(consent) {\n        return consent && consent.consentState === ANONYMOUS_CONSENT_STATUS.GIVEN;\n    }\n    /**\n     * Withdraw a consent for the given `templateCode`\n     * @param templateCode for which to withdraw the consent\n     */\n    withdrawConsent(templateCode) {\n        this.store.dispatch(new WithdrawAnonymousConsent(templateCode));\n    }\n    /**\n     * Sets all the anonymous consents' state to withdrawn.\n     */\n    withdrawAllConsents() {\n        return this.getTemplates(true).pipe(tap(templates => templates.forEach(template => this.withdrawConsent(template.id))));\n    }\n    /**\n     * Returns `true` if the provided `consent` is withdrawn.\n     * @param consent a consent to test\n     */\n    isConsentWithdrawn(consent) {\n        return (consent && consent.consentState === ANONYMOUS_CONSENT_STATUS.WITHDRAWN);\n    }\n    /**\n     * Toggles the dismissed state of the anonymous consents banner.\n     * @param dismissed the banner will be dismissed if `true` is passed, otherwise it will be visible.\n     */\n    toggleBannerDismissed(dismissed) {\n        this.store.dispatch(new ToggleAnonymousConsentsBannerDissmissed(dismissed));\n        if (dismissed) {\n            this.toggleTemplatesUpdated(false);\n        }\n    }\n    /**\n     * Returns `true` if the banner was dismissed, `false` otherwise.\n     */\n    isBannerDismissed() {\n        return this.store.pipe(select(getAnonymousConsentsBannerDismissed));\n    }\n    /**\n     * Returns `true` if the consent templates were updated on the back-end.\n     * If the templates are not present in the store, it triggers the load.\n     */\n    getTemplatesUpdated() {\n        return this.getTemplates(true).pipe(switchMap(_ => this.store.pipe(select(getAnonymousConsentTemplatesUpdate))));\n    }\n    /**\n     * Toggles the `updated` slice of the state\n     * @param updated\n     */\n    toggleTemplatesUpdated(updated) {\n        this.store.dispatch(new ToggleAnonymousConsentTemplatesUpdated(updated));\n    }\n    /**\n     * Returns `true` if either the banner is not dismissed or if the templates were updated on the back-end.\n     * Otherwise, it returns `false`.\n     */\n    isBannerVisible() {\n        return combineLatest([\n            this.isBannerDismissed(),\n            this.getTemplatesUpdated(),\n        ]).pipe(map(([dismissed, updated]) => !dismissed || updated));\n    }\n    /**\n     * Returns `true` if there's a missmatch in template versions between the provided `currentTemplates` and `newTemplates`\n     * @param currentTemplates current templates to check\n     * @param newTemplates new templates to check\n     */\n    detectUpdatedTemplates(currentTemplates, newTemplates) {\n        if (newTemplates.length !== currentTemplates.length) {\n            return true;\n        }\n        for (let i = 0; i < newTemplates.length; i++) {\n            const newTemplate = newTemplates[i];\n            const currentTemplate = currentTemplates[i];\n            if (newTemplate.version !== currentTemplate.version) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Serializes using `JSON.stringify()` and encodes using `encodeURIComponent()` methods\n     * @param consents to serialize and encode\n     */\n    serializeAndEncode(consents) {\n        if (!consents) {\n            return '';\n        }\n        const serialized = JSON.stringify(consents);\n        const encoded = encodeURIComponent(serialized);\n        return encoded;\n    }\n    /**\n     * Decodes using `decodeURIComponent()` and deserializes using `JSON.parse()`\n     * @param rawConsents to decode an deserialize\n     */\n    decodeAndDeserialize(rawConsents) {\n        const decoded = decodeURIComponent(rawConsents);\n        const unserialized = JSON.parse(decoded);\n        return unserialized;\n    }\n    /**\n     *\n     * Compares the given `newConsents` and `previousConsents` and returns `true` if there are differences (the `newConsents` are updates).\n     * Otherwise it returns `false`.\n     *\n     * @param newConsents new consents to compare\n     * @param previousConsents old consents to compare\n     */\n    consentsUpdated(newConsents, previousConsents) {\n        const newRawConsents = this.serializeAndEncode(newConsents);\n        const previousRawConsents = this.serializeAndEncode(previousConsents);\n        return newRawConsents !== previousRawConsents;\n    }\n};\nAnonymousConsentsService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nAnonymousConsentsService.ɵprov = ɵɵdefineInjectable({ factory: function AnonymousConsentsService_Factory() { return new AnonymousConsentsService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: AnonymousConsentsService, providedIn: \"root\" });\nAnonymousConsentsService = __decorate([\n    Injectable({ providedIn: 'root' })\n], AnonymousConsentsService);\n\nclass FeaturesConfig {\n}\nconst ANONYMOUS_CONSENTS_FEATURE = 'anonymousConsents';\n\nfunction isFeatureConfig(config) {\n    return typeof config === 'object' && config.features;\n}\nfunction isInLevel(level, version) {\n    if (level === '*') {\n        return true;\n    }\n    const levelParts = level.split('.');\n    const versionParts = version.split('.');\n    for (let i = 0; i < versionParts.length; i++) {\n        const versionNumberPart = Number(versionParts[i]);\n        const levelNumberPart = Number(levelParts[i]) || 0;\n        if (versionNumberPart !== levelNumberPart) {\n            return levelNumberPart > versionNumberPart;\n        }\n    }\n    return true;\n}\nfunction isFeatureLevel(config, level) {\n    if (isFeatureConfig(config)) {\n        return level[0] === '!'\n            ? !isInLevel(config.features.level, level.substr(1, level.length))\n            : isInLevel(config.features.level, level);\n    }\n}\nfunction isFeatureEnabled(config, feature) {\n    if (isFeatureConfig(config)) {\n        const featureConfig = feature[0] === '!'\n            ? config.features[feature.substr(1, feature.length)]\n            : config.features[feature];\n        const result = typeof featureConfig === 'string'\n            ? isFeatureLevel(config, featureConfig)\n            : featureConfig;\n        return feature[0] === '!' ? !result : result;\n    }\n}\n\nlet FeatureConfigService = class FeatureConfigService {\n    constructor(config) {\n        this.config = config;\n    }\n    isLevel(version) {\n        return isFeatureLevel(this.config, version);\n    }\n    isEnabled(feature) {\n        return isFeatureEnabled(this.config, feature);\n    }\n};\nFeatureConfigService.ctorParameters = () => [\n    { type: FeaturesConfig }\n];\nFeatureConfigService.ɵprov = ɵɵdefineInjectable({ factory: function FeatureConfigService_Factory() { return new FeatureConfigService(ɵɵinject(FeaturesConfig)); }, token: FeatureConfigService, providedIn: \"root\" });\nFeatureConfigService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], FeatureConfigService);\n\nlet FeatureLevelDirective = class FeatureLevelDirective {\n    constructor(templateRef, viewContainer, featureConfig) {\n        this.templateRef = templateRef;\n        this.viewContainer = viewContainer;\n        this.featureConfig = featureConfig;\n        this.hasView = false;\n    }\n    set cxFeatureLevel(level) {\n        if (this.featureConfig.isLevel(level.toString()) && !this.hasView) {\n            this.viewContainer.createEmbeddedView(this.templateRef);\n            this.hasView = true;\n        }\n        else if (!this.featureConfig.isLevel(level.toString()) && this.hasView) {\n            this.viewContainer.clear();\n            this.hasView = false;\n        }\n    }\n};\nFeatureLevelDirective.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ViewContainerRef },\n    { type: FeatureConfigService }\n];\n__decorate([\n    Input()\n], FeatureLevelDirective.prototype, \"cxFeatureLevel\", null);\nFeatureLevelDirective = __decorate([\n    Directive({\n        selector: '[cxFeatureLevel]',\n    })\n], FeatureLevelDirective);\n\nlet FeatureDirective = class FeatureDirective {\n    constructor(templateRef, viewContainer, featureConfig) {\n        this.templateRef = templateRef;\n        this.viewContainer = viewContainer;\n        this.featureConfig = featureConfig;\n        this.hasView = false;\n    }\n    set cxFeature(feature) {\n        if (this.featureConfig.isEnabled(feature) && !this.hasView) {\n            this.viewContainer.createEmbeddedView(this.templateRef);\n            this.hasView = true;\n        }\n        else if (!this.featureConfig.isEnabled(feature) && this.hasView) {\n            this.viewContainer.clear();\n            this.hasView = false;\n        }\n    }\n};\nFeatureDirective.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ViewContainerRef },\n    { type: FeatureConfigService }\n];\n__decorate([\n    Input()\n], FeatureDirective.prototype, \"cxFeature\", null);\nFeatureDirective = __decorate([\n    Directive({\n        selector: '[cxFeature]',\n    })\n], FeatureDirective);\n\nvar FeaturesConfigModule_1;\nlet FeaturesConfigModule = FeaturesConfigModule_1 = class FeaturesConfigModule {\n    static forRoot(defaultLevel) {\n        return {\n            ngModule: FeaturesConfigModule_1,\n            providers: [\n                provideConfig({\n                    features: {\n                        level: defaultLevel || '*',\n                    },\n                }),\n                {\n                    provide: FeaturesConfig,\n                    useExisting: Config,\n                },\n            ],\n        };\n    }\n};\nFeaturesConfigModule = FeaturesConfigModule_1 = __decorate([\n    NgModule({\n        declarations: [FeatureLevelDirective, FeatureDirective],\n        exports: [FeatureLevelDirective, FeatureDirective],\n    })\n], FeaturesConfigModule);\n\nclass AsmAdapter {\n}\n\nconst defaultOccAsmConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                asmCustomerSearch: '/assistedservicewebservices/customers/search',\n            },\n        },\n    },\n};\n\nclass AsmConfig extends OccConfig {\n}\n\nconst CUSTOMER_SEARCH_PAGE_NORMALIZER = new InjectionToken('CustomerSearchPageNormalizer');\n\nlet ConverterService = class ConverterService {\n    constructor(injector) {\n        this.injector = injector;\n        this.converters = new Map();\n    }\n    getConverters(injectionToken) {\n        if (!this.converters.has(injectionToken)) {\n            const converters = this.injector.get(injectionToken, []);\n            if (!Array.isArray(converters)) {\n                console.warn('Converter must be multi-provided, please use \"multi: true\" for', injectionToken.toString());\n            }\n            this.converters.set(injectionToken, converters);\n        }\n        return this.converters.get(injectionToken);\n    }\n    /**\n     * Will return true if converters for specified token were provided\n     */\n    hasConverters(injectionToken) {\n        const converters = this.getConverters(injectionToken);\n        return Array.isArray(converters) && converters.length > 0;\n    }\n    /**\n     * Pipeable operator to apply converter logic in a observable stream\n     */\n    pipeable(injectionToken) {\n        if (this.hasConverters(injectionToken)) {\n            return map((model) => this.convertSource(model, injectionToken));\n        }\n        else {\n            return (observable) => observable;\n        }\n    }\n    /**\n     * Pipeable operator to apply converter logic in a observable stream to collection of items\n     */\n    pipeableMany(injectionToken) {\n        if (this.hasConverters(injectionToken)) {\n            return map((model) => this.convertMany(model, injectionToken));\n        }\n        else {\n            return (observable) => observable;\n        }\n    }\n    /**\n     * Apply converter logic specified by injection token to source data\n     */\n    convert(source, injectionToken) {\n        if (this.hasConverters(injectionToken)) {\n            return this.convertSource(source, injectionToken);\n        }\n        else {\n            return source;\n        }\n    }\n    /**\n     * Apply converter logic specified by injection token to a collection\n     */\n    convertMany(sources, injectionToken) {\n        if (this.hasConverters(injectionToken) && Array.isArray(sources)) {\n            return sources.map(source => this.convertSource(source, injectionToken));\n        }\n        else {\n            return sources;\n        }\n    }\n    convertSource(source, injectionToken) {\n        return this.getConverters(injectionToken).reduce((target, converter) => {\n            return converter.convert(source, target);\n        }, undefined);\n    }\n};\nConverterService.ctorParameters = () => [\n    { type: Injector }\n];\nConverterService.ɵprov = ɵɵdefineInjectable({ factory: function ConverterService_Factory() { return new ConverterService(ɵɵinject(INJECTOR)); }, token: ConverterService, providedIn: \"root\" });\nConverterService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ConverterService);\n\nlet OccAsmAdapter = class OccAsmAdapter {\n    constructor(http, occEndpointsService, converterService, config, baseSiteService) {\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n        this.converterService = converterService;\n        this.config = config;\n        this.baseSiteService = baseSiteService;\n        this.baseSiteService\n            .getActive()\n            .subscribe(value => (this.activeBaseSite = value));\n    }\n    customerSearch(options) {\n        const headers = InterceptorUtil.createHeader(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, true, new HttpHeaders());\n        let params = new HttpParams()\n            .set('baseSite', this.activeBaseSite)\n            .set('sort', 'byNameAsc');\n        if (typeof options['query'] !== 'undefined') {\n            params = params.set('query', '' + options.query);\n        }\n        if (typeof options['pageSize'] !== 'undefined') {\n            params = params.set('pageSize', '' + options.pageSize);\n        }\n        const url = this.occEndpointsService.getRawEndpoint('asmCustomerSearch');\n        return this.http\n            .get(url, { headers, params })\n            .pipe(this.converterService.pipeable(CUSTOMER_SEARCH_PAGE_NORMALIZER));\n    }\n};\nOccAsmAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService },\n    { type: AsmConfig },\n    { type: BaseSiteService }\n];\nOccAsmAdapter = __decorate([\n    Injectable()\n], OccAsmAdapter);\n\nlet AsmOccModule = class AsmOccModule {\n};\nAsmOccModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            ConfigModule.withConfig(defaultOccAsmConfig),\n        ],\n        providers: [\n            {\n                provide: AsmAdapter,\n                useClass: OccAsmAdapter,\n            },\n        ],\n    })\n], AsmOccModule);\n\nclass CartAdapter {\n}\n\nconst CART_NORMALIZER = new InjectionToken('CartNormalizer');\n\nclass CartEntryAdapter {\n}\n\nclass SaveCartAdapter {\n}\n\nclass CartVoucherAdapter {\n}\n\nconst PRODUCT_NORMALIZER = new InjectionToken('ProductNormalizer');\n\nlet OccCartNormalizer = class OccCartNormalizer {\n    constructor(converter) {\n        this.converter = converter;\n    }\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source && source.entries) {\n            target.entries = source.entries.map(entry => (Object.assign(Object.assign({}, entry), { product: this.converter.convert(entry.product, PRODUCT_NORMALIZER) })));\n        }\n        this.removeDuplicatePromotions(source, target);\n        return target;\n    }\n    /**\n     * Remove all duplicate promotions\n     */\n    removeDuplicatePromotions(source, target) {\n        if (source && source.potentialOrderPromotions) {\n            target.potentialOrderPromotions = this.removeDuplicateItems(source.potentialOrderPromotions);\n        }\n        if (source && source.potentialProductPromotions) {\n            target.potentialProductPromotions = this.removeDuplicateItems(source.potentialProductPromotions);\n        }\n        if (source && source.appliedOrderPromotions) {\n            target.appliedOrderPromotions = this.removeDuplicateItems(source.appliedOrderPromotions);\n        }\n        if (source && source.appliedProductPromotions) {\n            target.appliedProductPromotions = this.removeDuplicateItems(source.appliedProductPromotions);\n        }\n    }\n    removeDuplicateItems(itemList) {\n        return itemList.filter((p, i, a) => {\n            const b = a.map(el => JSON.stringify(el));\n            return i === b.indexOf(JSON.stringify(p));\n        });\n    }\n};\nOccCartNormalizer.ctorParameters = () => [\n    { type: ConverterService }\n];\nOccCartNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccCartNormalizer_Factory() { return new OccCartNormalizer(ɵɵinject(ConverterService)); }, token: OccCartNormalizer, providedIn: \"root\" });\nOccCartNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccCartNormalizer);\n\nconst defaultOccCartConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                // tslint:disable:max-line-length\n                carts: 'users/${userId}/carts?fields=carts(DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),saveTime,user,name)',\n                cart: 'users/${userId}/carts/${cartId}?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',\n                createCart: 'users/${userId}/carts?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',\n                addEntries: 'users/${userId}/carts/${cartId}/entries',\n                updateEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',\n                removeEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',\n                addEmail: 'users/${userId}/carts/${cartId}/email',\n                deleteCart: 'users/${userId}/carts/${cartId}',\n                cartVoucher: 'users/${userId}/carts/${cartId}/vouchers',\n                saveCart: 'users/${userId}/carts/${cartId}/save',\n            },\n        },\n    },\n};\n\nconst CART_MODIFICATION_NORMALIZER = new InjectionToken('CartModificationNormalizer');\n\nlet OccCartEntryAdapter = class OccCartEntryAdapter {\n    constructor(http, occEndpointsService, converterService, featureConfigService) {\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n        this.converterService = converterService;\n        this.featureConfigService = featureConfigService;\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    getCartEndpoint(userId) {\n        const cartEndpoint = 'users/' + userId + '/carts/';\n        return this.occEndpointsService.getEndpoint(cartEndpoint);\n    }\n    add(userId, cartId, productCode, quantity = 1) {\n        const toAdd = JSON.stringify({});\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        // TODO: Deprecated, remove Issue: #4125\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyAdd(userId, cartId, productCode, quantity);\n        }\n        const url = this.occEndpointsService.getUrl('addEntries', {\n            userId,\n            cartId,\n        }, { code: productCode, qty: quantity });\n        return this.http\n            .post(url, toAdd, { headers })\n            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n    }\n    update(userId, cartId, entryNumber, qty, pickupStore) {\n        let params = {};\n        if (pickupStore) {\n            params = { pickupStore };\n        }\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        // TODO: Deprecated, remove Issue: #4125\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyUpdate(userId, cartId, entryNumber, qty, pickupStore);\n        }\n        const url = this.occEndpointsService.getUrl('updateEntries', { userId, cartId, entryNumber }, Object.assign({ qty }, params));\n        return this.http\n            .patch(url, {}, { headers })\n            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n    }\n    remove(userId, cartId, entryNumber) {\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        // TODO: Deprecated, remove Issue: #4125\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyRemove(userId, cartId, entryNumber);\n        }\n        const url = this.occEndpointsService.getUrl('removeEntries', {\n            userId,\n            cartId,\n            entryNumber,\n        });\n        return this.http.delete(url, { headers });\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyAdd(userId, cartId, productCode, quantity = 1) {\n        const url = this.getCartEndpoint(userId) + cartId + '/entries';\n        const params = new HttpParams({\n            fromString: 'code=' + productCode + '&qty=' + quantity,\n        });\n        const toAdd = JSON.stringify({});\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http\n            .post(url, toAdd, { headers, params })\n            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyUpdate(userId, cartId, entryNumber, qty, pickupStore) {\n        const url = this.getCartEndpoint(userId) + cartId + '/entries/' + entryNumber;\n        let queryString = 'qty=' + qty;\n        if (pickupStore) {\n            queryString = queryString + '&pickupStore=' + pickupStore;\n        }\n        const params = new HttpParams({\n            fromString: queryString,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http\n            .patch(url, {}, { headers, params })\n            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyRemove(userId, cartId, entryNumber) {\n        const url = this.getCartEndpoint(userId) + cartId + '/entries/' + entryNumber;\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http.delete(url, { headers });\n    }\n};\nOccCartEntryAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService },\n    { type: FeatureConfigService }\n];\nOccCartEntryAdapter = __decorate([\n    Injectable()\n], OccCartEntryAdapter);\n\nconst CART_VOUCHER_NORMALIZER = new InjectionToken('CartVoucherNormalizer');\n\nlet OccCartVoucherAdapter = class OccCartVoucherAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    getCartVoucherEndpoint(userId, cartId) {\n        return this.occEndpoints.getUrl('cartVoucher', { userId, cartId });\n    }\n    getHeaders(userId) {\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        if (userId === OCC_USER_ID_ANONYMOUS) {\n            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        }\n        return headers;\n    }\n    add(userId, cartId, voucherId) {\n        const url = this.getCartVoucherEndpoint(userId, cartId);\n        const toAdd = JSON.stringify({});\n        const params = new HttpParams().set('voucherId', voucherId);\n        const headers = this.getHeaders(userId);\n        return this.http.post(url, toAdd, { headers, params }).pipe(catchError((error) => throwError(error.json())), this.converter.pipeable(CART_VOUCHER_NORMALIZER));\n    }\n    remove(userId, cartId, voucherId) {\n        const url = this.getCartVoucherEndpoint(userId, cartId) +\n            '/' +\n            encodeURIComponent(voucherId);\n        const headers = this.getHeaders(userId);\n        return this.http\n            .delete(url, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nOccCartVoucherAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCartVoucherAdapter = __decorate([\n    Injectable()\n], OccCartVoucherAdapter);\n\n// TODO: Deprecated, remove Issue: #4125. Use configurable endpoints.\nconst DETAILS_PARAMS = 'DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,' +\n    'entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue),updateable),' +\n    'totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),' +\n    'deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue),pickupItemsQuantity,net,' +\n    'appliedVouchers,productDiscounts(formattedValue),user';\nlet OccCartAdapter = class OccCartAdapter {\n    constructor(http, occEndpointsService, converterService, featureConfigService) {\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n        this.converterService = converterService;\n        this.featureConfigService = featureConfigService;\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    getCartEndpoint(userId) {\n        const cartEndpoint = `users/${userId}/carts/`;\n        return this.occEndpointsService.getEndpoint(cartEndpoint);\n    }\n    loadAll(userId) {\n        // TODO: Deprecated, remove Issue: #4125.\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyLoadAll(userId);\n        }\n        return this.http\n            .get(this.occEndpointsService.getUrl('carts', { userId }))\n            .pipe(pluck('carts'), this.converterService.pipeableMany(CART_NORMALIZER));\n    }\n    load(userId, cartId) {\n        if (cartId === OCC_CART_ID_CURRENT) {\n            return this.loadAll(userId).pipe(map(carts => {\n                if (carts) {\n                    const activeCart = carts.find(cart => {\n                        return cart['saveTime'] === undefined;\n                    });\n                    return activeCart;\n                }\n                else {\n                    return null;\n                }\n            }));\n        }\n        else {\n            // TODO: Deprecated, remove Issue: #4125.\n            if (!this.featureConfigService.isLevel('1.1')) {\n                return this.legacyLoad(userId, cartId);\n            }\n            return this.http\n                .get(this.occEndpointsService.getUrl('cart', { userId, cartId }))\n                .pipe(this.converterService.pipeable(CART_NORMALIZER));\n        }\n    }\n    create(userId, oldCartId, toMergeCartGuid) {\n        const toAdd = JSON.stringify({});\n        // TODO: Deprecated, remove Issue: #4125.\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyCreate(userId, toAdd, oldCartId, toMergeCartGuid);\n        }\n        let params = {};\n        if (oldCartId) {\n            params = { oldCartId: oldCartId };\n        }\n        if (toMergeCartGuid) {\n            params['toMergeCartGuid'] = toMergeCartGuid;\n        }\n        return this.http\n            .post(this.occEndpointsService.getUrl('createCart', { userId }, params), toAdd)\n            .pipe(this.converterService.pipeable(CART_NORMALIZER));\n    }\n    delete(userId, cartId) {\n        let headers = new HttpHeaders();\n        if (userId === OCC_USER_ID_ANONYMOUS) {\n            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        }\n        return this.http.delete(this.occEndpointsService.getUrl('deleteCart', { userId, cartId }), { headers });\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyLoadAll(userId) {\n        const url = this.getCartEndpoint(userId);\n        const params = new HttpParams({\n            fromString: `fields=carts(${DETAILS_PARAMS},saveTime)`,\n        });\n        return this.http.get(url, { params }).pipe(pluck('carts'), this.converterService.pipeableMany(CART_NORMALIZER));\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyLoad(userId, cartId) {\n        const url = this.getCartEndpoint(userId) + cartId;\n        const params = new HttpParams({\n            fromString: `fields=${DETAILS_PARAMS}`,\n        });\n        return this.http\n            .get(url, { params })\n            .pipe(this.converterService.pipeable(CART_NORMALIZER));\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyCreate(userId, toAdd, oldCartId, toMergeCartGuid) {\n        const url = this.getCartEndpoint(userId);\n        let queryString = `fields=${DETAILS_PARAMS}`;\n        if (oldCartId) {\n            queryString = `${queryString}&oldCartId=${oldCartId}`;\n        }\n        if (toMergeCartGuid) {\n            queryString = `${queryString}&toMergeCartGuid=${toMergeCartGuid}`;\n        }\n        const params = new HttpParams({\n            fromString: queryString,\n        });\n        return this.http\n            .post(url, toAdd, { params })\n            .pipe(this.converterService.pipeable(CART_NORMALIZER));\n    }\n    addEmail(userId, cartId, email) {\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        const httpParams = new HttpParams().set('email', email);\n        const url = this.occEndpointsService.getUrl('addEmail', {\n            userId,\n            cartId,\n        });\n        return this.http.put(url, httpParams, { headers });\n    }\n};\nOccCartAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService },\n    { type: FeatureConfigService }\n];\nOccCartAdapter = __decorate([\n    Injectable()\n], OccCartAdapter);\n\nconst SAVE_CART_NORMALIZER = new InjectionToken('SaveCartNormalizer');\n\nlet OccSaveCartAdapter = class OccSaveCartAdapter {\n    constructor(http, occEndpointsService, converterService) {\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n        this.converterService = converterService;\n    }\n    saveCart(userId, cartId, saveCartName, saveCartDescription) {\n        let httpParams = new HttpParams();\n        if (Boolean(saveCartName)) {\n            httpParams = httpParams.set('saveCartName', saveCartName);\n        }\n        if (Boolean(saveCartDescription)) {\n            httpParams = httpParams.set('saveCartDescription', saveCartDescription);\n        }\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http\n            .patch(this.occEndpointsService.getUrl('saveCart', { userId, cartId }), httpParams, { headers })\n            .pipe(this.converterService.pipeable(SAVE_CART_NORMALIZER));\n    }\n};\nOccSaveCartAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccSaveCartAdapter = __decorate([\n    Injectable()\n], OccSaveCartAdapter);\n\nlet CartOccModule = class CartOccModule {\n};\nCartOccModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            ConfigModule.withConfig(defaultOccCartConfig),\n        ],\n        providers: [\n            {\n                provide: CartAdapter,\n                useClass: OccCartAdapter,\n            },\n            {\n                provide: CART_NORMALIZER,\n                useExisting: OccCartNormalizer,\n                multi: true,\n            },\n            {\n                provide: CartEntryAdapter,\n                useClass: OccCartEntryAdapter,\n            },\n            {\n                provide: CartVoucherAdapter,\n                useClass: OccCartVoucherAdapter,\n            },\n            {\n                provide: SaveCartAdapter,\n                useClass: OccSaveCartAdapter,\n            },\n        ],\n    })\n], CartOccModule);\n\nconst ORDER_NORMALIZER = new InjectionToken('OrderNormalizer');\n\n// To be changed to a more optimised params after ticket: C3PO-1076\nconst FULL_PARAMS = 'fields=FULL';\nconst CHECKOUT_PARAMS = 'deliveryAddress(FULL),deliveryMode,paymentInfo(FULL)';\nconst ORDERS_ENDPOINT = '/orders';\nconst CARTS_ENDPOINT = '/carts/';\nlet OccCheckoutAdapter = class OccCheckoutAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    getEndpoint(userId, subEndpoint) {\n        const orderEndpoint = 'users/' + userId + subEndpoint;\n        return this.occEndpoints.getEndpoint(orderEndpoint);\n    }\n    placeOrder(userId, cartId) {\n        const url = this.getEndpoint(userId, ORDERS_ENDPOINT);\n        const params = new HttpParams({\n            fromString: 'cartId=' + cartId + '&' + FULL_PARAMS,\n        });\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        if (userId === OCC_USER_ID_ANONYMOUS) {\n            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        }\n        return this.http\n            .post(url, {}, { headers, params })\n            .pipe(this.converter.pipeable(ORDER_NORMALIZER));\n    }\n    loadCheckoutDetails(userId, cartId) {\n        const url = this.getEndpoint(userId, CARTS_ENDPOINT) + cartId;\n        const params = new HttpParams({\n            fromString: `fields=${CHECKOUT_PARAMS}`,\n        });\n        return this.http.get(url, { params });\n    }\n    clearCheckoutDeliveryAddress(userId, cartId) {\n        const url = `${this.getEndpoint(userId, CARTS_ENDPOINT)}${cartId}/addresses/delivery`;\n        return this.http.delete(url);\n    }\n    clearCheckoutDeliveryMode(userId, cartId) {\n        const url = `${this.getEndpoint(userId, CARTS_ENDPOINT)}${cartId}/deliverymode`;\n        return this.http.delete(url);\n    }\n};\nOccCheckoutAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCheckoutAdapter = __decorate([\n    Injectable()\n], OccCheckoutAdapter);\n\nconst DELIVERY_MODE_NORMALIZER = new InjectionToken('DeliveryModeNormalizer');\n\nconst ADDRESS_NORMALIZER = new InjectionToken('AddressNormalizer');\nconst ADDRESS_SERIALIZER = new InjectionToken('AddressSerializer');\nconst ADDRESS_VALIDATION_NORMALIZER = new InjectionToken('AddressValidationNormalizer');\n\nlet OccCheckoutDeliveryAdapter = class OccCheckoutDeliveryAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    getCartEndpoint(userId) {\n        const cartEndpoint = 'users/' + userId + '/carts/';\n        return this.occEndpoints.getEndpoint(cartEndpoint);\n    }\n    createAddress(userId, cartId, address) {\n        address = this.converter.convert(address, ADDRESS_SERIALIZER);\n        return this.http\n            .post(this.getCartEndpoint(userId) + cartId + '/addresses/delivery', address, {\n            headers: new HttpHeaders().set('Content-Type', 'application/json'),\n        })\n            .pipe(this.converter.pipeable(ADDRESS_NORMALIZER));\n    }\n    setAddress(userId, cartId, addressId) {\n        return this.http.put(this.getCartEndpoint(userId) + cartId + '/addresses/delivery', {}, {\n            params: { addressId: addressId },\n        });\n    }\n    setMode(userId, cartId, deliveryModeId) {\n        return this.http.put(this.getCartEndpoint(userId) + cartId + '/deliverymode', {}, {\n            params: { deliveryModeId: deliveryModeId },\n        });\n    }\n    getMode(userId, cartId) {\n        return this.http\n            .get(this.getCartEndpoint(userId) + cartId + '/deliverymode')\n            .pipe(this.converter.pipeable(DELIVERY_MODE_NORMALIZER));\n    }\n    getSupportedModes(userId, cartId) {\n        return this.http\n            .get(this.getCartEndpoint(userId) + cartId + '/deliverymodes')\n            .pipe(pluck('deliveryModes'), this.converter.pipeableMany(DELIVERY_MODE_NORMALIZER));\n    }\n};\nOccCheckoutDeliveryAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCheckoutDeliveryAdapter = __decorate([\n    Injectable()\n], OccCheckoutDeliveryAdapter);\n\nconst PAYMENT_DETAILS_NORMALIZER = new InjectionToken('PaymentDetailsNormalizer');\nconst PAYMENT_DETAILS_SERIALIZER = new InjectionToken('PaymentDetailsSerializer');\nconst CARD_TYPE_NORMALIZER = new InjectionToken('CardTypeNormalizer');\n\nclass CustomEncoder {\n    encodeKey(key) {\n        return encodeURIComponent(key);\n    }\n    encodeValue(value) {\n        return encodeURIComponent(value);\n    }\n    decodeKey(key) {\n        return decodeURIComponent(key);\n    }\n    decodeValue(value) {\n        return decodeURIComponent(value);\n    }\n}\n\nconst ENDPOINT_CARD_TYPES = 'cardtypes';\nlet OccCheckoutPaymentAdapter = class OccCheckoutPaymentAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n        if (typeof DOMParser !== 'undefined') {\n            this.domparser = new DOMParser();\n        }\n    }\n    getCartEndpoint(userId) {\n        const cartEndpoint = 'users/' + userId + '/carts/';\n        return this.occEndpoints.getEndpoint(cartEndpoint);\n    }\n    create(userId, cartId, paymentDetails) {\n        paymentDetails = this.converter.convert(paymentDetails, PAYMENT_DETAILS_SERIALIZER);\n        return this.getProviderSubInfo(userId, cartId).pipe(map(data => {\n            const labelsMap = this.convertToMap(data.mappingLabels.entry);\n            return {\n                url: data.postUrl,\n                parameters: this.getParamsForPaymentProvider(paymentDetails, data.parameters.entry, labelsMap),\n                mappingLabels: labelsMap,\n            };\n        }), mergeMap(sub => {\n            // create a subscription directly with payment provider\n            return this.createSubWithProvider(sub.url, sub.parameters).pipe(map(response => this.extractPaymentDetailsFromHtml(response)), mergeMap(fromPaymentProvider => {\n                fromPaymentProvider['defaultPayment'] =\n                    paymentDetails.defaultPayment;\n                fromPaymentProvider['savePaymentInfo'] = true;\n                return this.createDetailsWithParameters(userId, cartId, fromPaymentProvider).pipe(this.converter.pipeable(PAYMENT_DETAILS_NORMALIZER));\n            }));\n        }));\n    }\n    set(userId, cartId, paymentDetailsId) {\n        return this.http.put(this.getCartEndpoint(userId) + cartId + '/paymentdetails', {}, {\n            params: { paymentDetailsId: paymentDetailsId },\n        });\n    }\n    loadCardTypes() {\n        return this.http\n            .get(this.occEndpoints.getEndpoint(ENDPOINT_CARD_TYPES))\n            .pipe(map(cardTypeList => cardTypeList.cardTypes), this.converter.pipeableMany(CARD_TYPE_NORMALIZER));\n    }\n    getProviderSubInfo(userId, cartId) {\n        return this.http.get(this.getCartEndpoint(userId) +\n            cartId +\n            '/payment/sop/request?responseUrl=sampleUrl');\n    }\n    createSubWithProvider(postUrl, parameters) {\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n            Accept: 'text/html',\n        });\n        let httpParams = new HttpParams({ encoder: new CustomEncoder() });\n        Object.keys(parameters).forEach(key => {\n            httpParams = httpParams.append(key, parameters[key]);\n        });\n        return this.http.post(postUrl, httpParams, {\n            headers,\n            responseType: 'text',\n        });\n    }\n    createDetailsWithParameters(userId, cartId, parameters) {\n        let httpParams = new HttpParams({ encoder: new CustomEncoder() });\n        Object.keys(parameters).forEach(key => {\n            httpParams = httpParams.append(key, parameters[key]);\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http.post(this.getCartEndpoint(userId) + cartId + '/payment/sop/response', httpParams, { headers });\n    }\n    getParamsForPaymentProvider(paymentDetails, parameters, mappingLabels) {\n        const params = this.convertToMap(parameters);\n        params[mappingLabels['hybris_account_holder_name']] =\n            paymentDetails.accountHolderName;\n        params[mappingLabels['hybris_card_type']] = paymentDetails.cardType.code;\n        params[mappingLabels['hybris_card_number']] = paymentDetails.cardNumber;\n        if (mappingLabels['hybris_combined_expiry_date'] === 'true') {\n            params[mappingLabels['hybris_card_expiry_date']] =\n                paymentDetails.expiryMonth +\n                    mappingLabels['hybris_separator_expiry_date'] +\n                    paymentDetails.expiryYear;\n        }\n        else {\n            params[mappingLabels['hybris_card_expiration_month']] =\n                paymentDetails.expiryMonth;\n            params[mappingLabels['hybris_card_expiration_year']] =\n                paymentDetails.expiryYear;\n        }\n        params[mappingLabels['hybris_card_cvn']] = paymentDetails.cvn;\n        // billing address\n        params[mappingLabels['hybris_billTo_country']] =\n            paymentDetails.billingAddress.country.isocode;\n        params[mappingLabels['hybris_billTo_firstname']] =\n            paymentDetails.billingAddress.firstName;\n        params[mappingLabels['hybris_billTo_lastname']] =\n            paymentDetails.billingAddress.lastName;\n        params[mappingLabels['hybris_billTo_street1']] =\n            paymentDetails.billingAddress.line1 +\n                ' ' +\n                paymentDetails.billingAddress.line2;\n        params[mappingLabels['hybris_billTo_city']] =\n            paymentDetails.billingAddress.town;\n        if (paymentDetails.billingAddress.region) {\n            params[mappingLabels['hybris_billTo_region']] =\n                paymentDetails.billingAddress.region.isocodeShort;\n        }\n        else {\n            params[mappingLabels['hybris_billTo_region']] = '';\n        }\n        params[mappingLabels['hybris_billTo_postalcode']] =\n            paymentDetails.billingAddress.postalCode;\n        return params;\n    }\n    extractPaymentDetailsFromHtml(html) {\n        const domdoc = this.domparser.parseFromString(html, 'text/xml');\n        const responseForm = domdoc.getElementsByTagName('form')[0];\n        const inputs = responseForm.getElementsByTagName('input');\n        const values = {};\n        for (let i = 0; inputs[i]; i++) {\n            const input = inputs[i];\n            if (input.getAttribute('name') !== '{}' &&\n                input.getAttribute('value') !== '') {\n                values[input.getAttribute('name')] = input.getAttribute('value');\n            }\n        }\n        return values;\n    }\n    convertToMap(paramList) {\n        return paramList.reduce(function (result, item) {\n            const key = item.key;\n            result[key] = item.value;\n            return result;\n        }, {});\n    }\n};\nOccCheckoutPaymentAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCheckoutPaymentAdapter = __decorate([\n    Injectable()\n], OccCheckoutPaymentAdapter);\n\nclass CheckoutAdapter {\n}\n\nlet OccOrderNormalizer = class OccOrderNormalizer {\n    constructor(converter) {\n        this.converter = converter;\n    }\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source.entries) {\n            target.entries = source.entries.map(entry => this.convertOrderEntry(entry));\n        }\n        if (source.consignments) {\n            target.consignments = source.consignments.map(consignment => (Object.assign(Object.assign({}, consignment), { entries: consignment.entries.map(entry => (Object.assign(Object.assign({}, entry), { orderEntry: this.convertOrderEntry(entry.orderEntry) }))) })));\n        }\n        if (source.unconsignedEntries) {\n            target.unconsignedEntries = source.unconsignedEntries.map(entry => this.convertOrderEntry(entry));\n        }\n        return target;\n    }\n    convertOrderEntry(source) {\n        return Object.assign(Object.assign({}, source), { product: this.converter.convert(source.product, PRODUCT_NORMALIZER) });\n    }\n};\nOccOrderNormalizer.ctorParameters = () => [\n    { type: ConverterService }\n];\nOccOrderNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccOrderNormalizer_Factory() { return new OccOrderNormalizer(ɵɵinject(ConverterService)); }, token: OccOrderNormalizer, providedIn: \"root\" });\nOccOrderNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccOrderNormalizer);\n\nclass CheckoutDeliveryAdapter {\n}\n\nclass CheckoutPaymentAdapter {\n}\n\nlet CheckoutOccModule = class CheckoutOccModule {\n};\nCheckoutOccModule = __decorate([\n    NgModule({\n        imports: [CommonModule, HttpClientModule],\n        providers: [\n            {\n                provide: CheckoutAdapter,\n                useClass: OccCheckoutAdapter,\n            },\n            { provide: ORDER_NORMALIZER, useExisting: OccOrderNormalizer, multi: true },\n            {\n                provide: CheckoutDeliveryAdapter,\n                useClass: OccCheckoutDeliveryAdapter,\n            },\n            {\n                provide: CheckoutPaymentAdapter,\n                useClass: OccCheckoutPaymentAdapter,\n            },\n        ],\n    })\n], CheckoutOccModule);\n\nconst CMS_PAGE_NORMALIZER = new InjectionToken('CmsPageNormalizer');\n\nlet OccCmsPageAdapter = class OccCmsPageAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n        this.headers = new HttpHeaders().set('Content-Type', 'application/json');\n    }\n    load(pageContext, fields) {\n        // load page by Id\n        if (pageContext.type === undefined) {\n            return this.http\n                .get(this.occEndpoints.getUrl('page', {\n                id: pageContext.id,\n            }, { fields: fields ? fields : 'DEFAULT' }), {\n                headers: this.headers,\n            })\n                .pipe(this.converter.pipeable(CMS_PAGE_NORMALIZER));\n        }\n        // load page by PageContext\n        const httpParams = this.getPagesRequestParams(pageContext);\n        return this.http\n            .get(this.getPagesEndpoint(httpParams, fields), {\n            headers: this.headers,\n        })\n            .pipe(this.converter.pipeable(CMS_PAGE_NORMALIZER));\n    }\n    getPagesEndpoint(params, fields) {\n        fields = fields ? fields : 'DEFAULT';\n        return this.occEndpoints.getUrl('pages', {}, Object.assign({ fields }, params));\n    }\n    getPagesRequestParams(pageContext) {\n        let httpParams = {};\n        // smartedit preview page is loaded by previewToken which added by interceptor\n        if (pageContext.id !== 'smartedit-preview') {\n            httpParams = { pageType: pageContext.type };\n            if (pageContext.type === PageType.CONTENT_PAGE) {\n                httpParams['pageLabelOrId'] = pageContext.id;\n            }\n            else {\n                httpParams['code'] = pageContext.id;\n            }\n        }\n        return httpParams;\n    }\n};\nOccCmsPageAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCmsPageAdapter = __decorate([\n    Injectable()\n], OccCmsPageAdapter);\n\nconst CMS_COMPONENT_NORMALIZER = new InjectionToken('CmsComponentNormalizer');\n\nlet OccCmsComponentAdapter = class OccCmsComponentAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n        this.headers = new HttpHeaders().set('Content-Type', 'application/json');\n    }\n    load(id, pageContext) {\n        return this.http\n            .get(this.getComponentEndPoint(id, pageContext), {\n            headers: this.headers,\n        })\n            .pipe(this.converter.pipeable(CMS_COMPONENT_NORMALIZER));\n    }\n    findComponentsByIds(ids, pageContext, fields = 'DEFAULT', currentPage = 0, pageSize = ids.length, sort) {\n        const requestParams = Object.assign(Object.assign({}, this.getContextParams(pageContext)), this.getPaginationParams(currentPage, pageSize, sort));\n        requestParams['componentIds'] = ids.toString();\n        return this.http\n            .get(this.getComponentsEndpoint(requestParams, fields), {\n            headers: this.headers,\n        })\n            .pipe(pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));\n    }\n    findComponentsByIdsLegacy(ids, pageContext, fields = 'DEFAULT', currentPage = 0, pageSize = ids.length, sort) {\n        const idList = { idList: ids };\n        const requestParams = Object.assign(Object.assign({}, this.getContextParams(pageContext)), this.getPaginationParams(currentPage, pageSize, sort));\n        return this.http\n            .post(this.getComponentsEndpoint(requestParams, fields), idList, {\n            headers: this.headers,\n        })\n            .pipe(pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));\n    }\n    getComponentEndPoint(id, pageContext) {\n        return this.occEndpoints.getUrl('component', { id }, this.getContextParams(pageContext));\n    }\n    getComponentsEndpoint(requestParams, fields) {\n        return this.occEndpoints.getUrl('components', {}, Object.assign({ fields }, requestParams));\n    }\n    getPaginationParams(currentPage, pageSize, sort) {\n        const requestParams = {};\n        if (currentPage !== undefined) {\n            requestParams['currentPage'] = currentPage.toString();\n        }\n        if (pageSize !== undefined) {\n            requestParams['pageSize'] = pageSize.toString();\n        }\n        if (sort !== undefined) {\n            requestParams['sort'] = sort;\n        }\n        return requestParams;\n    }\n    getContextParams(pageContext) {\n        let requestParams = {};\n        switch (pageContext.type) {\n            case PageType.PRODUCT_PAGE: {\n                requestParams = { productCode: pageContext.id };\n                break;\n            }\n            case PageType.CATEGORY_PAGE: {\n                requestParams = { categoryCode: pageContext.id };\n                break;\n            }\n            case PageType.CATALOG_PAGE: {\n                requestParams = { catalogCode: pageContext.id };\n                break;\n            }\n        }\n        return requestParams;\n    }\n};\nOccCmsComponentAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCmsComponentAdapter = __decorate([\n    Injectable()\n], OccCmsComponentAdapter);\n\nconst JSP_INCLUDE_CMS_COMPONENT_TYPE = 'JspIncludeComponent';\nconst CMS_FLEX_COMPONENT_TYPE = 'CMSFlexComponent';\n/** Strategy to control the loading strategy of DOM elements. */\nvar DeferLoadingStrategy;\n(function (DeferLoadingStrategy) {\n    /** Defers loading of DOM elements until element is near/in the users view port */\n    DeferLoadingStrategy[\"DEFER\"] = \"DEFERRED-LOADING\";\n    /** Renders the DOM instantly without being concerned with the view port */\n    DeferLoadingStrategy[\"INSTANT\"] = \"INSTANT-LOADING\";\n})(DeferLoadingStrategy || (DeferLoadingStrategy = {}));\nclass CmsConfig extends OccConfig {\n}\n\nlet OccCmsPageNormalizer = class OccCmsPageNormalizer {\n    convert(source, target = {}) {\n        this.normalizePageData(source, target);\n        this.normalizePageSlotData(source, target);\n        this.normalizePageComponentData(source, target);\n        this.normalizeComponentData(source, target);\n        return target;\n    }\n    normalizePageData(source, target) {\n        target.page = {\n            loadTime: Date.now(),\n            name: source.name,\n            type: source.typeCode,\n            title: source.title,\n            pageId: source.uid,\n            template: source.template,\n            slots: {},\n            properties: source.properties,\n            label: source.label,\n        };\n    }\n    normalizePageSlotData(source, target) {\n        for (const slot of source.contentSlots.contentSlot) {\n            target.page.slots[slot.position] = {\n                components: [],\n                properties: slot.properties,\n            };\n        }\n    }\n    normalizePageComponentData(source, target) {\n        for (const slot of source.contentSlots.contentSlot) {\n            if (slot.components.component &&\n                Array.isArray(slot.components.component)) {\n                for (const component of slot.components.component) {\n                    const comp = {\n                        uid: component.uid,\n                        typeCode: component.typeCode,\n                        properties: component.properties,\n                    };\n                    if (component.typeCode === CMS_FLEX_COMPONENT_TYPE) {\n                        comp.flexType = component.flexType;\n                    }\n                    else if (component.typeCode === JSP_INCLUDE_CMS_COMPONENT_TYPE) {\n                        comp.flexType = component.uid;\n                    }\n                    else {\n                        comp.flexType = component.typeCode;\n                    }\n                    target.page.slots[slot.position].components.push(comp);\n                }\n            }\n        }\n    }\n    normalizeComponentData(source, target) {\n        target.components = [];\n        for (const slot of source.contentSlots.contentSlot) {\n            if (slot.components.component &&\n                Array.isArray(slot.components.component)) {\n                for (const component of slot.components.component) {\n                    // we dont put properties into component state\n                    if (component.properties) {\n                        component.properties = undefined;\n                    }\n                    target.components.push(component);\n                }\n            }\n        }\n    }\n};\nOccCmsPageNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccCmsPageNormalizer_Factory() { return new OccCmsPageNormalizer(); }, token: OccCmsPageNormalizer, providedIn: \"root\" });\nOccCmsPageNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccCmsPageNormalizer);\n\n/**\n * Abstract class that can be used to implement custom loader logic\n * in order to load CMS structure from third-party CMS system.\n */\nclass CmsPageAdapter {\n}\n\nclass CmsComponentAdapter {\n}\n\nlet CmsOccModule = class CmsOccModule {\n};\nCmsOccModule = __decorate([\n    NgModule({\n        imports: [CommonModule, HttpClientModule],\n        providers: [\n            {\n                provide: CmsPageAdapter,\n                useClass: OccCmsPageAdapter,\n            },\n            {\n                provide: CMS_PAGE_NORMALIZER,\n                useExisting: OccCmsPageNormalizer,\n                multi: true,\n            },\n            {\n                provide: CmsComponentAdapter,\n                useClass: OccCmsComponentAdapter,\n            },\n        ],\n    })\n], CmsOccModule);\n\nlet ProductImageNormalizer = class ProductImageNormalizer {\n    constructor(config) {\n        this.config = config;\n    }\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source.images) {\n            target.images = this.normalize(source.images);\n        }\n        return target;\n    }\n    /**\n     * @desc\n     * Creates the image structure we'd like to have. Instead of\n     * having a single list with all images despite type and format\n     * we create a proper structure. With that we can do:\n     * - images.primary.thumnail.url\n     * - images.GALLERY[0].thumnail.url\n     */\n    normalize(source) {\n        const images = {};\n        if (source) {\n            for (const image of source) {\n                const isList = image.hasOwnProperty('galleryIndex');\n                if (!images.hasOwnProperty(image.imageType)) {\n                    images[image.imageType] = isList ? [] : {};\n                }\n                let imageContainer;\n                if (isList && !images[image.imageType][image.galleryIndex]) {\n                    images[image.imageType][image.galleryIndex] = {};\n                }\n                if (isList) {\n                    imageContainer = images[image.imageType][image.galleryIndex];\n                }\n                else {\n                    imageContainer = images[image.imageType];\n                }\n                const targetImage = Object.assign({}, image);\n                targetImage.url = this.normalizeImageUrl(targetImage.url);\n                imageContainer[image.format] = targetImage;\n            }\n        }\n        return images;\n    }\n    /**\n     * Traditionally, in an on-prem world, medias and other backend related calls\n     * are hosted at the same platform, but in a cloud setup, applications are are\n     * typically distributed cross different environments. For media, we use the\n     * `backend.media.baseUrl` by default, but fallback to `backend.occ.baseUrl`\n     * if none provided.\n     */\n    normalizeImageUrl(url) {\n        if (new RegExp(/^(http|data:image|\\/\\/)/i).test(url)) {\n            return url;\n        }\n        return ((this.config.backend.media.baseUrl ||\n            this.config.backend.occ.baseUrl ||\n            '') + url);\n    }\n};\nProductImageNormalizer.ctorParameters = () => [\n    { type: OccConfig }\n];\nProductImageNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function ProductImageNormalizer_Factory() { return new ProductImageNormalizer(ɵɵinject(OccConfig)); }, token: ProductImageNormalizer, providedIn: \"root\" });\nProductImageNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], ProductImageNormalizer);\n\nlet ProductReferenceNormalizer = class ProductReferenceNormalizer {\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source.productReferences) {\n            target.productReferences = this.normalize(source.productReferences);\n        }\n        return target;\n    }\n    /**\n     * @desc\n     * Creates the reference structure we'd like to have. Instead of\n     * having a single list with all references we create a proper structure.\n     * With that we have a semantic API for the clients\n     * - product.references.SIMILAR[0].code\n     */\n    normalize(source) {\n        const references = {};\n        if (source) {\n            for (const reference of source) {\n                if (!references.hasOwnProperty(reference.referenceType)) {\n                    references[reference.referenceType] = [];\n                }\n                references[reference.referenceType].push(reference);\n            }\n        }\n        return references;\n    }\n};\nProductReferenceNormalizer = __decorate([\n    Injectable()\n], ProductReferenceNormalizer);\n\nlet OccProductSearchPageNormalizer = class OccProductSearchPageNormalizer {\n    constructor(converterService) {\n        this.converterService = converterService;\n        /**\n         * Specifies the minimal number of top values in case\n         * non have been setup by the business.\n         */\n        this.DEFAULT_TOP_VALUES = 6;\n    }\n    convert(source, target = {}) {\n        target = Object.assign(Object.assign({}, target), source);\n        this.normalizeFacets(target);\n        if (source.products) {\n            target.products = source.products.map(product => this.converterService.convert(product, PRODUCT_NORMALIZER));\n        }\n        return target;\n    }\n    normalizeFacets(target) {\n        this.normalizeFacetValues(target);\n        this.normalizeUselessFacets(target);\n    }\n    /**\n     * The (current) backend returns facets with values that do not contribute\n     * to the facet navigation much, as the number in the result list will not get\n     * behaviour, see https://jira.hybris.com/browse/CS-427.\n     *\n     * As long as this is not in place, we manually filter the facet from the list;\n     * any facet that does not have a count < the total results will be dropped from\n     * the facets.\n     */\n    normalizeUselessFacets(target) {\n        target.facets = target.facets.filter(facet => {\n            return (!target.pagination ||\n                !target.pagination.totalResults ||\n                ((!facet.hasOwnProperty('visible') || facet.visible) &&\n                    facet.values &&\n                    facet.values.find(value => {\n                        return (value.selected || value.count < target.pagination.totalResults);\n                    })));\n        });\n    }\n    /*\n     * In case there are so-called `topValues` given for the facet values,\n     * values are obsolete.\n     *\n     * `topValues` is a feature in Adaptive Search which can limit a large\n     * amount of facet values to a small set (5 by default). As long as the backend\n     * provides all facet values AND topValues, we normalize the data to not bother\n     * the UI with this specific feature.\n     */\n    normalizeFacetValues(target) {\n        if (target.facets) {\n            target.facets = target.facets.map((facetSource) => {\n                const { topValues } = facetSource, facetTarget = __rest(facetSource, [\"topValues\"]);\n                facetTarget.topValueCount = topValues\n                    ? topValues.length\n                    : this.DEFAULT_TOP_VALUES;\n                return facetTarget;\n            });\n        }\n    }\n};\nOccProductSearchPageNormalizer.ctorParameters = () => [\n    { type: ConverterService }\n];\nOccProductSearchPageNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccProductSearchPageNormalizer_Factory() { return new OccProductSearchPageNormalizer(ɵɵinject(ConverterService)); }, token: OccProductSearchPageNormalizer, providedIn: \"root\" });\nOccProductSearchPageNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccProductSearchPageNormalizer);\n\nlet OccProductReferencesListNormalizer = class OccProductReferencesListNormalizer {\n    constructor(converter) {\n        this.converter = converter;\n    }\n    convert(source, target = []) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source && source.references) {\n            target = source.references.map(reference => (Object.assign(Object.assign({}, reference), { target: this.converter.convert(reference.target, PRODUCT_NORMALIZER) })));\n            return target;\n        }\n    }\n};\nOccProductReferencesListNormalizer.ctorParameters = () => [\n    { type: ConverterService }\n];\nOccProductReferencesListNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccProductReferencesListNormalizer_Factory() { return new OccProductReferencesListNormalizer(ɵɵinject(ConverterService)); }, token: OccProductReferencesListNormalizer, providedIn: \"root\" });\nOccProductReferencesListNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccProductReferencesListNormalizer);\n\nlet ProductNameNormalizer = class ProductNameNormalizer {\n    constructor(config) {\n        this.config = config;\n    }\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source.name) {\n            target.name = this.normalize(source.name);\n            target.nameHtml = source.name;\n        }\n        return target;\n    }\n    normalize(name) {\n        return name.replace(/<[^>]*>/g, '');\n    }\n};\nProductNameNormalizer.ctorParameters = () => [\n    { type: OccConfig }\n];\nProductNameNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function ProductNameNormalizer_Factory() { return new ProductNameNormalizer(ɵɵinject(OccConfig)); }, token: ProductNameNormalizer, providedIn: \"root\" });\nProductNameNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], ProductNameNormalizer);\n\nconst PRODUCT_REFERENCES_NORMALIZER = new InjectionToken('ProductReferencesListNormalizer');\n\nlet OccProductReferencesAdapter = class OccProductReferencesAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    load(productCode, referenceType, pageSize) {\n        return this.http\n            .get(this.getEndpoint(productCode, referenceType, pageSize))\n            .pipe(this.converter.pipeable(PRODUCT_REFERENCES_NORMALIZER));\n    }\n    getEndpoint(code, reference, pageSize) {\n        return this.occEndpoints.getUrl('productReferences', {\n            productCode: code,\n        }, { referenceType: reference, pageSize });\n    }\n};\nOccProductReferencesAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccProductReferencesAdapter = __decorate([\n    Injectable()\n], OccProductReferencesAdapter);\n\nconst PRODUCT_REVIEW_NORMALIZER = new InjectionToken('ProductReviewNormalizer');\nconst PRODUCT_REVIEW_SERIALIZER = new InjectionToken('ProductReviewSerializer');\n\nlet OccProductReviewsAdapter = class OccProductReviewsAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    load(productCode, maxCount) {\n        return this.http.get(this.getEndpoint(productCode, maxCount)).pipe(pluck('reviews'), this.converter.pipeableMany(PRODUCT_REVIEW_NORMALIZER));\n    }\n    post(productCode, review) {\n        review = this.converter.convert(review, PRODUCT_REVIEW_SERIALIZER);\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        const body = new URLSearchParams();\n        body.append('headline', review.headline);\n        body.append('comment', review.comment);\n        body.append('rating', review.rating.toString());\n        body.append('alias', review.alias);\n        return this.http.post(this.getEndpoint(productCode), body.toString(), {\n            headers,\n        });\n    }\n    getEndpoint(code, maxCount) {\n        return this.occEndpoints.getUrl('productReviews', {\n            productCode: code,\n        }, { maxCount });\n    }\n};\nOccProductReviewsAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccProductReviewsAdapter = __decorate([\n    Injectable()\n], OccProductReviewsAdapter);\n\nconst PRODUCT_SEARCH_PAGE_NORMALIZER = new InjectionToken('ProductSearchPageNormalizer');\nconst PRODUCT_SUGGESTION_NORMALIZER = new InjectionToken('ProductSuggestionNormalizer');\n\nconst DEFAULT_SEARCH_CONFIG = {\n    pageSize: 20,\n};\nlet OccProductSearchAdapter = class OccProductSearchAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    search(query, searchConfig = DEFAULT_SEARCH_CONFIG) {\n        return this.http\n            .get(this.getSearchEndpoint(query, searchConfig))\n            .pipe(this.converter.pipeable(PRODUCT_SEARCH_PAGE_NORMALIZER));\n    }\n    loadSuggestions(term, pageSize = 3) {\n        return this.http\n            .get(this.getSuggestionEndpoint(term, pageSize.toString()))\n            .pipe(pluck('suggestions'), this.converter.pipeableMany(PRODUCT_SUGGESTION_NORMALIZER));\n    }\n    getSearchEndpoint(query, searchConfig) {\n        return this.occEndpoints.getUrl('productSearch', {}, {\n            query,\n            pageSize: searchConfig.pageSize,\n            currentPage: searchConfig.currentPage,\n            sort: searchConfig.sortCode,\n        });\n    }\n    getSuggestionEndpoint(term, max) {\n        return this.occEndpoints.getUrl('productSuggestions', {}, { term, max });\n    }\n};\nOccProductSearchAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccProductSearchAdapter = __decorate([\n    Injectable()\n], OccProductSearchAdapter);\n\n/**\n * Merge occ fields parameters\n *\n * @param fields Fields definition as string or object\n */\nfunction mergeFields(fields) {\n    const parsedFields = fields.map(f => typeof f === 'string' ? parseFields(f) : f);\n    const mergedFields = optimizeFields(deepMerge({}, ...parsedFields));\n    return stringifyFields(mergedFields);\n}\n/**\n * Optimize fields definition by removing not needed groups\n *\n * @param fields\n */\nfunction optimizeFields(fields = {}) {\n    const keys = Object.keys(fields);\n    if (keys.includes('FULL')) {\n        delete fields['DEFAULT'];\n        delete fields['BASIC'];\n    }\n    else if (keys.includes('DEFAULT')) {\n        delete fields['BASIC'];\n    }\n    Object.keys(fields).forEach(key => {\n        fields[key] = optimizeFields(fields[key]);\n    });\n    return fields;\n}\n/**\n * Parse string field definition to an AST object\n *\n * @param fields Fields string definition\n * @param startIndex Used for recurrence\n */\nfunction parseFields(fields, startIndex = 0) {\n    const parsedFields = {};\n    let i = startIndex;\n    while (i < fields.length) {\n        if (fields[i] === ',') {\n            if (i > startIndex) {\n                parsedFields[fields.substr(startIndex, i - startIndex)] = {};\n            }\n            startIndex = i + 1;\n        }\n        else if (fields[i] === '(') {\n            const subFields = parseFields(fields, i + 1);\n            if (Array.isArray(subFields)) {\n                parsedFields[fields.substr(startIndex, i - startIndex)] = subFields[0];\n                startIndex = subFields[1];\n                i = startIndex - 1;\n            }\n            else {\n                return parsedFields;\n            }\n        }\n        else if (fields[i] === ')') {\n            if (i > startIndex) {\n                parsedFields[fields.substr(startIndex, i - startIndex)] = {};\n            }\n            return [parsedFields, i + 1];\n        }\n        i++;\n    }\n    if (startIndex < fields.length) {\n        parsedFields[fields.substr(startIndex, i - startIndex)] = {};\n    }\n    return parsedFields;\n}\n/**\n * Convert AST object fields definition to string representation\n *\n * @param fields\n */\nfunction stringifyFields(fields) {\n    return Object.keys(fields)\n        .map(key => {\n        const subFields = stringifyFields(fields[key]);\n        return subFields ? `${key}(${subFields})` : key;\n    })\n        .join(',');\n}\n/**\n * Extract part of the object described by fields definition\n *\n * @param data\n * @param fields\n */\nfunction extractFields(data, fields) {\n    const parsedFields = typeof fields === 'string' ? parseFields(fields) : fields;\n    return getObjectPart(data, parsedFields);\n}\nfunction getObjectPart(data, fields) {\n    if (!isObject(data)) {\n        return data;\n    }\n    const keys = Object.keys(fields);\n    if (keys.length === 0 ||\n        // we should not extract parts of the object with ambiguous fields definitions\n        keys.find(el => el === 'BASIC' || el === 'DEFAULT' || el === 'FULL')) {\n        return data;\n    }\n    const result = {};\n    keys.forEach(key => {\n        if (data.hasOwnProperty(key)) {\n            result[key] = getObjectPart(data[key], fields[key]);\n        }\n    });\n    return result;\n}\n\n/**\n * Helper service for optimizing endpoint calls to occ backend\n */\nlet OccFieldsService = class OccFieldsService {\n    constructor(http) {\n        this.http = http;\n        this.FIELDS_PARAM = 'fields';\n    }\n    /**\n     * Merge similar occ endpoints calls by merging fields parameter\n     *\n     * We assume that different scopes are defined by different fields parameters,\n     * so we are grouping all requests with the same urls (except fields definition)\n     * and merging into one request with fields that will satisfy all separate ones.\n     *\n     * @param models\n     */\n    getOptimalUrlGroups(models) {\n        const groupedByUrls = {};\n        for (const model of models) {\n            const [urlPart, fields] = this.splitFields(model.url);\n            if (!groupedByUrls[urlPart]) {\n                groupedByUrls[urlPart] = {};\n            }\n            model.fields = fields ? parseFields(fields) : {};\n            groupedByUrls[urlPart][model.scopedData.scope] = model;\n        }\n        const mergedUrls = {};\n        for (const [url, group] of Object.entries(groupedByUrls)) {\n            const urlWithFields = this.getUrlWithFields(url, Object.values(group).map(lo => lo.fields));\n            mergedUrls[urlWithFields] = group;\n        }\n        return mergedUrls;\n    }\n    /**\n     * Extract fields parameter from occ endpoint url\n     *\n     * @param urlWithFields\n     */\n    splitFields(urlWithFields) {\n        const [url, params] = urlWithFields.split('?');\n        const paramsMap = {};\n        if (params) {\n            params.split('&').map(param => {\n                const keyValue = param.split('=');\n                paramsMap[keyValue[0]] = keyValue[1];\n            });\n        }\n        const nonFieldsParams = Object.keys(paramsMap)\n            .sort()\n            .reduce((id, par) => {\n            if (par !== this.FIELDS_PARAM) {\n                id.push(paramsMap[par] ? `${par}=${paramsMap[par]}` : par);\n            }\n            return id;\n        }, []);\n        const nonFields = nonFieldsParams.join('&');\n        return [\n            nonFields ? `${url}?${nonFields}` : url,\n            paramsMap[this.FIELDS_PARAM],\n        ];\n    }\n    /**\n     * Combine url with field parameters\n     *\n     * @param url\n     * @param fields\n     */\n    getUrlWithFields(url, fields) {\n        const mergedFields = mergeFields(fields);\n        if (mergedFields) {\n            url += url.includes('?') ? '&' : '?';\n            url += `${this.FIELDS_PARAM}=${mergedFields}`;\n        }\n        return url;\n    }\n};\nOccFieldsService.ctorParameters = () => [\n    { type: HttpClient }\n];\nOccFieldsService.ɵprov = ɵɵdefineInjectable({ factory: function OccFieldsService_Factory() { return new OccFieldsService(ɵɵinject(HttpClient)); }, token: OccFieldsService, providedIn: \"root\" });\nOccFieldsService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], OccFieldsService);\n\nlet OccRequestsOptimizerService = class OccRequestsOptimizerService {\n    constructor(http, occFields) {\n        this.http = http;\n        this.occFields = occFields;\n    }\n    /**\n     * Optimize occ endpoint calls merging requests to the same url by merging field parameters\n     *\n     * @param scopedDataWithUrls\n     * @param dataFactory\n     */\n    scopedDataLoad(scopedDataWithUrls, dataFactory) {\n        const result = [];\n        if (!dataFactory) {\n            dataFactory = url => this.http.get(url);\n        }\n        const mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);\n        Object.entries(mergedUrls).forEach(([url, groupedModelsSet]) => {\n            const groupedModels = Object.values(groupedModelsSet);\n            if (groupedModels.length === 1) {\n                // only one scope for url, we can pass the data straightaway\n                result.push(Object.assign(Object.assign({}, groupedModels[0].scopedData), { data$: dataFactory(url) }));\n            }\n            else {\n                // multiple scopes per url\n                // we have to split the model per each scope\n                const data$ = dataFactory(url).pipe(shareReplay(1), \n                // TODO deprecated since 1.4, remove\n                map(data => JSON.parse(JSON.stringify(data))));\n                groupedModels.forEach(modelData => {\n                    result.push(Object.assign(Object.assign({}, modelData.scopedData), { data$: data$.pipe(map(data => extractFields(data, modelData.fields))) }));\n                });\n            }\n        });\n        return result;\n    }\n};\nOccRequestsOptimizerService.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccFieldsService }\n];\nOccRequestsOptimizerService.ɵprov = ɵɵdefineInjectable({ factory: function OccRequestsOptimizerService_Factory() { return new OccRequestsOptimizerService(ɵɵinject(HttpClient), ɵɵinject(OccFieldsService)); }, token: OccRequestsOptimizerService, providedIn: \"root\" });\nOccRequestsOptimizerService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], OccRequestsOptimizerService);\n\nlet OccProductAdapter = class OccProductAdapter {\n    constructor(http, occEndpoints, converter, requestsOptimizer) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n        this.requestsOptimizer = requestsOptimizer;\n    }\n    load(productCode, scope) {\n        return this.http\n            .get(this.getEndpoint(productCode, scope))\n            .pipe(this.converter.pipeable(PRODUCT_NORMALIZER));\n    }\n    loadMany(products) {\n        const scopedDataWithUrls = products.map(model => ({\n            scopedData: model,\n            url: this.getEndpoint(model.code, model.scope),\n        }));\n        return this.requestsOptimizer\n            .scopedDataLoad(scopedDataWithUrls)\n            .map(scopedProduct => (Object.assign(Object.assign({}, scopedProduct), { data$: scopedProduct.data$.pipe(this.converter.pipeable(PRODUCT_NORMALIZER)) })));\n    }\n    getEndpoint(code, scope) {\n        return this.occEndpoints.getUrl('product', {\n            productCode: code,\n        }, undefined, scope);\n    }\n};\nOccProductAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService },\n    { type: OccRequestsOptimizerService }\n];\nOccProductAdapter = __decorate([\n    Injectable()\n], OccProductAdapter);\n\nclass ProductAdapter {\n}\n\nclass ProductReferencesAdapter {\n}\n\nclass ProductReviewsAdapter {\n}\n\nclass ProductSearchAdapter {\n}\n\nvar ProductScope;\n(function (ProductScope) {\n    ProductScope[\"LIST\"] = \"list\";\n    ProductScope[\"DETAILS\"] = \"details\";\n    ProductScope[\"ATTRIBUTES\"] = \"attributes\";\n    ProductScope[\"VARIANTS\"] = \"variants\";\n})(ProductScope || (ProductScope = {}));\n\nconst defaultOccProductConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                product: 'products/${productCode}?fields=DEFAULT,averageRating,images(FULL),classifications,manufacturer,numberOfReviews,categories(FULL),baseOptions,baseProduct,variantOptions,variantType',\n                product_scopes: {\n                    list: 'products/${productCode}?fields=code,name,summary,price(formattedValue),images(DEFAULT,galleryIndex)',\n                    details: 'products/${productCode}?fields=averageRating,stock(DEFAULT),description,availableForPickup,code,url,price(DEFAULT),numberOfReviews,manufacturer,categories(FULL),priceRange,multidimensional,configuratorType,configurable,tags,images(FULL)',\n                    attributes: 'products/${productCode}?fields=classifications',\n                    variants: 'products/${productCode}?fields=name,purchasable,baseOptions(DEFAULT),baseProduct,variantOptions(DEFAULT),variantType',\n                },\n                productReviews: 'products/${productCode}/reviews',\n                // Uncomment this when occ gets configured\n                // productReferences:\n                //   'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))&referenceType=${referenceType}',\n                productReferences: 'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))',\n                // tslint:disable:max-line-length\n                productSearch: 'products/search?fields=products(code,name,summary,price(FULL),images(DEFAULT),stock(FULL),averageRating,variantOptions),facets,breadcrumbs,pagination(DEFAULT),sorts(DEFAULT),freeTextSearch',\n                // tslint:enable\n                productSuggestions: 'products/suggestions',\n            },\n        },\n        loadingScopes: {\n            product: {\n                details: {\n                    include: [ProductScope.LIST, ProductScope.VARIANTS],\n                },\n            },\n        },\n    },\n};\n\nlet ProductOccModule = class ProductOccModule {\n};\nProductOccModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            ConfigModule.withConfig(defaultOccProductConfig),\n        ],\n        providers: [\n            {\n                provide: ProductAdapter,\n                useClass: OccProductAdapter,\n            },\n            {\n                provide: PRODUCT_NORMALIZER,\n                useExisting: ProductImageNormalizer,\n                multi: true,\n            },\n            {\n                provide: PRODUCT_NORMALIZER,\n                useExisting: ProductNameNormalizer,\n                multi: true,\n            },\n            {\n                provide: ProductReferencesAdapter,\n                useClass: OccProductReferencesAdapter,\n            },\n            {\n                provide: PRODUCT_REFERENCES_NORMALIZER,\n                useExisting: OccProductReferencesListNormalizer,\n                multi: true,\n            },\n            {\n                provide: ProductSearchAdapter,\n                useClass: OccProductSearchAdapter,\n            },\n            {\n                provide: PRODUCT_SEARCH_PAGE_NORMALIZER,\n                useExisting: OccProductSearchPageNormalizer,\n                multi: true,\n            },\n            {\n                provide: ProductReviewsAdapter,\n                useClass: OccProductReviewsAdapter,\n            },\n        ],\n    })\n], ProductOccModule);\n\nconst LANGUAGE_NORMALIZER = new InjectionToken('LanguageNormalizer');\nconst CURRENCY_NORMALIZER = new InjectionToken('CurrencyNormalizer');\nconst COUNTRY_NORMALIZER = new InjectionToken('CountryNormalizer');\nconst REGION_NORMALIZER = new InjectionToken('RegionNormalizer');\n\nlet OccSiteAdapter = class OccSiteAdapter {\n    constructor(http, occEndpointsService, converterService) {\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n        this.converterService = converterService;\n    }\n    loadLanguages() {\n        return this.http\n            .get(this.occEndpointsService.getUrl('languages'))\n            .pipe(map(languageList => languageList.languages), this.converterService.pipeableMany(LANGUAGE_NORMALIZER));\n    }\n    loadCurrencies() {\n        return this.http\n            .get(this.occEndpointsService.getUrl('currencies'))\n            .pipe(map(currencyList => currencyList.currencies), this.converterService.pipeableMany(CURRENCY_NORMALIZER));\n    }\n    loadCountries(type) {\n        return this.http\n            .get(this.occEndpointsService.getUrl('countries', undefined, type ? { type } : undefined))\n            .pipe(map(countryList => countryList.countries), this.converterService.pipeableMany(COUNTRY_NORMALIZER));\n    }\n    loadRegions(countryIsoCode) {\n        return this.http\n            .get(this.occEndpointsService.getUrl('regions', { isoCode: countryIsoCode }))\n            .pipe(map(regionList => regionList.regions), this.converterService.pipeableMany(REGION_NORMALIZER));\n    }\n    loadBaseSite() {\n        const baseUrl = this.occEndpointsService.getBaseEndpoint();\n        const urlSplits = baseUrl.split('/');\n        const activeSite = urlSplits.pop();\n        const url = urlSplits.join('/') + '/basesites';\n        const params = new HttpParams({\n            fromString: 'fields=FULL',\n        });\n        return this.http\n            .get(url, { params: params })\n            .pipe(map(siteList => {\n            return siteList.baseSites.find(site => site.uid === activeSite);\n        }));\n    }\n};\nOccSiteAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccSiteAdapter = __decorate([\n    Injectable()\n], OccSiteAdapter);\n\nclass SiteAdapter {\n}\n\nconst defaultOccSiteContextConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                languages: 'languages',\n                currencies: 'currencies',\n                countries: 'countries',\n                regions: 'countries/${isoCode}/regions?fields=regions(name,isocode,isocodeShort)',\n            },\n        },\n    },\n};\n\n/**\n * Facade that provides easy access to curreny state, actions and selectors.\n */\nlet CurrencyService = class CurrencyService {\n    constructor(store, winRef, config) {\n        this.store = store;\n        this.config = config;\n        this.sessionStorage = winRef.sessionStorage;\n    }\n    /**\n     * Represents all the currencies supported by the current store.\n     */\n    getAll() {\n        return this.store.pipe(select(getAllCurrencies), tap(currencies => {\n            if (!currencies) {\n                this.store.dispatch(new LoadCurrencies());\n            }\n        }), filter(currenies => Boolean(currenies)));\n    }\n    /**\n     * Represents the isocode of the active currency.\n     */\n    getActive() {\n        return this.store.pipe(select(getActiveCurrency), filter(active => Boolean(active)));\n    }\n    /**\n     * Sets the active language.\n     */\n    setActive(isocode) {\n        return this.store\n            .pipe(select(getActiveCurrency), take(1))\n            .subscribe(activeCurrency => {\n            if (activeCurrency !== isocode) {\n                this.store.dispatch(new SetActiveCurrency(isocode));\n            }\n        });\n    }\n    /**\n     * Initials the active currency. The active currency is either given\n     * by the last visit (stored in session storage) or by the\n     * default session currency of the store.\n     */\n    initialize() {\n        const sessionCurrency = this.sessionStorage && this.sessionStorage.getItem('currency');\n        if (sessionCurrency &&\n            getContextParameterValues(this.config, CURRENCY_CONTEXT_ID).includes(sessionCurrency)) {\n            this.setActive(sessionCurrency);\n        }\n        else {\n            this.setActive(getContextParameterDefault(this.config, CURRENCY_CONTEXT_ID));\n        }\n    }\n};\nCurrencyService.ctorParameters = () => [\n    { type: Store },\n    { type: WindowRef },\n    { type: SiteContextConfig }\n];\nCurrencyService = __decorate([\n    Injectable()\n], CurrencyService);\n\n/**\n * Facade that provides easy access to language state, actions and selectors.\n */\nlet LanguageService = class LanguageService {\n    constructor(store, winRef, config) {\n        this.store = store;\n        this.config = config;\n        this.sessionStorage = winRef.sessionStorage;\n    }\n    /**\n     * Represents all the languages supported by the current store.\n     */\n    getAll() {\n        return this.store.pipe(select(getAllLanguages), tap(languages => {\n            if (!languages) {\n                this.store.dispatch(new LoadLanguages());\n            }\n        }), filter(languages => Boolean(languages)));\n    }\n    /**\n     * Represents the isocode of the active language.\n     */\n    getActive() {\n        return this.store.pipe(select(getActiveLanguage), filter(active => Boolean(active)));\n    }\n    /**\n     * Sets the active language.\n     */\n    setActive(isocode) {\n        return this.store\n            .pipe(select(getActiveLanguage), take(1))\n            .subscribe(activeLanguage => {\n            if (activeLanguage !== isocode) {\n                this.store.dispatch(new SetActiveLanguage(isocode));\n            }\n        });\n    }\n    /**\n     * Initials the active language. The active language is either given\n     * by the last visit (stored in session storage) or by the\n     * default session language of the store.\n     */\n    initialize() {\n        const sessionLanguage = this.sessionStorage && this.sessionStorage.getItem('language');\n        if (sessionLanguage &&\n            getContextParameterValues(this.config, LANGUAGE_CONTEXT_ID).includes(sessionLanguage)) {\n            this.setActive(sessionLanguage);\n        }\n        else {\n            this.setActive(getContextParameterDefault(this.config, LANGUAGE_CONTEXT_ID));\n        }\n    }\n};\nLanguageService.ctorParameters = () => [\n    { type: Store },\n    { type: WindowRef },\n    { type: SiteContextConfig }\n];\nLanguageService = __decorate([\n    Injectable()\n], LanguageService);\n\nlet SiteContextInterceptor = class SiteContextInterceptor {\n    constructor(languageService, currencyService, occEndpoints, config) {\n        this.languageService = languageService;\n        this.currencyService = currencyService;\n        this.occEndpoints = occEndpoints;\n        this.config = config;\n        this.activeLang = getContextParameterDefault(this.config, LANGUAGE_CONTEXT_ID);\n        this.activeCurr = getContextParameterDefault(this.config, CURRENCY_CONTEXT_ID);\n        this.languageService\n            .getActive()\n            .subscribe(data => (this.activeLang = data));\n        this.currencyService.getActive().subscribe(data => {\n            this.activeCurr = data;\n        });\n    }\n    intercept(request, next) {\n        if (request.url.includes(this.occEndpoints.getBaseEndpoint())) {\n            request = request.clone({\n                setParams: {\n                    lang: this.activeLang,\n                    curr: this.activeCurr,\n                },\n            });\n        }\n        return next.handle(request);\n    }\n};\nSiteContextInterceptor.ctorParameters = () => [\n    { type: LanguageService },\n    { type: CurrencyService },\n    { type: OccEndpointsService },\n    { type: SiteContextConfig }\n];\nSiteContextInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function SiteContextInterceptor_Factory() { return new SiteContextInterceptor(ɵɵinject(LanguageService), ɵɵinject(CurrencyService), ɵɵinject(OccEndpointsService), ɵɵinject(SiteContextConfig)); }, token: SiteContextInterceptor, providedIn: \"root\" });\nSiteContextInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], SiteContextInterceptor);\n\nlet SiteContextOccModule = class SiteContextOccModule {\n};\nSiteContextOccModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            ConfigModule.withConfig(defaultOccSiteContextConfig),\n        ],\n        providers: [\n            {\n                provide: SiteAdapter,\n                useClass: OccSiteAdapter,\n            },\n            {\n                provide: HTTP_INTERCEPTORS,\n                useExisting: SiteContextInterceptor,\n                multi: true,\n            },\n        ],\n    })\n], SiteContextOccModule);\n\nclass StoreFinderAdapter {\n}\n\nconst defaultOccStoreFinderConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                store: 'stores/${storeId}?fields=FULL',\n                stores: 'stores?fields=stores(name,displayName,formattedDistance,openingHours(weekDayOpeningList(FULL),specialDayOpeningList(FULL)),geoPoint(latitude,longitude),address(line1,line2,town,region(FULL),postalCode,phone,country,email), features),pagination(DEFAULT),sorts(DEFAULT)',\n                storescounts: 'stores/storescounts',\n            },\n        },\n    },\n};\n\nlet StoreFinderConnector = class StoreFinderConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    search(query, searchConfig, longitudeLatitude) {\n        return this.adapter.search(query, searchConfig, longitudeLatitude);\n    }\n    getCounts() {\n        return this.adapter.loadCounts();\n    }\n    get(storeId) {\n        return this.adapter.load(storeId);\n    }\n};\nStoreFinderConnector.ctorParameters = () => [\n    { type: StoreFinderAdapter }\n];\nStoreFinderConnector.ɵprov = ɵɵdefineInjectable({ factory: function StoreFinderConnector_Factory() { return new StoreFinderConnector(ɵɵinject(StoreFinderAdapter)); }, token: StoreFinderConnector, providedIn: \"root\" });\nStoreFinderConnector = __decorate([\n    Injectable({ providedIn: 'root' })\n], StoreFinderConnector);\n\nconst POINT_OF_SERVICE_NORMALIZER = new InjectionToken('PointOfServiceNormalizer');\nconst STORE_FINDER_SEARCH_PAGE_NORMALIZER = new InjectionToken('StoreFinderSearchPageNormalizer');\nconst STORE_COUNT_NORMALIZER = new InjectionToken('StoreCountNormalizer');\n\nlet OccStoreFinderAdapter = class OccStoreFinderAdapter {\n    constructor(http, occEndpointsService, converterService) {\n        this.http = http;\n        this.occEndpointsService = occEndpointsService;\n        this.converterService = converterService;\n    }\n    search(query, searchConfig, longitudeLatitude) {\n        return this.callOccFindStores(query, searchConfig, longitudeLatitude).pipe(this.converterService.pipeable(STORE_FINDER_SEARCH_PAGE_NORMALIZER));\n    }\n    loadCounts() {\n        return this.http\n            .get(this.occEndpointsService.getUrl('storescounts'))\n            .pipe(map(({ countriesAndRegionsStoreCount }) => countriesAndRegionsStoreCount), this.converterService.pipeableMany(STORE_COUNT_NORMALIZER));\n    }\n    load(storeId) {\n        return this.http\n            .get(this.occEndpointsService.getUrl('store', { storeId }))\n            .pipe(this.converterService.pipeable(POINT_OF_SERVICE_NORMALIZER));\n    }\n    callOccFindStores(query, searchConfig, longitudeLatitude) {\n        const params = {};\n        if (longitudeLatitude) {\n            params['longitude'] = String(longitudeLatitude.longitude);\n            params['latitude'] = String(longitudeLatitude.latitude);\n            params['radius'] = String('10000000');\n        }\n        else {\n            params['query'] = query;\n        }\n        if (searchConfig.pageSize) {\n            params['pageSize'] = String(searchConfig.pageSize);\n        }\n        if (searchConfig.currentPage) {\n            params['currentPage'] = String(searchConfig.currentPage);\n        }\n        if (searchConfig.sort) {\n            params['sort'] = searchConfig.sort;\n        }\n        return this.http.get(this.occEndpointsService.getUrl('stores', undefined, params));\n    }\n};\nOccStoreFinderAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccStoreFinderAdapter = __decorate([\n    Injectable()\n], OccStoreFinderAdapter);\n\nlet StoreFinderOccModule = class StoreFinderOccModule {\n};\nStoreFinderOccModule = __decorate([\n    NgModule({\n        imports: [ConfigModule.withConfig(defaultOccStoreFinderConfig)],\n        providers: [{ provide: StoreFinderAdapter, useClass: OccStoreFinderAdapter }],\n    })\n], StoreFinderOccModule);\n\nconst CONSENT_TEMPLATE_NORMALIZER = new InjectionToken('ConsentTemplateNormalizer');\n\nlet OccAnonymousConsentTemplatesAdapter = class OccAnonymousConsentTemplatesAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    loadAnonymousConsentTemplates() {\n        const url = this.occEndpoints.getUrl('anonymousConsentTemplates');\n        return this.http.get(url).pipe(catchError(error => throwError(error)), map(consentList => consentList.consentTemplates), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));\n    }\n};\nOccAnonymousConsentTemplatesAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccAnonymousConsentTemplatesAdapter = __decorate([\n    Injectable()\n], OccAnonymousConsentTemplatesAdapter);\n\nlet OccUserAddressAdapter = class OccUserAddressAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    loadAll(userId) {\n        const url = this.occEndpoints.getUrl('addresses', { userId });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http.get(url, { headers }).pipe(catchError((error) => throwError(error)), map(addressList => addressList.addresses), this.converter.pipeableMany(ADDRESS_NORMALIZER));\n    }\n    add(userId, address) {\n        const url = this.occEndpoints.getUrl('addresses', { userId });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        address = this.converter.convert(address, ADDRESS_SERIALIZER);\n        return this.http\n            .post(url, address, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n    update(userId, addressId, address) {\n        const url = this.occEndpoints.getUrl('addressDetail', {\n            userId,\n            addressId,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        address = this.converter.convert(address, ADDRESS_SERIALIZER);\n        return this.http\n            .patch(url, address, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n    verify(userId, address) {\n        const url = this.occEndpoints.getUrl('addressVerification', { userId });\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        if (userId === OCC_USER_ID_ANONYMOUS) {\n            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        }\n        address = this.converter.convert(address, ADDRESS_SERIALIZER);\n        return this.http.post(url, address, { headers }).pipe(catchError((error) => throwError(error)), this.converter.pipeable(ADDRESS_VALIDATION_NORMALIZER));\n    }\n    delete(userId, addressId) {\n        const url = this.occEndpoints.getUrl('addressDetail', {\n            userId,\n            addressId,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http\n            .delete(url, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nOccUserAddressAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccUserAddressAdapter = __decorate([\n    Injectable()\n], OccUserAddressAdapter);\n\nlet OccUserConsentAdapter = class OccUserConsentAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    loadConsents(userId) {\n        const url = this.occEndpoints.getUrl('consentTemplates', { userId });\n        const headers = new HttpHeaders({ 'Cache-Control': 'no-cache' });\n        return this.http.get(url, { headers }).pipe(catchError((error) => throwError(error)), map(consentList => consentList.consentTemplates), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));\n    }\n    giveConsent(userId, consentTemplateId, consentTemplateVersion) {\n        const url = this.occEndpoints.getUrl('consents', { userId });\n        const httpParams = new HttpParams()\n            .set('consentTemplateId', consentTemplateId)\n            .set('consentTemplateVersion', consentTemplateVersion.toString());\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Cache-Control': 'no-cache',\n        });\n        return this.http\n            .post(url, httpParams, { headers })\n            .pipe(catchError(error => throwError(error)), this.converter.pipeable(CONSENT_TEMPLATE_NORMALIZER));\n    }\n    withdrawConsent(userId, consentCode) {\n        const headers = new HttpHeaders({\n            'Cache-Control': 'no-cache',\n        });\n        const url = this.occEndpoints.getUrl('consentDetail', {\n            userId,\n            consentId: consentCode,\n        });\n        return this.http.delete(url, { headers });\n    }\n};\nOccUserConsentAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccUserConsentAdapter = __decorate([\n    Injectable()\n], OccUserConsentAdapter);\n\nconst ORDER_HISTORY_NORMALIZER = new InjectionToken('OrderHistoryNormalizer');\nconst CONSIGNMENT_TRACKING_NORMALIZER = new InjectionToken('ConsignmentTrackingNormalizer');\nconst ORDER_RETURN_REQUEST_NORMALIZER = new InjectionToken('OrderReturnRequestNormalizer');\nconst ORDER_RETURN_REQUEST_INPUT_SERIALIZER = new InjectionToken('OrderReturnRequestInputSerializer');\nconst ORDER_RETURNS_NORMALIZER = new InjectionToken('OrderReturnsNormalizer');\n\nlet OccUserOrderAdapter = class OccUserOrderAdapter {\n    constructor(http, occEndpoints, converter, featureConfigService) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n        this.featureConfigService = featureConfigService;\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    getOrderEndpoint(userId) {\n        const orderEndpoint = 'users/' + userId + '/orders';\n        return this.occEndpoints.getEndpoint(orderEndpoint);\n    }\n    load(userId, orderCode) {\n        // TODO: Deprecated, remove Issue #4125\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyLoad(userId, orderCode);\n        }\n        const url = this.occEndpoints.getUrl('orderDetail', {\n            userId,\n            orderId: orderCode,\n        });\n        let headers = new HttpHeaders();\n        if (userId === OCC_USER_ID_ANONYMOUS) {\n            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        }\n        return this.http\n            .get(url, { headers })\n            .pipe(this.converter.pipeable(ORDER_NORMALIZER));\n    }\n    loadHistory(userId, pageSize, currentPage, sort) {\n        // TODO: Deprecated, remove Issue #4125\n        if (!this.featureConfigService.isLevel('1.1')) {\n            return this.legacyLoadHistory(userId, pageSize, currentPage, sort);\n        }\n        const params = {};\n        if (pageSize) {\n            params['pageSize'] = pageSize.toString();\n        }\n        if (currentPage) {\n            params['currentPage'] = currentPage.toString();\n        }\n        if (sort) {\n            params['sort'] = sort.toString();\n        }\n        const url = this.occEndpoints.getUrl('orderHistory', { userId }, params);\n        return this.http\n            .get(url)\n            .pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyLoad(userId, orderCode) {\n        const url = this.getOrderEndpoint(userId) + '/' + orderCode;\n        const params = new HttpParams({\n            fromString: 'fields=FULL',\n        });\n        return this.http\n            .get(url, {\n            params,\n        })\n            .pipe(this.converter.pipeable(ORDER_NORMALIZER));\n    }\n    /**\n     * @deprecated Since 1.1\n     * Use configurable endpoints.\n     * Remove issue: #4125\n     */\n    legacyLoadHistory(userId, pageSize, currentPage, sort) {\n        const url = this.getOrderEndpoint(userId);\n        let params = new HttpParams();\n        if (pageSize) {\n            params = params.set('pageSize', pageSize.toString());\n        }\n        if (currentPage) {\n            params = params.set('currentPage', currentPage.toString());\n        }\n        if (sort) {\n            params = params.set('sort', sort);\n        }\n        return this.http\n            .get(url, { params: params })\n            .pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));\n    }\n    getConsignmentTracking(orderCode, consignmentCode, userId = OCC_USER_ID_CURRENT) {\n        const url = this.occEndpoints.getUrl('consignmentTracking', {\n            userId,\n            orderCode,\n            consignmentCode,\n        });\n        return this.http\n            .get(url)\n            .pipe(this.converter.pipeable(CONSIGNMENT_TRACKING_NORMALIZER));\n    }\n    cancel(userId, orderCode, cancelRequestInput) {\n        const url = this.occEndpoints.getUrl('cancelOrder', {\n            userId,\n            orderId: orderCode,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http\n            .post(url, cancelRequestInput, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n    createReturnRequest(userId, returnRequestInput) {\n        const url = this.occEndpoints.getUrl('returnOrder', {\n            userId,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        returnRequestInput = this.converter.convert(returnRequestInput, ORDER_RETURN_REQUEST_INPUT_SERIALIZER);\n        return this.http.post(url, returnRequestInput, { headers }).pipe(catchError((error) => throwError(error)), this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));\n    }\n    loadReturnRequestList(userId, pageSize, currentPage, sort) {\n        const params = {};\n        if (pageSize) {\n            params['pageSize'] = pageSize.toString();\n        }\n        if (currentPage) {\n            params['currentPage'] = currentPage.toString();\n        }\n        if (sort) {\n            params['sort'] = sort.toString();\n        }\n        const url = this.occEndpoints.getUrl('orderReturns', { userId }, params);\n        return this.http\n            .get(url)\n            .pipe(this.converter.pipeable(ORDER_RETURNS_NORMALIZER));\n    }\n    loadReturnRequestDetail(userId, returnRequestCode) {\n        const url = this.occEndpoints.getUrl('orderReturnDetail', {\n            userId,\n            returnRequestCode,\n        });\n        return this.http\n            .get(url)\n            .pipe(this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));\n    }\n    cancelReturnRequest(userId, returnRequestCode, returnRequestModification) {\n        const url = this.occEndpoints.getUrl('cancelReturn', {\n            userId,\n            returnRequestCode,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http\n            .patch(url, returnRequestModification, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nOccUserOrderAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService },\n    { type: FeatureConfigService }\n];\nOccUserOrderAdapter = __decorate([\n    Injectable()\n], OccUserOrderAdapter);\n\nlet OccUserPaymentAdapter = class OccUserPaymentAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    loadAll(userId) {\n        const url = this.occEndpoints.getUrl('paymentDetailsAll', { userId }) + '?saved=true';\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http.get(url, { headers }).pipe(catchError((error) => throwError(error)), map(methodList => methodList.payments), this.converter.pipeableMany(PAYMENT_DETAILS_NORMALIZER));\n    }\n    delete(userId, paymentMethodID) {\n        const url = this.occEndpoints.getUrl('paymentDetail', {\n            userId,\n            paymentDetailId: paymentMethodID,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http\n            .delete(url, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n    setDefault(userId, paymentMethodID) {\n        const url = this.occEndpoints.getUrl('paymentDetail', {\n            userId,\n            paymentDetailId: paymentMethodID,\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        return this.http\n            .patch(url, \n        // TODO: Remove billingAddress property\n        { billingAddress: { titleCode: 'mr' }, defaultPayment: true }, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nOccUserPaymentAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccUserPaymentAdapter = __decorate([\n    Injectable()\n], OccUserPaymentAdapter);\n\nconst USER_NORMALIZER = new InjectionToken('UserNormalizer');\nconst USER_SERIALIZER = new InjectionToken('UserSerializer');\nconst USER_SIGN_UP_SERIALIZER = new InjectionToken('UserSignUpSerializer');\nconst TITLE_NORMALIZER = new InjectionToken('TitleNormalizer');\n\nlet OccUserAdapter = class OccUserAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    load(userId) {\n        const url = this.occEndpoints.getUrl('user', { userId });\n        return this.http\n            .get(url)\n            .pipe(this.converter.pipeable(USER_NORMALIZER));\n    }\n    update(userId, user) {\n        const url = this.occEndpoints.getUrl('user', { userId });\n        user = this.converter.convert(user, USER_SERIALIZER);\n        return this.http.patch(url, user);\n    }\n    register(user) {\n        const url = this.occEndpoints.getUrl('userRegister');\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        user = this.converter.convert(user, USER_SIGN_UP_SERIALIZER);\n        return this.http\n            .post(url, user, { headers })\n            .pipe(this.converter.pipeable(USER_NORMALIZER));\n    }\n    registerGuest(guid, password) {\n        const url = this.occEndpoints.getUrl('userRegister');\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        const httpParams = new HttpParams()\n            .set('guid', guid)\n            .set('password', password);\n        return this.http\n            .post(url, httpParams, { headers })\n            .pipe(this.converter.pipeable(USER_NORMALIZER));\n    }\n    requestForgotPasswordEmail(userEmailAddress) {\n        const url = this.occEndpoints.getUrl('userForgotPassword');\n        const httpParams = new HttpParams().set('userId', userEmailAddress);\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        return this.http.post(url, httpParams, { headers });\n    }\n    resetPassword(token, newPassword) {\n        const url = this.occEndpoints.getUrl('userResetPassword');\n        let headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n        return this.http.post(url, { token, newPassword }, { headers });\n    }\n    updateEmail(userId, currentPassword, newUserId) {\n        const url = this.occEndpoints.getUrl('userUpdateLoginId', { userId });\n        const httpParams = new HttpParams()\n            .set('password', currentPassword)\n            .set('newLogin', newUserId);\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http.put(url, httpParams, { headers });\n    }\n    updatePassword(userId, oldPassword, newPassword) {\n        const url = this.occEndpoints.getUrl('userUpdatePassword', { userId });\n        const httpParams = new HttpParams()\n            .set('old', oldPassword)\n            .set('new', newPassword);\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http.put(url, httpParams, { headers });\n    }\n    remove(userId) {\n        const url = this.occEndpoints.getUrl('user', { userId });\n        return this.http.delete(url);\n    }\n    loadTitles() {\n        const url = this.occEndpoints.getUrl('titles');\n        return this.http.get(url).pipe(map(titleList => titleList.titles), this.converter.pipeableMany(TITLE_NORMALIZER));\n    }\n};\nOccUserAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccUserAdapter = __decorate([\n    Injectable()\n], OccUserAdapter);\n\nclass AnonymousConsentTemplatesAdapter {\n}\n\nclass UserAddressAdapter {\n}\n\nclass UserConsentAdapter {\n}\n\nclass UserOrderAdapter {\n}\n\nclass UserPaymentAdapter {\n}\n\nclass UserAdapter {\n}\n\nconst defaultOccUserConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                // tslint:disable:max-line-length\n                user: 'users/${userId}',\n                userRegister: 'users',\n                userForgotPassword: 'forgottenpasswordtokens',\n                userResetPassword: 'resetpassword',\n                userUpdateLoginId: 'users/${userId}/login',\n                userUpdatePassword: 'users/${userId}/password',\n                titles: 'titles',\n                paymentDetailsAll: 'users/${userId}/paymentdetails',\n                paymentDetail: 'users/${userId}/paymentdetails/${paymentDetailId}',\n                orderHistory: 'users/${userId}/orders',\n                orderDetail: 'users/${userId}/orders/${orderId}?fields=FULL',\n                anonymousConsentTemplates: 'users/anonymous/consenttemplates',\n                consentTemplates: 'users/${userId}/consenttemplates',\n                consents: 'users/${userId}/consents',\n                consentDetail: 'users/${userId}/consents/${consentId}',\n                addresses: 'users/${userId}/addresses',\n                addressDetail: 'users/${userId}/addresses/${addressId}',\n                addressVerification: 'users/${userId}/addresses/verification',\n                consignmentTracking: 'users/${userId}/orders/${orderCode}/consignments/${consignmentCode}/tracking',\n                customerCoupons: 'users/${userId}/customercoupons',\n                claimCoupon: 'users/${userId}/customercoupons/${couponCode}/claim',\n                couponNotification: 'users/${userId}/customercoupons/${couponCode}/notification',\n                notificationPreference: 'users/${userId}/notificationpreferences',\n                productInterests: 'users/${userId}/productinterests',\n                getProductInterests: 'users/${userId}/productinterests?fields=sorts,pagination,results(productInterestEntry,product(code))',\n                cancelOrder: 'users/${userId}/orders/${orderId}/cancellation',\n                returnOrder: 'users/${userId}/orderReturns?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',\n                orderReturns: 'users/${userId}/orderReturns?fields=BASIC',\n                orderReturnDetail: 'users/${userId}/orderReturns/${returnRequestCode}?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',\n                cancelReturn: 'users/${userId}/orderReturns/${returnRequestCode}',\n            },\n        },\n    },\n};\n\nclass CustomerCouponAdapter {\n}\n\nconst CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER = new InjectionToken('CustomerCouponSearchResultNormalizer');\n\nlet OccCustomerCouponAdapter = class OccCustomerCouponAdapter {\n    constructor(http, occEndpoints, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.converter = converter;\n    }\n    getCustomerCoupons(userId, pageSize, currentPage, sort) {\n        const url = this.occEndpoints.getUrl('customerCoupons', { userId });\n        let params = new HttpParams().set('sort', sort ? sort : 'startDate:asc');\n        if (pageSize) {\n            params = params.set('pageSize', pageSize.toString());\n        }\n        if (currentPage) {\n            params = params.set('currentPage', currentPage.toString());\n        }\n        const headers = this.newHttpHeader();\n        return this.http\n            .get(url, { headers, params })\n            .pipe(this.converter.pipeable(CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER));\n    }\n    turnOffNotification(userId, couponCode) {\n        const url = this.occEndpoints.getUrl('couponNotification', {\n            userId,\n            couponCode,\n        });\n        const headers = this.newHttpHeader();\n        return this.http.delete(url, { headers });\n    }\n    turnOnNotification(userId, couponCode) {\n        const url = this.occEndpoints.getUrl('couponNotification', {\n            userId,\n            couponCode,\n        });\n        const headers = this.newHttpHeader();\n        return this.http.post(url, { headers });\n    }\n    claimCustomerCoupon(userId, couponCode) {\n        const url = this.occEndpoints.getUrl('claimCoupon', {\n            userId,\n            couponCode,\n        });\n        const headers = this.newHttpHeader();\n        return this.http.post(url, { headers });\n    }\n    newHttpHeader() {\n        return new HttpHeaders({\n            'Content-Type': 'application/json',\n        });\n    }\n};\nOccCustomerCouponAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: ConverterService }\n];\nOccCustomerCouponAdapter = __decorate([\n    Injectable()\n], OccCustomerCouponAdapter);\n\nclass UserNotificationPreferenceAdapter {\n}\n\nconst NOTIFICATION_PREFERENCE_SERIALIZER = new InjectionToken('NotificationPreferenceSerializer');\nconst NOTIFICATION_PREFERENCE_NORMALIZER = new InjectionToken('NotificationPreferenceNormalizer');\n\nlet UserNotificationPreferenceConnector = class UserNotificationPreferenceConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    loadAll(userId) {\n        return this.adapter.loadAll(userId);\n    }\n    update(userId, preferences) {\n        return this.adapter.update(userId, preferences);\n    }\n};\nUserNotificationPreferenceConnector.ctorParameters = () => [\n    { type: UserNotificationPreferenceAdapter }\n];\nUserNotificationPreferenceConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserNotificationPreferenceConnector_Factory() { return new UserNotificationPreferenceConnector(ɵɵinject(UserNotificationPreferenceAdapter)); }, token: UserNotificationPreferenceConnector, providedIn: \"root\" });\nUserNotificationPreferenceConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserNotificationPreferenceConnector);\n\nconst headers = new HttpHeaders({\n    'Content-Type': 'application/json',\n});\nlet OccUserNotificationPreferenceAdapter = class OccUserNotificationPreferenceAdapter {\n    constructor(http, converter, occEndpoints) {\n        this.http = http;\n        this.converter = converter;\n        this.occEndpoints = occEndpoints;\n    }\n    loadAll(userId) {\n        return this.http\n            .get(this.occEndpoints.getUrl('notificationPreference', { userId }), {\n            headers,\n        })\n            .pipe(map(list => list.preferences), this.converter.pipeableMany(NOTIFICATION_PREFERENCE_NORMALIZER), catchError((error) => throwError(error)));\n    }\n    update(userId, preferences) {\n        preferences = this.converter.convert(preferences, NOTIFICATION_PREFERENCE_SERIALIZER);\n        return this.http\n            .patch(this.occEndpoints.getUrl('notificationPreference', { userId }), { preferences: preferences }, { headers })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nOccUserNotificationPreferenceAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: ConverterService },\n    { type: OccEndpointsService }\n];\nOccUserNotificationPreferenceAdapter = __decorate([\n    Injectable()\n], OccUserNotificationPreferenceAdapter);\n\nconst PRODUCT_INTERESTS_NORMALIZER = new InjectionToken('ProductInterestsNormalizer');\n\nconst headers$1 = new HttpHeaders({\n    'Content-Type': 'application/json',\n});\nlet OccUserInterestsAdapter = class OccUserInterestsAdapter {\n    constructor(http, occEndpoints, config, converter) {\n        this.http = http;\n        this.occEndpoints = occEndpoints;\n        this.config = config;\n        this.converter = converter;\n    }\n    getInterests(userId, pageSize, currentPage, sort, productCode, notificationType) {\n        let params = new HttpParams().set('sort', sort ? sort : 'name:asc');\n        if (pageSize) {\n            params = params.set('pageSize', pageSize.toString());\n        }\n        if (currentPage) {\n            params = params.set('currentPage', currentPage.toString());\n        }\n        if (productCode) {\n            params = params.set('productCode', productCode);\n        }\n        if (notificationType) {\n            params = params.set('notificationType', notificationType.toString());\n        }\n        return this.http\n            .get(this.occEndpoints.getUrl('getProductInterests', { userId }), {\n            headers: headers$1,\n            params,\n        })\n            .pipe(this.converter.pipeable(PRODUCT_INTERESTS_NORMALIZER), catchError((error) => throwError(error)));\n    }\n    removeInterest(userId, item) {\n        const r = [];\n        item.productInterestEntry.forEach((entry) => {\n            const params = new HttpParams()\n                .set('productCode', item.product.code)\n                .set('notificationType', entry.interestType);\n            r.push(this.http\n                .delete(this.occEndpoints.getUrl('productInterests', { userId }), {\n                params: params,\n            })\n                .pipe(catchError((error) => throwError(error))));\n        });\n        return forkJoin(r);\n    }\n    addInterest(userId, productCode, notificationType) {\n        const params = new HttpParams()\n            .set('productCode', productCode)\n            .set('notificationType', notificationType.toString());\n        return this.http\n            .post(this.occEndpoints.getUrl('productInterests', { userId }), {}, {\n            headers: headers$1,\n            params,\n        })\n            .pipe(catchError((error) => throwError(error)));\n    }\n};\nOccUserInterestsAdapter.ctorParameters = () => [\n    { type: HttpClient },\n    { type: OccEndpointsService },\n    { type: OccConfig },\n    { type: ConverterService }\n];\nOccUserInterestsAdapter = __decorate([\n    Injectable()\n], OccUserInterestsAdapter);\n\nclass UserInterestsAdapter {\n}\n\nlet OccUserInterestsNormalizer = class OccUserInterestsNormalizer {\n    constructor(converter) {\n        this.converter = converter;\n    }\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source && source.results) {\n            target.results = source.results.map(result => (Object.assign(Object.assign({}, result), { product: this.converter.convert(result.product, PRODUCT_NORMALIZER) })));\n        }\n        return target;\n    }\n};\nOccUserInterestsNormalizer.ctorParameters = () => [\n    { type: ConverterService }\n];\nOccUserInterestsNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccUserInterestsNormalizer_Factory() { return new OccUserInterestsNormalizer(ɵɵinject(ConverterService)); }, token: OccUserInterestsNormalizer, providedIn: \"root\" });\nOccUserInterestsNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccUserInterestsNormalizer);\n\nlet OccReturnRequestNormalizer = class OccReturnRequestNormalizer {\n    constructor(converter) {\n        this.converter = converter;\n    }\n    convert(source, target) {\n        if (target === undefined) {\n            target = Object.assign({}, source);\n        }\n        if (source.returnEntries) {\n            target.returnEntries = source.returnEntries.map(entry => (Object.assign(Object.assign({}, entry), { orderEntry: this.convertOrderEntry(entry.orderEntry) })));\n        }\n        return target;\n    }\n    convertOrderEntry(source) {\n        return Object.assign(Object.assign({}, source), { product: this.converter.convert(source.product, PRODUCT_NORMALIZER) });\n    }\n};\nOccReturnRequestNormalizer.ctorParameters = () => [\n    { type: ConverterService }\n];\nOccReturnRequestNormalizer.ɵprov = ɵɵdefineInjectable({ factory: function OccReturnRequestNormalizer_Factory() { return new OccReturnRequestNormalizer(ɵɵinject(ConverterService)); }, token: OccReturnRequestNormalizer, providedIn: \"root\" });\nOccReturnRequestNormalizer = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccReturnRequestNormalizer);\n\nlet UserOccModule = class UserOccModule {\n};\nUserOccModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            ConfigModule.withConfig(defaultOccUserConfig),\n        ],\n        providers: [\n            { provide: UserAdapter, useClass: OccUserAdapter },\n            { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },\n            { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },\n            {\n                provide: AnonymousConsentTemplatesAdapter,\n                useClass: OccAnonymousConsentTemplatesAdapter,\n            },\n            {\n                provide: UserPaymentAdapter,\n                useClass: OccUserPaymentAdapter,\n            },\n            { provide: UserOrderAdapter, useClass: OccUserOrderAdapter },\n            { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },\n            {\n                provide: UserNotificationPreferenceAdapter,\n                useClass: OccUserNotificationPreferenceAdapter,\n            },\n            { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },\n            {\n                provide: PRODUCT_INTERESTS_NORMALIZER,\n                useExisting: OccUserInterestsNormalizer,\n                multi: true,\n            },\n            {\n                provide: ORDER_RETURN_REQUEST_NORMALIZER,\n                useExisting: OccReturnRequestNormalizer,\n                multi: true,\n            },\n        ],\n    })\n], UserOccModule);\n\nlet JavaRegExpConverter = class JavaRegExpConverter {\n    constructor() {\n        /**\n         * Pattern that extracts modifiers from the Java regexp.\n         *\n         * Java regexps MAY start with ONE or MANY modifiers like `(?MODIFIERS)PATTERN`. Examples:\n         * - `(?i)` for Case Insensitive Mode: `(?i)PATTERN`\n         * - `(?u)` for Unicode-Aware Case Folding; `(?u)PATTERN`\n         * - or multiple combined:  `(?iu)PATTERN`\n         * - (more modifiers in the official Java docs https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)\n         *\n         * This pattern extracts 3 parts from the input string, i.e. for `(?iu)PATTERN`:\n         *    1. original modifiers syntax, i.e. `(?iu)` (or undefined if no modifiers present)\n         *    2. extracted modifiers, i.e. `iu` (or undefined if no modifiers present)\n         *    3. the rest of the regexp, i.e. `PATTERN`\n         */\n        this.EXTRACT_JAVA_REGEXP_MODIFIERS = /^(\\(\\?([a-z]+)\\))?(.*)/;\n    }\n    /**\n     * Converts RegExp from Java syntax to Javascript, by recognizing Java regexp modifiers\n     * and converting them to the Javascript ones (i.e. case insensitive mode: `(?i)PATTERN` -> `/pattern/i`)\n     *\n     * **CAUTION!** Not all features and modifiers of Java regexps are valid in Javascript!\n     * If unsupported feature or modifier is used, then `null` will be returned instead of Javascript RegExp.\n     *\n     * See differences between Java and Javascript regexps:\n     * - https://stackoverflow.com/questions/8754444/convert-javascript-regular-expression-to-java-syntax\n     * - https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines#Language_features\n     */\n    toJsRegExp(javaSyntax) {\n        const parts = javaSyntax.match(this.EXTRACT_JAVA_REGEXP_MODIFIERS);\n        if (!parts) {\n            return null;\n        }\n        const [, , modifiers, jsSyntax] = parts;\n        try {\n            return new RegExp(jsSyntax, modifiers);\n        }\n        catch (error) {\n            if (isDevMode()) {\n                console.warn(`WARNING: Could not convert Java regexp into Javascript. Original regexp: ${javaSyntax} \\nMessage: ${error}`);\n            }\n            return null;\n        }\n    }\n};\nJavaRegExpConverter.ɵprov = ɵɵdefineInjectable({ factory: function JavaRegExpConverter_Factory() { return new JavaRegExpConverter(); }, token: JavaRegExpConverter, providedIn: \"root\" });\nJavaRegExpConverter = __decorate([\n    Injectable({ providedIn: 'root' })\n], JavaRegExpConverter);\n\n/**\n * The url of the server request when running SSR\n * */\nconst SERVER_REQUEST_URL = new InjectionToken('SERVER_REQUEST_URL');\n/**\n * The url of the server request host when running SSR\n * */\nconst SERVER_REQUEST_ORIGIN = new InjectionToken('SERVER_REQUEST_ORIGIN');\n\nlet OccLoadedConfigConverter = class OccLoadedConfigConverter {\n    constructor(javaRegExpConverter) {\n        this.javaRegExpConverter = javaRegExpConverter;\n    }\n    fromOccBaseSites(baseSites, currentUrl) {\n        const baseSite = baseSites.find(site => this.isCurrentBaseSite(site, currentUrl));\n        if (!baseSite) {\n            throw this.getError(`Current url (${currentUrl}) doesn't match with any of url patterns of any base site.`);\n        }\n        // Although `stores` property is an array, typically there is only one store. So we return the first store from the list.\n        const baseStore = baseSite.stores && baseSite.stores[0];\n        if (!baseStore) {\n            throw this.getError(`Current base site (${baseSite.uid}) doesn't have any base store.`);\n        }\n        return {\n            baseSite: baseSite.uid,\n            languages: this.getIsoCodes(baseStore.languages, baseSite.defaultLanguage || baseStore.defaultLanguage),\n            currencies: this.getIsoCodes(baseStore.currencies, baseStore.defaultCurrency),\n            urlParameters: this.getUrlParams(baseSite.urlEncodingAttributes),\n        };\n    }\n    toSiteContextConfig({ baseSite, languages, currencies, urlParameters: urlEncodingAttributes, }) {\n        const result = {\n            context: {\n                urlParameters: urlEncodingAttributes,\n                [BASE_SITE_CONTEXT_ID]: [baseSite],\n                [LANGUAGE_CONTEXT_ID]: languages,\n                [CURRENCY_CONTEXT_ID]: currencies,\n            },\n        };\n        return result;\n    }\n    toI18nConfig({ languages }) {\n        return { i18n: { fallbackLang: languages[0] } };\n    }\n    isCurrentBaseSite(site, currentUrl) {\n        const index = (site.urlPatterns || []).findIndex(javaRegexp => {\n            const jsRegexp = this.javaRegExpConverter.toJsRegExp(javaRegexp);\n            if (jsRegexp) {\n                const result = jsRegexp.test(currentUrl);\n                return result;\n            }\n        });\n        return index !== -1;\n    }\n    /**\n     * Returns an array of url encoded site context parameters.\n     *\n     * It maps the string \"storefront\" (used in OCC) to the \"baseSite\" (used in Spartacus)\n     */\n    getUrlParams(params) {\n        const STOREFRONT_PARAM = 'storefront';\n        return (params || []).map(param => param === STOREFRONT_PARAM ? BASE_SITE_CONTEXT_ID : param);\n    }\n    /**\n     * Returns iso codes in a array, where the first element is the default iso code.\n     */\n    getIsoCodes(elements, defaultElement) {\n        const result = this.moveToFirst(elements, el => el.isocode === defaultElement.isocode).map(el => el.isocode);\n        return result;\n    }\n    /**\n     * Moves to the start of the array the first element that satisfies the given predicate.\n     *\n     * @param array array to modify\n     * @param predicate function called on elements\n     */\n    moveToFirst(array, predicate) {\n        array = [...array];\n        const index = array.findIndex(predicate);\n        if (index !== -1) {\n            const [el] = array.splice(index, 1);\n            array.unshift(el);\n        }\n        return array;\n    }\n    getError(message) {\n        return new Error(`Error: Cannot get base site config! ${message}`);\n    }\n};\nOccLoadedConfigConverter.ctorParameters = () => [\n    { type: JavaRegExpConverter }\n];\nOccLoadedConfigConverter.ɵprov = ɵɵdefineInjectable({ factory: function OccLoadedConfigConverter_Factory() { return new OccLoadedConfigConverter(ɵɵinject(JavaRegExpConverter)); }, token: OccLoadedConfigConverter, providedIn: \"root\" });\nOccLoadedConfigConverter = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccLoadedConfigConverter);\n\nlet OccSitesConfigLoader = class OccSitesConfigLoader {\n    constructor(config, http) {\n        this.config = config;\n        this.http = http;\n        this.endpoint = 'basesites?fields=baseSites(uid,defaultLanguage(isocode),urlEncodingAttributes,urlPatterns,stores(currencies(isocode),defaultCurrency(isocode),languages(isocode),defaultLanguage(isocode)))';\n    }\n    get baseEndpoint() {\n        return ((this.config.backend.occ.baseUrl || '') + this.config.backend.occ.prefix);\n    }\n    get url() {\n        return `${this.baseEndpoint}${this.endpoint}`;\n    }\n    load() {\n        if (!this.config || !this.config.backend || !this.config.backend.occ) {\n            return throwError(new Error(`Missing config for OCC backend!`));\n        }\n        return this.http\n            .get(this.url)\n            .pipe(map(({ baseSites }) => baseSites));\n    }\n};\nOccSitesConfigLoader.ctorParameters = () => [\n    { type: OccConfig },\n    { type: HttpClient }\n];\nOccSitesConfigLoader.ɵprov = ɵɵdefineInjectable({ factory: function OccSitesConfigLoader_Factory() { return new OccSitesConfigLoader(ɵɵinject(OccConfig), ɵɵinject(HttpClient)); }, token: OccSitesConfigLoader, providedIn: \"root\" });\nOccSitesConfigLoader = __decorate([\n    Injectable({ providedIn: 'root' })\n], OccSitesConfigLoader);\n\nconst EXTERNAL_CONFIG_TRANSFER_ID = makeStateKey('cx-external-config');\nlet OccConfigLoaderService = class OccConfigLoaderService {\n    constructor(platform, document, config, sitesConfigLoader, converter, transferState, serverRequestUrl) {\n        this.platform = platform;\n        this.document = document;\n        this.config = config;\n        this.sitesConfigLoader = sitesConfigLoader;\n        this.converter = converter;\n        this.transferState = transferState;\n        this.serverRequestUrl = serverRequestUrl;\n    }\n    get currentUrl() {\n        if (isPlatformBrowser(this.platform)) {\n            return this.document.location.href;\n        }\n        if (this.serverRequestUrl) {\n            return this.serverRequestUrl;\n        }\n        if (isDevMode()) {\n            console.error(`Please provide token 'SERVER_REQUEST_URL' with the requested URL for SSR`);\n        }\n    }\n    /**\n     * Initializes the Spartacus config asynchronously basing on the external config\n     */\n    loadConfig() {\n        return this.get()\n            .pipe(tap(externalConfig => this.transfer(externalConfig)), map(externalConfig => deepMerge({}, ...this.getConfigChunks(externalConfig))))\n            .toPromise();\n    }\n    /**\n     * Returns the external config\n     */\n    get() {\n        const rehydratedExternalConfig = this.rehydrate();\n        return rehydratedExternalConfig\n            ? of(rehydratedExternalConfig)\n            : this.load();\n    }\n    /**\n     * Loads the external config from backend\n     */\n    load() {\n        return this.sitesConfigLoader\n            .load()\n            .pipe(map(baseSites => this.converter.fromOccBaseSites(baseSites, this.currentUrl)));\n    }\n    /**\n     * Tries to rehydrate external config in the browser from SSR\n     */\n    rehydrate() {\n        if (this.transferState && isPlatformBrowser(this.platform)) {\n            return this.transferState.get(EXTERNAL_CONFIG_TRANSFER_ID, undefined);\n        }\n    }\n    /**\n     * Transfers the given external config in SSR to the browser\n     *\n     * @param externalConfig\n     */\n    transfer(externalConfig) {\n        if (this.transferState &&\n            isPlatformServer(this.platform) &&\n            externalConfig) {\n            this.transferState.set(EXTERNAL_CONFIG_TRANSFER_ID, externalConfig);\n        }\n    }\n    getConfigChunks(externalConfig) {\n        const chunks = [this.converter.toSiteContextConfig(externalConfig)];\n        if (this.shouldReturnI18nChunk()) {\n            chunks.push(this.converter.toI18nConfig(externalConfig));\n        }\n        return chunks;\n    }\n    shouldReturnI18nChunk() {\n        const fallbackLangExists = typeof (this.config &&\n            this.config.i18n &&\n            this.config.i18n.fallbackLang) !== 'undefined';\n        if (fallbackLangExists && isDevMode()) {\n            console.warn(`There is an already provided static config for 'i18n.fallbackLang', so the value from OCC loaded config is ignored.`);\n        }\n        return !fallbackLangExists;\n    }\n};\nOccConfigLoaderService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },\n    { type: OccSitesConfigLoader },\n    { type: OccLoadedConfigConverter },\n    { type: TransferState, decorators: [{ type: Optional }] },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [SERVER_REQUEST_URL,] }] }\n];\nOccConfigLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function OccConfigLoaderService_Factory() { return new OccConfigLoaderService(ɵɵinject(PLATFORM_ID), ɵɵinject(DOCUMENT), ɵɵinject(Config), ɵɵinject(OccSitesConfigLoader), ɵɵinject(OccLoadedConfigConverter), ɵɵinject(TransferState, 8), ɵɵinject(SERVER_REQUEST_URL, 8)); }, token: OccConfigLoaderService, providedIn: \"root\" });\nOccConfigLoaderService = __decorate([\n    Injectable({ providedIn: 'root' }),\n    __param(0, Inject(PLATFORM_ID)),\n    __param(1, Inject(DOCUMENT)),\n    __param(2, Inject(Config)),\n    __param(5, Optional()),\n    __param(6, Optional()),\n    __param(6, Inject(SERVER_REQUEST_URL))\n], OccConfigLoaderService);\n\nvar OccConfigLoaderModule_1;\n/**\n * Initializes the Spartacus config asynchronously basing on the external config\n */\nfunction initConfig(configLoader, config) {\n    /**\n     * Load config for `context` from backend only when there is no static config for `context.baseSite`\n     */\n    if (!config.context || !config.context[BASE_SITE_CONTEXT_ID]) {\n        return {\n            scopes: ['context', 'i18n.fallbackLang'],\n            configFactory: () => configLoader.loadConfig(),\n        };\n    }\n    return null;\n}\n/**\n * Re-provides the external config chunk given before Angular bootstrap\n */\nlet OccConfigLoaderModule = OccConfigLoaderModule_1 = class OccConfigLoaderModule {\n    static forRoot() {\n        return {\n            ngModule: OccConfigLoaderModule_1,\n            providers: [\n                {\n                    provide: CONFIG_INITIALIZER,\n                    useFactory: initConfig,\n                    deps: [OccConfigLoaderService, SiteContextConfig],\n                    multi: true,\n                },\n            ],\n        };\n    }\n};\nOccConfigLoaderModule = OccConfigLoaderModule_1 = __decorate([\n    NgModule()\n], OccConfigLoaderModule);\n\nconst OCC_BASE_URL_META_TAG_NAME = 'occ-backend-base-url';\nconst OCC_BASE_URL_META_TAG_PLACEHOLDER = 'OCC_BACKEND_BASE_URL_VALUE';\nconst MEDIA_BASE_URL_META_TAG_NAME = 'media-backend-base-url';\nconst MEDIA_BASE_URL_META_TAG_PLACEHOLDER = 'MEDIA_BACKEND_BASE_URL_VALUE';\nfunction occServerConfigFromMetaTagFactory(meta) {\n    const baseUrl = getMetaTagContent(OCC_BASE_URL_META_TAG_NAME, meta);\n    return baseUrl && baseUrl !== OCC_BASE_URL_META_TAG_PLACEHOLDER\n        ? { backend: { occ: { baseUrl } } }\n        : {};\n}\nfunction mediaServerConfigFromMetaTagFactory(meta) {\n    const baseUrl = getMetaTagContent(MEDIA_BASE_URL_META_TAG_NAME, meta);\n    return baseUrl && baseUrl !== MEDIA_BASE_URL_META_TAG_PLACEHOLDER\n        ? { backend: { media: { baseUrl } } }\n        : {};\n}\nfunction getMetaTagContent(name, meta) {\n    const metaTag = meta.getTag(`name=\"${name}\"`);\n    return metaTag && metaTag.content;\n}\nfunction provideConfigFromMetaTags() {\n    return [\n        provideConfigFactory(occServerConfigFromMetaTagFactory, [Meta]),\n        provideConfigFactory(mediaServerConfigFromMetaTagFactory, [Meta]),\n    ];\n}\n\nconst defaultOccConfig = {\n    backend: {\n        occ: {\n            prefix: '/rest/v2/',\n        },\n        media: {},\n    },\n};\n\nfunction occConfigValidator(config) {\n    if (config.backend === undefined ||\n        config.backend.occ === undefined ||\n        config.backend.occ.baseUrl === undefined) {\n        return 'Please configure backend.occ.baseUrl before using storefront library!';\n    }\n}\n\nvar Occ;\n(function (Occ) {\n    /**\n     * Defines values for PriceType.\n     * Possible values include: 'BUY', 'FROM'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: PriceType = <PriceType>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let PriceType;\n    (function (PriceType) {\n        PriceType[\"BUY\"] = \"BUY\";\n        PriceType[\"FROM\"] = \"FROM\";\n    })(PriceType = Occ.PriceType || (Occ.PriceType = {}));\n    /**\n     * Defines values for ImageType.\n     * Possible values include: 'PRIMARY', 'GALLERY'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: ImageType = <ImageType>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let ImageType;\n    (function (ImageType) {\n        ImageType[\"PRIMARY\"] = \"PRIMARY\";\n        ImageType[\"GALLERY\"] = \"GALLERY\";\n    })(ImageType = Occ.ImageType || (Occ.ImageType = {}));\n    /**\n     * Defines values for Fields.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields = <Fields>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields;\n    (function (Fields) {\n        Fields[\"BASIC\"] = \"BASIC\";\n        Fields[\"DEFAULT\"] = \"DEFAULT\";\n        Fields[\"FULL\"] = \"FULL\";\n    })(Fields = Occ.Fields || (Occ.Fields = {}));\n    /**\n     * Defines values for Fields1.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields1 = <Fields1>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields1;\n    (function (Fields1) {\n        Fields1[\"BASIC\"] = \"BASIC\";\n        Fields1[\"DEFAULT\"] = \"DEFAULT\";\n        Fields1[\"FULL\"] = \"FULL\";\n    })(Fields1 = Occ.Fields1 || (Occ.Fields1 = {}));\n    /**\n     * Defines values for Fields2.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields2 = <Fields2>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields2;\n    (function (Fields2) {\n        Fields2[\"BASIC\"] = \"BASIC\";\n        Fields2[\"DEFAULT\"] = \"DEFAULT\";\n        Fields2[\"FULL\"] = \"FULL\";\n    })(Fields2 = Occ.Fields2 || (Occ.Fields2 = {}));\n    /**\n     * Defines values for Fields3.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields3 = <Fields3>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields3;\n    (function (Fields3) {\n        Fields3[\"BASIC\"] = \"BASIC\";\n        Fields3[\"DEFAULT\"] = \"DEFAULT\";\n        Fields3[\"FULL\"] = \"FULL\";\n    })(Fields3 = Occ.Fields3 || (Occ.Fields3 = {}));\n    /**\n     * Defines values for Fields4.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields4 = <Fields4>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields4;\n    (function (Fields4) {\n        Fields4[\"BASIC\"] = \"BASIC\";\n        Fields4[\"DEFAULT\"] = \"DEFAULT\";\n        Fields4[\"FULL\"] = \"FULL\";\n    })(Fields4 = Occ.Fields4 || (Occ.Fields4 = {}));\n    /**\n     * Defines values for Fields5.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields5 = <Fields5>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields5;\n    (function (Fields5) {\n        Fields5[\"BASIC\"] = \"BASIC\";\n        Fields5[\"DEFAULT\"] = \"DEFAULT\";\n        Fields5[\"FULL\"] = \"FULL\";\n    })(Fields5 = Occ.Fields5 || (Occ.Fields5 = {}));\n    /**\n     * Defines values for Fields6.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields6 = <Fields6>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields6;\n    (function (Fields6) {\n        Fields6[\"BASIC\"] = \"BASIC\";\n        Fields6[\"DEFAULT\"] = \"DEFAULT\";\n        Fields6[\"FULL\"] = \"FULL\";\n    })(Fields6 = Occ.Fields6 || (Occ.Fields6 = {}));\n    /**\n     * Defines values for PageType.\n     * Possible values include: 'ContentPage', 'ProductPage', 'CategoryPage',\n     * 'CatalogPage'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: PageType = <PageType>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let PageType;\n    (function (PageType) {\n        PageType[\"CONTENT_PAGE\"] = \"ContentPage\";\n        PageType[\"PRODUCT_PAGE\"] = \"ProductPage\";\n        PageType[\"CATEGORY_PAGE\"] = \"CategoryPage\";\n        PageType[\"CATALOG_PAGE\"] = \"CatalogPage\";\n    })(PageType = Occ.PageType || (Occ.PageType = {}));\n    /**\n     * Defines values for Fields7.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields7 = <Fields7>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields7;\n    (function (Fields7) {\n        Fields7[\"BASIC\"] = \"BASIC\";\n        Fields7[\"DEFAULT\"] = \"DEFAULT\";\n        Fields7[\"FULL\"] = \"FULL\";\n    })(Fields7 = Occ.Fields7 || (Occ.Fields7 = {}));\n    /**\n     * Defines values for Fields8.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields8 = <Fields8>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields8;\n    (function (Fields8) {\n        Fields8[\"BASIC\"] = \"BASIC\";\n        Fields8[\"DEFAULT\"] = \"DEFAULT\";\n        Fields8[\"FULL\"] = \"FULL\";\n    })(Fields8 = Occ.Fields8 || (Occ.Fields8 = {}));\n    /**\n     * Defines values for Fields9.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields9 = <Fields9>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields9;\n    (function (Fields9) {\n        Fields9[\"BASIC\"] = \"BASIC\";\n        Fields9[\"DEFAULT\"] = \"DEFAULT\";\n        Fields9[\"FULL\"] = \"FULL\";\n    })(Fields9 = Occ.Fields9 || (Occ.Fields9 = {}));\n    /**\n     * Defines values for Fields10.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields10 = <Fields10>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields10;\n    (function (Fields10) {\n        Fields10[\"BASIC\"] = \"BASIC\";\n        Fields10[\"DEFAULT\"] = \"DEFAULT\";\n        Fields10[\"FULL\"] = \"FULL\";\n    })(Fields10 = Occ.Fields10 || (Occ.Fields10 = {}));\n    /**\n     * Defines values for Fields11.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields11 = <Fields11>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields11;\n    (function (Fields11) {\n        Fields11[\"BASIC\"] = \"BASIC\";\n        Fields11[\"DEFAULT\"] = \"DEFAULT\";\n        Fields11[\"FULL\"] = \"FULL\";\n    })(Fields11 = Occ.Fields11 || (Occ.Fields11 = {}));\n    /**\n     * Defines values for Fields12.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields12 = <Fields12>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields12;\n    (function (Fields12) {\n        Fields12[\"BASIC\"] = \"BASIC\";\n        Fields12[\"DEFAULT\"] = \"DEFAULT\";\n        Fields12[\"FULL\"] = \"FULL\";\n    })(Fields12 = Occ.Fields12 || (Occ.Fields12 = {}));\n    /**\n     * Defines values for Fields13.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields13 = <Fields13>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields13;\n    (function (Fields13) {\n        Fields13[\"BASIC\"] = \"BASIC\";\n        Fields13[\"DEFAULT\"] = \"DEFAULT\";\n        Fields13[\"FULL\"] = \"FULL\";\n    })(Fields13 = Occ.Fields13 || (Occ.Fields13 = {}));\n    /**\n     * Defines values for Fields14.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields14 = <Fields14>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields14;\n    (function (Fields14) {\n        Fields14[\"BASIC\"] = \"BASIC\";\n        Fields14[\"DEFAULT\"] = \"DEFAULT\";\n        Fields14[\"FULL\"] = \"FULL\";\n    })(Fields14 = Occ.Fields14 || (Occ.Fields14 = {}));\n    /**\n     * Defines values for Fields15.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields15 = <Fields15>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields15;\n    (function (Fields15) {\n        Fields15[\"BASIC\"] = \"BASIC\";\n        Fields15[\"DEFAULT\"] = \"DEFAULT\";\n        Fields15[\"FULL\"] = \"FULL\";\n    })(Fields15 = Occ.Fields15 || (Occ.Fields15 = {}));\n    /**\n     * Defines values for Fields16.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields16 = <Fields16>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields16;\n    (function (Fields16) {\n        Fields16[\"BASIC\"] = \"BASIC\";\n        Fields16[\"DEFAULT\"] = \"DEFAULT\";\n        Fields16[\"FULL\"] = \"FULL\";\n    })(Fields16 = Occ.Fields16 || (Occ.Fields16 = {}));\n    /**\n     * Defines values for SortEnum.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: SortEnum = <SortEnum>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let SortEnum;\n    (function (SortEnum) {\n        SortEnum[\"BASIC\"] = \"BASIC\";\n        SortEnum[\"DEFAULT\"] = \"DEFAULT\";\n        SortEnum[\"FULL\"] = \"FULL\";\n    })(SortEnum = Occ.SortEnum || (Occ.SortEnum = {}));\n    /**\n     * Defines values for Fields17.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields17 = <Fields17>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields17;\n    (function (Fields17) {\n        Fields17[\"BASIC\"] = \"BASIC\";\n        Fields17[\"DEFAULT\"] = \"DEFAULT\";\n        Fields17[\"FULL\"] = \"FULL\";\n    })(Fields17 = Occ.Fields17 || (Occ.Fields17 = {}));\n    /**\n     * Defines values for Fields18.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields18 = <Fields18>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields18;\n    (function (Fields18) {\n        Fields18[\"BASIC\"] = \"BASIC\";\n        Fields18[\"DEFAULT\"] = \"DEFAULT\";\n        Fields18[\"FULL\"] = \"FULL\";\n    })(Fields18 = Occ.Fields18 || (Occ.Fields18 = {}));\n    /**\n     * Defines values for Fields19.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields19 = <Fields19>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields19;\n    (function (Fields19) {\n        Fields19[\"BASIC\"] = \"BASIC\";\n        Fields19[\"DEFAULT\"] = \"DEFAULT\";\n        Fields19[\"FULL\"] = \"FULL\";\n    })(Fields19 = Occ.Fields19 || (Occ.Fields19 = {}));\n    /**\n     * Defines values for Fields20.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields20 = <Fields20>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields20;\n    (function (Fields20) {\n        Fields20[\"BASIC\"] = \"BASIC\";\n        Fields20[\"DEFAULT\"] = \"DEFAULT\";\n        Fields20[\"FULL\"] = \"FULL\";\n    })(Fields20 = Occ.Fields20 || (Occ.Fields20 = {}));\n    /**\n     * Defines values for Fields21.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields21 = <Fields21>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields21;\n    (function (Fields21) {\n        Fields21[\"BASIC\"] = \"BASIC\";\n        Fields21[\"DEFAULT\"] = \"DEFAULT\";\n        Fields21[\"FULL\"] = \"FULL\";\n    })(Fields21 = Occ.Fields21 || (Occ.Fields21 = {}));\n    /**\n     * Defines values for Fields22.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields22 = <Fields22>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields22;\n    (function (Fields22) {\n        Fields22[\"BASIC\"] = \"BASIC\";\n        Fields22[\"DEFAULT\"] = \"DEFAULT\";\n        Fields22[\"FULL\"] = \"FULL\";\n    })(Fields22 = Occ.Fields22 || (Occ.Fields22 = {}));\n    /**\n     * Defines values for Fields23.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields23 = <Fields23>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields23;\n    (function (Fields23) {\n        Fields23[\"BASIC\"] = \"BASIC\";\n        Fields23[\"DEFAULT\"] = \"DEFAULT\";\n        Fields23[\"FULL\"] = \"FULL\";\n    })(Fields23 = Occ.Fields23 || (Occ.Fields23 = {}));\n    /**\n     * Defines values for Fields24.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields24 = <Fields24>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields24;\n    (function (Fields24) {\n        Fields24[\"BASIC\"] = \"BASIC\";\n        Fields24[\"DEFAULT\"] = \"DEFAULT\";\n        Fields24[\"FULL\"] = \"FULL\";\n    })(Fields24 = Occ.Fields24 || (Occ.Fields24 = {}));\n    /**\n     * Defines values for Fields25.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields25 = <Fields25>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields25;\n    (function (Fields25) {\n        Fields25[\"BASIC\"] = \"BASIC\";\n        Fields25[\"DEFAULT\"] = \"DEFAULT\";\n        Fields25[\"FULL\"] = \"FULL\";\n    })(Fields25 = Occ.Fields25 || (Occ.Fields25 = {}));\n    /**\n     * Defines values for Fields26.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields26 = <Fields26>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields26;\n    (function (Fields26) {\n        Fields26[\"BASIC\"] = \"BASIC\";\n        Fields26[\"DEFAULT\"] = \"DEFAULT\";\n        Fields26[\"FULL\"] = \"FULL\";\n    })(Fields26 = Occ.Fields26 || (Occ.Fields26 = {}));\n    /**\n     * Defines values for Fields27.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields27 = <Fields27>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields27;\n    (function (Fields27) {\n        Fields27[\"BASIC\"] = \"BASIC\";\n        Fields27[\"DEFAULT\"] = \"DEFAULT\";\n        Fields27[\"FULL\"] = \"FULL\";\n    })(Fields27 = Occ.Fields27 || (Occ.Fields27 = {}));\n    /**\n     * Defines values for Fields28.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields28 = <Fields28>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields28;\n    (function (Fields28) {\n        Fields28[\"BASIC\"] = \"BASIC\";\n        Fields28[\"DEFAULT\"] = \"DEFAULT\";\n        Fields28[\"FULL\"] = \"FULL\";\n    })(Fields28 = Occ.Fields28 || (Occ.Fields28 = {}));\n    /**\n     * Defines values for Fields29.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields29 = <Fields29>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields29;\n    (function (Fields29) {\n        Fields29[\"BASIC\"] = \"BASIC\";\n        Fields29[\"DEFAULT\"] = \"DEFAULT\";\n        Fields29[\"FULL\"] = \"FULL\";\n    })(Fields29 = Occ.Fields29 || (Occ.Fields29 = {}));\n    /**\n     * Defines values for Fields30.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields30 = <Fields30>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields30;\n    (function (Fields30) {\n        Fields30[\"BASIC\"] = \"BASIC\";\n        Fields30[\"DEFAULT\"] = \"DEFAULT\";\n        Fields30[\"FULL\"] = \"FULL\";\n    })(Fields30 = Occ.Fields30 || (Occ.Fields30 = {}));\n    /**\n     * Defines values for Fields31.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields31 = <Fields31>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields31;\n    (function (Fields31) {\n        Fields31[\"BASIC\"] = \"BASIC\";\n        Fields31[\"DEFAULT\"] = \"DEFAULT\";\n        Fields31[\"FULL\"] = \"FULL\";\n    })(Fields31 = Occ.Fields31 || (Occ.Fields31 = {}));\n    /**\n     * Defines values for Fields32.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields32 = <Fields32>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields32;\n    (function (Fields32) {\n        Fields32[\"BASIC\"] = \"BASIC\";\n        Fields32[\"DEFAULT\"] = \"DEFAULT\";\n        Fields32[\"FULL\"] = \"FULL\";\n    })(Fields32 = Occ.Fields32 || (Occ.Fields32 = {}));\n    /**\n     * Defines values for Fields33.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields33 = <Fields33>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields33;\n    (function (Fields33) {\n        Fields33[\"BASIC\"] = \"BASIC\";\n        Fields33[\"DEFAULT\"] = \"DEFAULT\";\n        Fields33[\"FULL\"] = \"FULL\";\n    })(Fields33 = Occ.Fields33 || (Occ.Fields33 = {}));\n    /**\n     * Defines values for Fields34.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields34 = <Fields34>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields34;\n    (function (Fields34) {\n        Fields34[\"BASIC\"] = \"BASIC\";\n        Fields34[\"DEFAULT\"] = \"DEFAULT\";\n        Fields34[\"FULL\"] = \"FULL\";\n    })(Fields34 = Occ.Fields34 || (Occ.Fields34 = {}));\n    /**\n     * Defines values for Fields35.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields35 = <Fields35>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields35;\n    (function (Fields35) {\n        Fields35[\"BASIC\"] = \"BASIC\";\n        Fields35[\"DEFAULT\"] = \"DEFAULT\";\n        Fields35[\"FULL\"] = \"FULL\";\n    })(Fields35 = Occ.Fields35 || (Occ.Fields35 = {}));\n    /**\n     * Defines values for Fields36.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields36 = <Fields36>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields36;\n    (function (Fields36) {\n        Fields36[\"BASIC\"] = \"BASIC\";\n        Fields36[\"DEFAULT\"] = \"DEFAULT\";\n        Fields36[\"FULL\"] = \"FULL\";\n    })(Fields36 = Occ.Fields36 || (Occ.Fields36 = {}));\n    /**\n     * Defines values for Fields37.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields37 = <Fields37>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields37;\n    (function (Fields37) {\n        Fields37[\"BASIC\"] = \"BASIC\";\n        Fields37[\"DEFAULT\"] = \"DEFAULT\";\n        Fields37[\"FULL\"] = \"FULL\";\n    })(Fields37 = Occ.Fields37 || (Occ.Fields37 = {}));\n    /**\n     * Defines values for Fields38.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields38 = <Fields38>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields38;\n    (function (Fields38) {\n        Fields38[\"BASIC\"] = \"BASIC\";\n        Fields38[\"DEFAULT\"] = \"DEFAULT\";\n        Fields38[\"FULL\"] = \"FULL\";\n    })(Fields38 = Occ.Fields38 || (Occ.Fields38 = {}));\n    /**\n     * Defines values for Fields39.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields39 = <Fields39>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields39;\n    (function (Fields39) {\n        Fields39[\"BASIC\"] = \"BASIC\";\n        Fields39[\"DEFAULT\"] = \"DEFAULT\";\n        Fields39[\"FULL\"] = \"FULL\";\n    })(Fields39 = Occ.Fields39 || (Occ.Fields39 = {}));\n    /**\n     * Defines values for Fields40.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields40 = <Fields40>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields40;\n    (function (Fields40) {\n        Fields40[\"BASIC\"] = \"BASIC\";\n        Fields40[\"DEFAULT\"] = \"DEFAULT\";\n        Fields40[\"FULL\"] = \"FULL\";\n    })(Fields40 = Occ.Fields40 || (Occ.Fields40 = {}));\n    /**\n     * Defines values for Fields41.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields41 = <Fields41>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields41;\n    (function (Fields41) {\n        Fields41[\"BASIC\"] = \"BASIC\";\n        Fields41[\"DEFAULT\"] = \"DEFAULT\";\n        Fields41[\"FULL\"] = \"FULL\";\n    })(Fields41 = Occ.Fields41 || (Occ.Fields41 = {}));\n    /**\n     * Defines values for Fields42.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields42 = <Fields42>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields42;\n    (function (Fields42) {\n        Fields42[\"BASIC\"] = \"BASIC\";\n        Fields42[\"DEFAULT\"] = \"DEFAULT\";\n        Fields42[\"FULL\"] = \"FULL\";\n    })(Fields42 = Occ.Fields42 || (Occ.Fields42 = {}));\n    /**\n     * Defines values for Fields43.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields43 = <Fields43>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields43;\n    (function (Fields43) {\n        Fields43[\"BASIC\"] = \"BASIC\";\n        Fields43[\"DEFAULT\"] = \"DEFAULT\";\n        Fields43[\"FULL\"] = \"FULL\";\n    })(Fields43 = Occ.Fields43 || (Occ.Fields43 = {}));\n    /**\n     * Defines values for Fields44.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields44 = <Fields44>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields44;\n    (function (Fields44) {\n        Fields44[\"BASIC\"] = \"BASIC\";\n        Fields44[\"DEFAULT\"] = \"DEFAULT\";\n        Fields44[\"FULL\"] = \"FULL\";\n    })(Fields44 = Occ.Fields44 || (Occ.Fields44 = {}));\n    /**\n     * Defines values for Fields45.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields45 = <Fields45>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields45;\n    (function (Fields45) {\n        Fields45[\"BASIC\"] = \"BASIC\";\n        Fields45[\"DEFAULT\"] = \"DEFAULT\";\n        Fields45[\"FULL\"] = \"FULL\";\n    })(Fields45 = Occ.Fields45 || (Occ.Fields45 = {}));\n    /**\n     * Defines values for Fields46.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields46 = <Fields46>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields46;\n    (function (Fields46) {\n        Fields46[\"BASIC\"] = \"BASIC\";\n        Fields46[\"DEFAULT\"] = \"DEFAULT\";\n        Fields46[\"FULL\"] = \"FULL\";\n    })(Fields46 = Occ.Fields46 || (Occ.Fields46 = {}));\n    /**\n     * Defines values for Fields47.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields47 = <Fields47>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields47;\n    (function (Fields47) {\n        Fields47[\"BASIC\"] = \"BASIC\";\n        Fields47[\"DEFAULT\"] = \"DEFAULT\";\n        Fields47[\"FULL\"] = \"FULL\";\n    })(Fields47 = Occ.Fields47 || (Occ.Fields47 = {}));\n    /**\n     * Defines values for Fields48.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields48 = <Fields48>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields48;\n    (function (Fields48) {\n        Fields48[\"BASIC\"] = \"BASIC\";\n        Fields48[\"DEFAULT\"] = \"DEFAULT\";\n        Fields48[\"FULL\"] = \"FULL\";\n    })(Fields48 = Occ.Fields48 || (Occ.Fields48 = {}));\n    /**\n     * Defines values for Fields49.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields49 = <Fields49>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields49;\n    (function (Fields49) {\n        Fields49[\"BASIC\"] = \"BASIC\";\n        Fields49[\"DEFAULT\"] = \"DEFAULT\";\n        Fields49[\"FULL\"] = \"FULL\";\n    })(Fields49 = Occ.Fields49 || (Occ.Fields49 = {}));\n    /**\n     * Defines values for Fields50.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields50 = <Fields50>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields50;\n    (function (Fields50) {\n        Fields50[\"BASIC\"] = \"BASIC\";\n        Fields50[\"DEFAULT\"] = \"DEFAULT\";\n        Fields50[\"FULL\"] = \"FULL\";\n    })(Fields50 = Occ.Fields50 || (Occ.Fields50 = {}));\n    /**\n     * Defines values for Fields51.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields51 = <Fields51>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields51;\n    (function (Fields51) {\n        Fields51[\"BASIC\"] = \"BASIC\";\n        Fields51[\"DEFAULT\"] = \"DEFAULT\";\n        Fields51[\"FULL\"] = \"FULL\";\n    })(Fields51 = Occ.Fields51 || (Occ.Fields51 = {}));\n    /**\n     * Defines values for Fields52.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields52 = <Fields52>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields52;\n    (function (Fields52) {\n        Fields52[\"BASIC\"] = \"BASIC\";\n        Fields52[\"DEFAULT\"] = \"DEFAULT\";\n        Fields52[\"FULL\"] = \"FULL\";\n    })(Fields52 = Occ.Fields52 || (Occ.Fields52 = {}));\n    /**\n     * Defines values for Fields53.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields53 = <Fields53>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields53;\n    (function (Fields53) {\n        Fields53[\"BASIC\"] = \"BASIC\";\n        Fields53[\"DEFAULT\"] = \"DEFAULT\";\n        Fields53[\"FULL\"] = \"FULL\";\n    })(Fields53 = Occ.Fields53 || (Occ.Fields53 = {}));\n    /**\n     * Defines values for Fields54.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields54 = <Fields54>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields54;\n    (function (Fields54) {\n        Fields54[\"BASIC\"] = \"BASIC\";\n        Fields54[\"DEFAULT\"] = \"DEFAULT\";\n        Fields54[\"FULL\"] = \"FULL\";\n    })(Fields54 = Occ.Fields54 || (Occ.Fields54 = {}));\n    /**\n     * Defines values for Fields55.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields55 = <Fields55>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields55;\n    (function (Fields55) {\n        Fields55[\"BASIC\"] = \"BASIC\";\n        Fields55[\"DEFAULT\"] = \"DEFAULT\";\n        Fields55[\"FULL\"] = \"FULL\";\n    })(Fields55 = Occ.Fields55 || (Occ.Fields55 = {}));\n    /**\n     * Defines values for Fields56.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields56 = <Fields56>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields56;\n    (function (Fields56) {\n        Fields56[\"BASIC\"] = \"BASIC\";\n        Fields56[\"DEFAULT\"] = \"DEFAULT\";\n        Fields56[\"FULL\"] = \"FULL\";\n    })(Fields56 = Occ.Fields56 || (Occ.Fields56 = {}));\n    /**\n     * Defines values for Fields57.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields57 = <Fields57>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields57;\n    (function (Fields57) {\n        Fields57[\"BASIC\"] = \"BASIC\";\n        Fields57[\"DEFAULT\"] = \"DEFAULT\";\n        Fields57[\"FULL\"] = \"FULL\";\n    })(Fields57 = Occ.Fields57 || (Occ.Fields57 = {}));\n    /**\n     * Defines values for Fields58.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields58 = <Fields58>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields58;\n    (function (Fields58) {\n        Fields58[\"BASIC\"] = \"BASIC\";\n        Fields58[\"DEFAULT\"] = \"DEFAULT\";\n        Fields58[\"FULL\"] = \"FULL\";\n    })(Fields58 = Occ.Fields58 || (Occ.Fields58 = {}));\n    /**\n     * Defines values for Fields59.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields59 = <Fields59>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields59;\n    (function (Fields59) {\n        Fields59[\"BASIC\"] = \"BASIC\";\n        Fields59[\"DEFAULT\"] = \"DEFAULT\";\n        Fields59[\"FULL\"] = \"FULL\";\n    })(Fields59 = Occ.Fields59 || (Occ.Fields59 = {}));\n    /**\n     * Defines values for Fields60.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields60 = <Fields60>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields60;\n    (function (Fields60) {\n        Fields60[\"BASIC\"] = \"BASIC\";\n        Fields60[\"DEFAULT\"] = \"DEFAULT\";\n        Fields60[\"FULL\"] = \"FULL\";\n    })(Fields60 = Occ.Fields60 || (Occ.Fields60 = {}));\n    /**\n     * Defines values for Fields61.\n     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Fields61 = <Fields61>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Fields61;\n    (function (Fields61) {\n        Fields61[\"BASIC\"] = \"BASIC\";\n        Fields61[\"DEFAULT\"] = \"DEFAULT\";\n        Fields61[\"FULL\"] = \"FULL\";\n    })(Fields61 = Occ.Fields61 || (Occ.Fields61 = {}));\n    /**\n     * Defines values for Type.\n     * Possible values include: 'all', 'product', 'order'\n     * There could be more values for this enum apart from the ones defined here.If\n     * you want to set a value that is not from the known values then you can do\n     * the following:\n     * let param: Type = <Type>\"someUnknownValueThatWillStillBeValid\";\n     * @readonly\n     * @enum {string}\n     */\n    let Type;\n    (function (Type) {\n        Type[\"All\"] = \"all\";\n        Type[\"Product\"] = \"product\";\n        Type[\"Order\"] = \"order\";\n    })(Type = Occ.Type || (Occ.Type = {}));\n    let CONSENT_STATUS;\n    (function (CONSENT_STATUS) {\n        CONSENT_STATUS[\"ANONYMOUS_CONSENT_GIVEN\"] = \"GIVEN\";\n        CONSENT_STATUS[\"ANONYMOUS_CONSENT_WITHDRAWN\"] = \"WITHDRAWN\";\n    })(CONSENT_STATUS = Occ.CONSENT_STATUS || (Occ.CONSENT_STATUS = {}));\n    let NotificationType;\n    (function (NotificationType) {\n        NotificationType[\"BACK_IN_STOCK\"] = \"BACK_IN_STOCK\";\n    })(NotificationType = Occ.NotificationType || (Occ.NotificationType = {}));\n})(Occ || (Occ = {}));\n\nvar OccModule_1;\nlet OccModule = OccModule_1 = class OccModule {\n    static forRoot() {\n        return {\n            ngModule: OccModule_1,\n            providers: [\n                { provide: OccConfig, useExisting: Config },\n                provideConfig(defaultOccConfig),\n                provideConfigValidator(occConfigValidator),\n            ],\n        };\n    }\n};\nOccModule = OccModule_1 = __decorate([\n    NgModule({\n        imports: [\n            AsmOccModule,\n            CmsOccModule,\n            CartOccModule,\n            CheckoutOccModule,\n            ProductOccModule,\n            SiteContextOccModule,\n            StoreFinderOccModule,\n            UserOccModule,\n            OccConfigLoaderModule.forRoot(),\n        ],\n    })\n], OccModule);\n\nlet LoadingScopesService = class LoadingScopesService {\n    constructor(config) {\n        this.config = config;\n    }\n    /**\n     * Aims to expand scopes based on loading scopes config.\n     *\n     * I.e. if 'details' scope includes 'list' scope by configuration, it'll return ['details', 'list']\n     *\n     * If scope data overlaps with each other, the data should be merged in the order of scopes provided,\n     * i.e. the last scope is merged last, overwriting parts of the data already provided by preceding scope.\n     * It should apply also to implicit scopes (that are included by configuration).\n     *\n     * @param model\n     * @param scopes\n     */\n    expand(model, scopes) {\n        const scopesConfig = this.config &&\n            this.config.backend &&\n            this.config.backend.loadingScopes &&\n            this.config.backend.loadingScopes[model];\n        if (scopesConfig) {\n            const expandedScopes = [...scopes];\n            let i = expandedScopes.length;\n            while (i > 0) {\n                i--;\n                const includedScopes = scopesConfig[expandedScopes[i]] &&\n                    scopesConfig[expandedScopes[i]].include;\n                if (includedScopes) {\n                    for (const includedScope of includedScopes) {\n                        if (!expandedScopes.includes(includedScope)) {\n                            expandedScopes.splice(i, 0, includedScope);\n                            i++;\n                        }\n                    }\n                }\n            }\n            return expandedScopes;\n        }\n        return scopes;\n    }\n    /**\n     * Return maxAge for product scope in milliseconds\n     *\n     * @param model\n     * @param scope\n     */\n    getMaxAge(model, scope) {\n        const scopesConfig = this.config &&\n            this.config.backend &&\n            this.config.backend.loadingScopes &&\n            this.config.backend.loadingScopes[model];\n        return (scopesConfig[scope] && scopesConfig[scope].maxAge) * 1000 || 0;\n    }\n};\nLoadingScopesService.ctorParameters = () => [\n    { type: OccConfig }\n];\nLoadingScopesService.ɵprov = ɵɵdefineInjectable({ factory: function LoadingScopesService_Factory() { return new LoadingScopesService(ɵɵinject(OccConfig)); }, token: LoadingScopesService, providedIn: \"root\" });\nLoadingScopesService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], LoadingScopesService);\n\n/**\n * @deprecated since 1.2.0\n * Use OCC_USER_ID_ANONYMOUS instead\n */\nconst ANONYMOUS_USERID = OCC_USER_ID_ANONYMOUS;\n\nconst ANONYMOUS_CONSENTS_HEADER = 'X-Anonymous-Consents';\nlet AnonymousConsentsInterceptor = class AnonymousConsentsInterceptor {\n    constructor(anonymousConsentsService, authService, occEndpoints, config) {\n        this.anonymousConsentsService = anonymousConsentsService;\n        this.authService = authService;\n        this.occEndpoints = occEndpoints;\n        this.config = config;\n    }\n    intercept(request, next) {\n        return iif(() => isFeatureEnabled(this.config, ANONYMOUS_CONSENTS_FEATURE), this.anonymousConsentsService.getConsents().pipe(take(1), withLatestFrom(this.authService.isUserLoggedIn()), switchMap(([consents, isUserLoggedIn]) => {\n            if (!this.isOccUrl(request.url)) {\n                return next.handle(request);\n            }\n            const clonedRequest = this.handleRequest(consents, request);\n            return next.handle(clonedRequest).pipe(tap(event => {\n                if (event instanceof HttpResponse) {\n                    this.handleResponse(isUserLoggedIn, event.headers.get(ANONYMOUS_CONSENTS_HEADER), consents);\n                }\n            }));\n        })), next.handle(request));\n    }\n    handleResponse(isUserLoggedIn, newRawConsents, previousConsents) {\n        if (!isUserLoggedIn && newRawConsents) {\n            let newConsents = [];\n            newConsents = this.anonymousConsentsService.decodeAndDeserialize(newRawConsents);\n            newConsents = this.giveRequiredConsents(newConsents);\n            if (this.anonymousConsentsService.consentsUpdated(newConsents, previousConsents)) {\n                this.anonymousConsentsService.setConsents(newConsents);\n            }\n        }\n    }\n    handleRequest(consents, request) {\n        if (!consents) {\n            return request;\n        }\n        const rawConsents = this.anonymousConsentsService.serializeAndEncode(consents);\n        return request.clone({\n            setHeaders: {\n                [ANONYMOUS_CONSENTS_HEADER]: rawConsents,\n            },\n        });\n    }\n    isOccUrl(url) {\n        return url.includes(this.occEndpoints.getBaseEndpoint());\n    }\n    giveRequiredConsents(consents) {\n        const givenConsents = [...consents];\n        if (Boolean(this.config.anonymousConsents) &&\n            Boolean(this.config.anonymousConsents.requiredConsents)) {\n            for (const consent of givenConsents) {\n                if (this.config.anonymousConsents.requiredConsents.includes(consent.templateCode)) {\n                    consent.consentState = ANONYMOUS_CONSENT_STATUS.GIVEN;\n                }\n            }\n        }\n        return givenConsents;\n    }\n};\nAnonymousConsentsInterceptor.ctorParameters = () => [\n    { type: AnonymousConsentsService },\n    { type: AuthService },\n    { type: OccEndpointsService },\n    { type: AnonymousConsentsConfig }\n];\nAnonymousConsentsInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function AnonymousConsentsInterceptor_Factory() { return new AnonymousConsentsInterceptor(ɵɵinject(AnonymousConsentsService), ɵɵinject(AuthService), ɵɵinject(OccEndpointsService), ɵɵinject(AnonymousConsentsConfig)); }, token: AnonymousConsentsInterceptor, providedIn: \"root\" });\nAnonymousConsentsInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], AnonymousConsentsInterceptor);\n\nconst interceptors$1 = [\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: AnonymousConsentsInterceptor,\n        multi: true,\n    },\n];\n\nconst PROCESS_FEATURE = 'process';\n\nfunction getProcessState() {\n    return createFeatureSelector(PROCESS_FEATURE);\n}\n\nfunction getProcessStateFactory(processId) {\n    return createSelector(getProcessState(), entityState => entityStateSelector(entityState, processId));\n}\nfunction getProcessLoadingFactory(processId) {\n    return createSelector(getProcessStateFactory(processId), loaderState => loaderLoadingSelector(loaderState));\n}\nfunction getProcessSuccessFactory(processId) {\n    return createSelector(getProcessStateFactory(processId), loaderState => loaderSuccessSelector(loaderState));\n}\nfunction getProcessErrorFactory(processId) {\n    return createSelector(getProcessStateFactory(processId), loaderState => loaderErrorSelector(loaderState));\n}\n\nvar process_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getProcessStateFactory: getProcessStateFactory,\n    getProcessLoadingFactory: getProcessLoadingFactory,\n    getProcessSuccessFactory: getProcessSuccessFactory,\n    getProcessErrorFactory: getProcessErrorFactory\n});\n\nconst LOAD_BILLING_COUNTRIES = '[User] Load Billing Countries';\nconst LOAD_BILLING_COUNTRIES_FAIL = '[User] Load Billing Countries Fail';\nconst LOAD_BILLING_COUNTRIES_SUCCESS = '[User] Load Billing Countries Success';\nclass LoadBillingCountries {\n    constructor() {\n        this.type = LOAD_BILLING_COUNTRIES;\n    }\n}\nclass LoadBillingCountriesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_BILLING_COUNTRIES_FAIL;\n    }\n}\nclass LoadBillingCountriesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_BILLING_COUNTRIES_SUCCESS;\n    }\n}\n\nconst LOAD_CONSIGNMENT_TRACKING = '[User] Load Consignment Tracking';\nconst LOAD_CONSIGNMENT_TRACKING_FAIL = '[User] Load Consignment Tracking Fail';\nconst LOAD_CONSIGNMENT_TRACKING_SUCCESS = '[User] Load Consignment Tracking Success';\nconst CLEAR_CONSIGNMENT_TRACKING = '[User] Clear Consignment Tracking';\nclass LoadConsignmentTracking {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CONSIGNMENT_TRACKING;\n    }\n}\nclass LoadConsignmentTrackingFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CONSIGNMENT_TRACKING_FAIL;\n    }\n}\nclass LoadConsignmentTrackingSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CONSIGNMENT_TRACKING_SUCCESS;\n    }\n}\nclass ClearConsignmentTracking {\n    constructor() {\n        this.type = CLEAR_CONSIGNMENT_TRACKING;\n    }\n}\n\nconst LOAD_DELIVERY_COUNTRIES = '[User] Load Delivery Countries';\nconst LOAD_DELIVERY_COUNTRIES_FAIL = '[User] Load Delivery Countries Fail';\nconst LOAD_DELIVERY_COUNTRIES_SUCCESS = '[User] Load Delivery Countries Success';\nclass LoadDeliveryCountries {\n    constructor() {\n        this.type = LOAD_DELIVERY_COUNTRIES;\n    }\n}\nclass LoadDeliveryCountriesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_DELIVERY_COUNTRIES_FAIL;\n    }\n}\nclass LoadDeliveryCountriesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_DELIVERY_COUNTRIES_SUCCESS;\n    }\n}\n\nconst FORGOT_PASSWORD_EMAIL_REQUEST = '[User] Forgot Password Email Request';\nconst FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS = '[User] Forgot Password Email Request Success';\nconst FORGOT_PASSWORD_EMAIL_REQUEST_FAIL = '[User] Forgot Password Email Request Fail';\nclass ForgotPasswordEmailRequest {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = FORGOT_PASSWORD_EMAIL_REQUEST;\n    }\n}\nclass ForgotPasswordEmailRequestFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = FORGOT_PASSWORD_EMAIL_REQUEST_FAIL;\n    }\n}\nclass ForgotPasswordEmailRequestSuccess {\n    constructor() {\n        this.type = FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS;\n    }\n}\n\nconst USER_FEATURE = 'user';\nconst UPDATE_EMAIL_PROCESS_ID = 'updateEmail';\nconst UPDATE_PASSWORD_PROCESS_ID = 'updatePassword';\nconst UPDATE_USER_DETAILS_PROCESS_ID = 'updateUserDetails';\nconst REGISTER_USER_PROCESS_ID = 'registerUser';\nconst REMOVE_USER_PROCESS_ID = 'removeUser';\nconst GIVE_CONSENT_PROCESS_ID = 'giveConsent';\nconst WITHDRAW_CONSENT_PROCESS_ID = 'withdrawConsent';\nconst UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID = 'updateNotificationPreferences';\nconst ADD_PRODUCT_INTEREST_PROCESS_ID = 'addProductInterests';\nconst REMOVE_PRODUCT_INTERESTS_PROCESS_ID = 'removeProductInterests';\nconst CANCEL_ORDER_PROCESS_ID = 'cancelOrder';\nconst CANCEL_RETURN_PROCESS_ID = 'cancelReturn';\nconst USER_CONSENTS = '[User] User Consents';\nconst USER_PAYMENT_METHODS = '[User] User Payment Methods';\nconst USER_ORDERS = '[User] User Orders';\nconst USER_ADDRESSES = '[User] User Addresses';\nconst USER_RETURN_REQUESTS = '[User] Order Return Requests';\nconst USER_RETURN_REQUEST_DETAILS = '[User] Return Request Details';\nconst USER_ORDER_DETAILS = '[User] User Order Details';\nconst REGIONS = '[User] Regions';\nconst CUSTOMER_COUPONS = '[User] Customer Coupons';\nconst SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'subscribeCustomerCoupon';\nconst UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'unsubscribeCustomerCoupon';\nconst CLAIM_CUSTOMER_COUPON_PROCESS_ID = 'claimCustomerCoupon';\nconst NOTIFICATION_PREFERENCES = '[User] Notification Preferences';\nconst PRODUCT_INTERESTS = '[User] Product Interests';\n\nconst LOAD_ORDER_DETAILS = '[User] Load Order Details';\nconst LOAD_ORDER_DETAILS_FAIL = '[User] Load Order Details Fail';\nconst LOAD_ORDER_DETAILS_SUCCESS = '[User] Load Order Details Success';\nconst CLEAR_ORDER_DETAILS = '[User] Clear Order Details';\nconst CANCEL_ORDER = '[User] Cancel Order';\nconst CANCEL_ORDER_FAIL = '[User] Cancel Order Fail';\nconst CANCEL_ORDER_SUCCESS = '[User] Cancel Order Success';\nconst RESET_CANCEL_ORDER_PROCESS = '[User] Reset Cancel Order Process';\nclass LoadOrderDetails extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_ORDER_DETAILS);\n        this.payload = payload;\n        this.type = LOAD_ORDER_DETAILS;\n    }\n}\nclass LoadOrderDetailsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_ORDER_DETAILS, payload);\n        this.payload = payload;\n        this.type = LOAD_ORDER_DETAILS_FAIL;\n    }\n}\nclass LoadOrderDetailsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_ORDER_DETAILS);\n        this.payload = payload;\n        this.type = LOAD_ORDER_DETAILS_SUCCESS;\n    }\n}\nclass ClearOrderDetails extends LoaderResetAction {\n    constructor() {\n        super(USER_ORDER_DETAILS);\n        this.type = CLEAR_ORDER_DETAILS;\n    }\n}\nclass CancelOrder extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);\n        this.payload = payload;\n        this.type = CANCEL_ORDER;\n    }\n}\nclass CancelOrderFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = CANCEL_ORDER_FAIL;\n    }\n}\nclass CancelOrderSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);\n        this.type = CANCEL_ORDER_SUCCESS;\n    }\n}\nclass ResetCancelOrderProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);\n        this.type = RESET_CANCEL_ORDER_PROCESS;\n    }\n}\n\nconst LOAD_USER_PAYMENT_METHODS = '[User] Load User Payment Methods';\nconst LOAD_USER_PAYMENT_METHODS_FAIL = '[User] Load User Payment Methods Fail';\nconst LOAD_USER_PAYMENT_METHODS_SUCCESS = '[User] Load User Payment Methods Success';\nconst SET_DEFAULT_USER_PAYMENT_METHOD = '[User] Set Default User Payment Method';\nconst SET_DEFAULT_USER_PAYMENT_METHOD_FAIL = '[User] Set Default User Payment Method Fail';\nconst SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS = '[User] Set Default User Payment Method Success';\nconst DELETE_USER_PAYMENT_METHOD = '[User] Delete User Payment Method';\nconst DELETE_USER_PAYMENT_METHOD_FAIL = '[User] Delete User Payment Method Fail';\nconst DELETE_USER_PAYMENT_METHOD_SUCCESS = '[User] Delete User  Payment Method Success';\nclass LoadUserPaymentMethods extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS);\n        this.payload = payload;\n        this.type = LOAD_USER_PAYMENT_METHODS;\n    }\n}\nclass LoadUserPaymentMethodsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS, payload);\n        this.payload = payload;\n        this.type = LOAD_USER_PAYMENT_METHODS_FAIL;\n    }\n}\nclass LoadUserPaymentMethodsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS);\n        this.payload = payload;\n        this.type = LOAD_USER_PAYMENT_METHODS_SUCCESS;\n    }\n}\nclass SetDefaultUserPaymentMethod extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS);\n        this.payload = payload;\n        this.type = SET_DEFAULT_USER_PAYMENT_METHOD;\n    }\n}\nclass SetDefaultUserPaymentMethodFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS, payload);\n        this.payload = payload;\n        this.type = SET_DEFAULT_USER_PAYMENT_METHOD_FAIL;\n    }\n}\nclass SetDefaultUserPaymentMethodSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS);\n        this.payload = payload;\n        this.type = SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS;\n    }\n}\nclass DeleteUserPaymentMethod extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS);\n        this.payload = payload;\n        this.type = DELETE_USER_PAYMENT_METHOD;\n    }\n}\nclass DeleteUserPaymentMethodFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS, payload);\n        this.payload = payload;\n        this.type = DELETE_USER_PAYMENT_METHOD_FAIL;\n    }\n}\nclass DeleteUserPaymentMethodSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_PAYMENT_METHODS);\n        this.payload = payload;\n        this.type = DELETE_USER_PAYMENT_METHOD_SUCCESS;\n    }\n}\n\nconst LOAD_REGIONS = '[User] Load Regions';\nconst LOAD_REGIONS_SUCCESS = '[User] Load Regions Success';\nconst LOAD_REGIONS_FAIL = '[User] Load Regions Fail';\nconst CLEAR_REGIONS = '[User] Clear Regions';\nclass LoadRegions extends LoaderLoadAction {\n    constructor(payload) {\n        super(REGIONS);\n        this.payload = payload;\n        this.type = LOAD_REGIONS;\n    }\n}\nclass LoadRegionsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(REGIONS, payload);\n        this.payload = payload;\n        this.type = LOAD_REGIONS_FAIL;\n    }\n}\nclass LoadRegionsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(REGIONS);\n        this.payload = payload;\n        this.type = LOAD_REGIONS_SUCCESS;\n    }\n}\nclass ClearRegions {\n    constructor() {\n        this.type = CLEAR_REGIONS;\n    }\n}\n\nconst RESET_PASSWORD = '[User] Reset Password';\nconst RESET_PASSWORD_SUCCESS = '[User] Reset Password Success';\nconst RESET_PASSWORD_FAIL = '[User] Reset Password Fail';\nclass ResetPassword {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = RESET_PASSWORD;\n    }\n}\nclass ResetPasswordFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = RESET_PASSWORD_FAIL;\n    }\n}\nclass ResetPasswordSuccess {\n    constructor() {\n        this.type = RESET_PASSWORD_SUCCESS;\n    }\n}\n\nconst LOAD_TITLES = '[User] Load Tiltes';\nconst LOAD_TITLES_FAIL = '[User] Load Titles Fail';\nconst LOAD_TITLES_SUCCESS = '[User] Load Titles Success';\nclass LoadTitles {\n    constructor() {\n        this.type = LOAD_TITLES;\n    }\n}\nclass LoadTitlesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_TITLES_FAIL;\n    }\n}\nclass LoadTitlesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_TITLES_SUCCESS;\n    }\n}\n\nconst UPDATE_EMAIL = '[User] Update Email';\nconst UPDATE_EMAIL_ERROR = '[User] Update Email Error';\nconst UPDATE_EMAIL_SUCCESS = '[User] Update Email Success';\nconst RESET_EMAIL = '[User] Reset Email';\nclass UpdateEmailAction extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID);\n        this.payload = payload;\n        this.type = UPDATE_EMAIL;\n    }\n}\nclass UpdateEmailSuccessAction extends EntitySuccessAction {\n    constructor(newUid) {\n        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID);\n        this.newUid = newUid;\n        this.type = UPDATE_EMAIL_SUCCESS;\n    }\n}\nclass UpdateEmailErrorAction extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = UPDATE_EMAIL_ERROR;\n    }\n}\nclass ResetUpdateEmailAction extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID);\n        this.type = RESET_EMAIL;\n    }\n}\n\nconst UPDATE_PASSWORD = '[User] Update Password';\nconst UPDATE_PASSWORD_FAIL = '[User] Update Password Fail';\nconst UPDATE_PASSWORD_SUCCESS = '[User] Update Password Success';\nconst UPDATE_PASSWORD_RESET = '[User] Reset Update Password Process State';\nclass UpdatePassword extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID);\n        this.payload = payload;\n        this.type = UPDATE_PASSWORD;\n    }\n}\nclass UpdatePasswordFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = UPDATE_PASSWORD_FAIL;\n    }\n}\nclass UpdatePasswordSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID);\n        this.type = UPDATE_PASSWORD_SUCCESS;\n    }\n}\nclass UpdatePasswordReset extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID);\n        this.type = UPDATE_PASSWORD_RESET;\n    }\n}\n\nconst LOAD_USER_ADDRESSES = '[User] Load User Addresses';\nconst LOAD_USER_ADDRESSES_FAIL = '[User] Load User Addresses Fail';\nconst LOAD_USER_ADDRESSES_SUCCESS = '[User] Load User Addresses Success';\nconst ADD_USER_ADDRESS = '[User] Add User Address';\nconst ADD_USER_ADDRESS_FAIL = '[User] Add User Address Fail';\nconst ADD_USER_ADDRESS_SUCCESS = '[User] Add User Address Success';\nconst UPDATE_USER_ADDRESS = '[User] Update User Address';\nconst UPDATE_USER_ADDRESS_FAIL = '[User] Update User Address Fail';\nconst UPDATE_USER_ADDRESS_SUCCESS = '[User] Update User Address Success';\nconst DELETE_USER_ADDRESS = '[User] Delete User Address';\nconst DELETE_USER_ADDRESS_FAIL = '[User] Delete User Address Fail';\nconst DELETE_USER_ADDRESS_SUCCESS = '[User] Delete User Address Success';\nclass LoadUserAddresses extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = LOAD_USER_ADDRESSES;\n    }\n}\nclass LoadUserAddressesFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_ADDRESSES, payload);\n        this.payload = payload;\n        this.type = LOAD_USER_ADDRESSES_FAIL;\n    }\n}\nclass LoadUserAddressesSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = LOAD_USER_ADDRESSES_SUCCESS;\n    }\n}\n// Adding address actions\nclass AddUserAddress extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = ADD_USER_ADDRESS;\n    }\n}\nclass AddUserAddressFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_ADDRESSES, payload);\n        this.payload = payload;\n        this.type = ADD_USER_ADDRESS_FAIL;\n    }\n}\nclass AddUserAddressSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = ADD_USER_ADDRESS_SUCCESS;\n    }\n}\n// Updating address actions\nclass UpdateUserAddress extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = UPDATE_USER_ADDRESS;\n    }\n}\nclass UpdateUserAddressFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_ADDRESSES, payload);\n        this.payload = payload;\n        this.type = UPDATE_USER_ADDRESS_FAIL;\n    }\n}\nclass UpdateUserAddressSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = UPDATE_USER_ADDRESS_SUCCESS;\n    }\n}\n// Deleting address actions\nclass DeleteUserAddress extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = DELETE_USER_ADDRESS;\n    }\n}\nclass DeleteUserAddressFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_ADDRESSES, payload);\n        this.payload = payload;\n        this.type = DELETE_USER_ADDRESS_FAIL;\n    }\n}\nclass DeleteUserAddressSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_ADDRESSES);\n        this.payload = payload;\n        this.type = DELETE_USER_ADDRESS_SUCCESS;\n    }\n}\n\nconst LOAD_USER_CONSENTS = '[User] Load User Consents';\nconst LOAD_USER_CONSENTS_SUCCESS = '[User] Load User Consents Success';\nconst LOAD_USER_CONSENTS_FAIL = '[User] Load User Consents Fail';\nconst RESET_LOAD_USER_CONSENTS = '[User] Reset Load User Consents';\nconst GIVE_USER_CONSENT = '[User] Give User Consent';\nconst GIVE_USER_CONSENT_FAIL = '[User] Give User Consent Fail';\nconst GIVE_USER_CONSENT_SUCCESS = '[User] Give User Consent Success';\nconst RESET_GIVE_USER_CONSENT_PROCESS = '[User] Reset Give User Consent Process';\nconst TRANSFER_ANONYMOUS_CONSENT = '[User] Transfer Anonymous Consent';\nconst WITHDRAW_USER_CONSENT = '[User] Withdraw User Consent';\nconst WITHDRAW_USER_CONSENT_FAIL = '[User] Withdraw User Consent Fail';\nconst WITHDRAW_USER_CONSENT_SUCCESS = '[User] Withdraw User Consent Success';\nconst RESET_WITHDRAW_USER_CONSENT_PROCESS = '[User] Reset Withdraw User Consent Process';\nclass LoadUserConsents extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_CONSENTS);\n        this.payload = payload;\n        this.type = LOAD_USER_CONSENTS;\n    }\n}\nclass LoadUserConsentsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_CONSENTS, payload);\n        this.payload = payload;\n        this.type = LOAD_USER_CONSENTS_FAIL;\n    }\n}\nclass LoadUserConsentsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_CONSENTS);\n        this.payload = payload;\n        this.type = LOAD_USER_CONSENTS_SUCCESS;\n    }\n}\nclass ResetLoadUserConsents extends LoaderResetAction {\n    constructor() {\n        super(USER_CONSENTS);\n        this.type = RESET_LOAD_USER_CONSENTS;\n    }\n}\nclass GiveUserConsent extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);\n        this.payload = payload;\n        this.type = GIVE_USER_CONSENT;\n    }\n}\nclass GiveUserConsentFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID, payload);\n        this.type = GIVE_USER_CONSENT_FAIL;\n    }\n}\nclass GiveUserConsentSuccess extends EntitySuccessAction {\n    constructor(consentTemplate) {\n        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);\n        this.consentTemplate = consentTemplate;\n        this.type = GIVE_USER_CONSENT_SUCCESS;\n    }\n}\nclass ResetGiveUserConsentProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);\n        this.type = RESET_GIVE_USER_CONSENT_PROCESS;\n    }\n}\nclass TransferAnonymousConsent {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = TRANSFER_ANONYMOUS_CONSENT;\n    }\n}\nclass WithdrawUserConsent extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);\n        this.payload = payload;\n        this.type = WITHDRAW_USER_CONSENT;\n    }\n}\nclass WithdrawUserConsentFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID, payload);\n        this.type = WITHDRAW_USER_CONSENT_FAIL;\n    }\n}\nclass WithdrawUserConsentSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);\n        this.type = WITHDRAW_USER_CONSENT_SUCCESS;\n    }\n}\nclass ResetWithdrawUserConsentProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);\n        this.type = RESET_WITHDRAW_USER_CONSENT_PROCESS;\n    }\n}\n\nconst LOAD_USER_DETAILS = '[User] Load User Details';\nconst LOAD_USER_DETAILS_FAIL = '[User] Load User Details Fail';\nconst LOAD_USER_DETAILS_SUCCESS = '[User] Load User Details Success';\nconst UPDATE_USER_DETAILS = '[User] Update User Details';\nconst UPDATE_USER_DETAILS_FAIL = '[User] Update User Details Fail';\nconst UPDATE_USER_DETAILS_SUCCESS = '[User] Update User Details Success';\nconst RESET_USER_DETAILS = '[User] Reset User Details';\nclass LoadUserDetails {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_USER_DETAILS;\n    }\n}\nclass LoadUserDetailsFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_USER_DETAILS_FAIL;\n    }\n}\nclass LoadUserDetailsSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_USER_DETAILS_SUCCESS;\n    }\n}\nclass UpdateUserDetails extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID);\n        this.payload = payload;\n        this.type = UPDATE_USER_DETAILS;\n    }\n}\nclass UpdateUserDetailsFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = UPDATE_USER_DETAILS_FAIL;\n    }\n}\nclass UpdateUserDetailsSuccess extends EntitySuccessAction {\n    constructor(userUpdates) {\n        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID);\n        this.userUpdates = userUpdates;\n        this.type = UPDATE_USER_DETAILS_SUCCESS;\n    }\n}\nclass ResetUpdateUserDetails extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID);\n        this.type = RESET_USER_DETAILS;\n    }\n}\n\nconst CLEAR_USER_MISCS_DATA = '[User] Clear User Misc Data';\nclass ClearUserMiscsData {\n    constructor() {\n        this.type = CLEAR_USER_MISCS_DATA;\n    }\n}\n\nconst LOAD_USER_ORDERS = '[User] Load User Orders';\nconst LOAD_USER_ORDERS_FAIL = '[User] Load User Orders Fail';\nconst LOAD_USER_ORDERS_SUCCESS = '[User] Load User Orders Success';\nconst CLEAR_USER_ORDERS = '[User] Clear User Orders';\nclass LoadUserOrders extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_ORDERS);\n        this.payload = payload;\n        this.type = LOAD_USER_ORDERS;\n    }\n}\nclass LoadUserOrdersFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_ORDERS, payload);\n        this.payload = payload;\n        this.type = LOAD_USER_ORDERS_FAIL;\n    }\n}\nclass LoadUserOrdersSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_ORDERS);\n        this.payload = payload;\n        this.type = LOAD_USER_ORDERS_SUCCESS;\n    }\n}\nclass ClearUserOrders extends LoaderResetAction {\n    constructor() {\n        super(USER_ORDERS);\n        this.type = CLEAR_USER_ORDERS;\n    }\n}\n\nconst REGISTER_USER = '[User] Register User';\nconst REGISTER_USER_FAIL = '[User] Register User Fail';\nconst REGISTER_USER_SUCCESS = '[User] Register User Success';\nconst RESET_REGISTER_USER_PROCESS = '[User] Reset Register User Process';\nconst REGISTER_GUEST = '[User] Register Guest';\nconst REGISTER_GUEST_FAIL = '[User] Register Guest Fail';\nconst REGISTER_GUEST_SUCCESS = '[User] Register Guest Success';\nconst REMOVE_USER = '[User] Remove User';\nconst REMOVE_USER_FAIL = '[User] Remove User Fail';\nconst REMOVE_USER_SUCCESS = '[User] Remove User Success';\nconst REMOVE_USER_RESET = '[User] Reset Remove User Process State';\nclass RegisterUser extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);\n        this.payload = payload;\n        this.type = REGISTER_USER;\n    }\n}\nclass RegisterUserFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = REGISTER_USER_FAIL;\n    }\n}\nclass RegisterUserSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);\n        this.type = REGISTER_USER_SUCCESS;\n    }\n}\nclass ResetRegisterUserProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);\n        this.type = RESET_REGISTER_USER_PROCESS;\n    }\n}\nclass RegisterGuest {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REGISTER_GUEST;\n    }\n}\nclass RegisterGuestFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REGISTER_GUEST_FAIL;\n    }\n}\nclass RegisterGuestSuccess {\n    constructor() {\n        this.type = REGISTER_GUEST_SUCCESS;\n    }\n}\nclass RemoveUser extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID);\n        this.payload = payload;\n        this.type = REMOVE_USER;\n    }\n}\nclass RemoveUserFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = REMOVE_USER_FAIL;\n    }\n}\nclass RemoveUserSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID);\n        this.type = REMOVE_USER_SUCCESS;\n    }\n}\nclass RemoveUserReset extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID);\n        this.type = REMOVE_USER_RESET;\n    }\n}\n\nconst LOAD_CUSTOMER_COUPONS = '[User] Load Customer Coupons';\nconst LOAD_CUSTOMER_COUPONS_FAIL = '[User] Load Customer Coupons Fail';\nconst LOAD_CUSTOMER_COUPONS_SUCCESS = '[User] Load Customer Coupons Success';\nconst RESET_LOAD_CUSTOMER_COUPONS = '[User] Reset Load Customer Coupons';\nconst SUBSCRIBE_CUSTOMER_COUPON = '[User] Subscribe Customer Notification Coupon';\nconst SUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Subscribe Customer Coupon Notification Fail';\nconst SUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Subscribe Customer Coupon Notification Success';\nconst RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Subscribe Customer Coupon Process';\nconst UNSUBSCRIBE_CUSTOMER_COUPON = '[User] Unsubscribe Customer Notification Coupon';\nconst UNSUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Unsubscribe Customer Coupon Notification Fail';\nconst UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Unsubscribe Customer Coupon Notification Success';\nconst RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Unsubscribe Customer Coupon Process';\nconst CLAIM_CUSTOMER_COUPON = '[User] Claim Customer';\nconst CLAIM_CUSTOMER_COUPON_FAIL = '[User] Claim Customer Fail';\nconst CLAIM_CUSTOMER_COUPON_SUCCESS = '[User] Claim Customer Success';\nclass LoadCustomerCoupons extends LoaderLoadAction {\n    constructor(payload) {\n        super(CUSTOMER_COUPONS);\n        this.payload = payload;\n        this.type = LOAD_CUSTOMER_COUPONS;\n    }\n}\nclass LoadCustomerCouponsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CUSTOMER_COUPONS, payload);\n        this.payload = payload;\n        this.type = LOAD_CUSTOMER_COUPONS_FAIL;\n    }\n}\nclass LoadCustomerCouponsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CUSTOMER_COUPONS);\n        this.payload = payload;\n        this.type = LOAD_CUSTOMER_COUPONS_SUCCESS;\n    }\n}\nclass ResetLoadCustomerCoupons extends LoaderResetAction {\n    constructor() {\n        super(CUSTOMER_COUPONS);\n        this.type = RESET_LOAD_CUSTOMER_COUPONS;\n    }\n}\n// Subscribe coupon notification actions\nclass SubscribeCustomerCoupon extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n        this.payload = payload;\n        this.type = SUBSCRIBE_CUSTOMER_COUPON;\n    }\n}\nclass SubscribeCustomerCouponFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = SUBSCRIBE_CUSTOMER_COUPON_FAIL;\n    }\n}\nclass SubscribeCustomerCouponSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = SUBSCRIBE_CUSTOMER_COUPON_SUCCESS;\n    }\n}\nclass ResetSubscribeCustomerCouponProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n        this.type = RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS;\n    }\n}\nclass UnsubscribeCustomerCoupon extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n        this.payload = payload;\n        this.type = UNSUBSCRIBE_CUSTOMER_COUPON;\n    }\n}\nclass UnsubscribeCustomerCouponFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = UNSUBSCRIBE_CUSTOMER_COUPON_FAIL;\n    }\n}\nclass UnsubscribeCustomerCouponSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS;\n    }\n}\nclass ResetUnsubscribeCustomerCouponProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n        this.type = RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS;\n    }\n}\nclass ClaimCustomerCoupon extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID);\n        this.payload = payload;\n        this.type = CLAIM_CUSTOMER_COUPON;\n    }\n}\nclass ClaimCustomerCouponFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = CLAIM_CUSTOMER_COUPON_FAIL;\n    }\n}\nclass ClaimCustomerCouponSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = CLAIM_CUSTOMER_COUPON_SUCCESS;\n    }\n}\n\nconst LOAD_NOTIFICATION_PREFERENCES = '[User] Load Notification Preferences';\nconst LOAD_NOTIFICATION_PREFERENCES_FAIL = '[User] Load Notification Preferences Fail';\nconst LOAD_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Load Notification Preferences Success';\nconst UPDATE_NOTIFICATION_PREFERENCES = '[User] Update Notification Preferences';\nconst UPDATE_NOTIFICATION_PREFERENCES_FAIL = '[User] Update Notification Preferences Fail';\nconst UPDATE_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Update Notification Preferences Success';\nconst RESET_NOTIFICATION_PREFERENCES = '[User] Reset Notification Preferences';\nconst CLEAR_NOTIFICATION_PREFERENCES = '[User] Clear Notification Preferences';\nclass LoadNotificationPreferences extends LoaderLoadAction {\n    constructor(payload) {\n        super(NOTIFICATION_PREFERENCES);\n        this.payload = payload;\n        this.type = LOAD_NOTIFICATION_PREFERENCES;\n    }\n}\nclass LoadNotificationPreferencesFail extends LoaderFailAction {\n    constructor(payload) {\n        super(NOTIFICATION_PREFERENCES, payload);\n        this.payload = payload;\n        this.type = LOAD_NOTIFICATION_PREFERENCES_FAIL;\n    }\n}\nclass LoadNotificationPreferencesSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(NOTIFICATION_PREFERENCES);\n        this.payload = payload;\n        this.type = LOAD_NOTIFICATION_PREFERENCES_SUCCESS;\n    }\n}\nclass UpdateNotificationPreferences extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);\n        this.payload = payload;\n        this.type = UPDATE_NOTIFICATION_PREFERENCES;\n    }\n}\nclass UpdateNotificationPreferencesFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = UPDATE_NOTIFICATION_PREFERENCES_FAIL;\n    }\n}\nclass UpdateNotificationPreferencesSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);\n        this.payload = payload;\n        this.type = UPDATE_NOTIFICATION_PREFERENCES_SUCCESS;\n    }\n}\nclass ResetNotificationPreferences extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);\n        this.type = RESET_NOTIFICATION_PREFERENCES;\n    }\n}\nclass ClearNotificationPreferences extends LoaderResetAction {\n    constructor() {\n        super(NOTIFICATION_PREFERENCES);\n        this.type = CLEAR_NOTIFICATION_PREFERENCES;\n    }\n}\n\nconst LOAD_PRODUCT_INTERESTS = 'Load Product Interests';\nconst LOAD_PRODUCT_INTERESTS_FAIL = 'Load Product Interests Fail';\nconst LOAD_PRODUCT_INTERESTS_SUCCESS = 'Load Product Interests Success';\nconst REMOVE_PRODUCT_INTEREST = 'Remove Product Interest';\nconst REMOVE_PRODUCT_INTEREST_SUCCESS = 'Remove Product Interest Success';\nconst REMOVE_PRODUCT_INTEREST_FAIL = 'Remove Product Interest Fail';\nconst ADD_PRODUCT_INTEREST = 'Add Product Interest';\nconst ADD_PRODUCT_INTEREST_FAIL = 'Add Product Interest Fail';\nconst ADD_PRODUCT_INTEREST_SUCCESS = 'Add Product Interest Success';\nconst ADD_PRODUCT_INTEREST_RESET = 'Add Product Interest Reset';\nconst REMOVE_PRODUCT_INTEREST_RESET = 'Remove Product Interest Reset';\nconst CLEAR_PRODUCT_INTERESTS = 'Clear Product Interests';\nclass LoadProductInterests extends LoaderLoadAction {\n    constructor(payload) {\n        super(PRODUCT_INTERESTS);\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_INTERESTS;\n    }\n}\nclass LoadProductInterestsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(PRODUCT_INTERESTS, payload);\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_INTERESTS_FAIL;\n    }\n}\nclass LoadProductInterestsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(PRODUCT_INTERESTS);\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_INTERESTS_SUCCESS;\n    }\n}\nclass RemoveProductInterest extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);\n        this.payload = payload;\n        this.type = REMOVE_PRODUCT_INTEREST;\n    }\n}\nclass RemoveProductInterestSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);\n        this.payload = payload;\n        this.type = REMOVE_PRODUCT_INTEREST_SUCCESS;\n    }\n}\nclass RemoveProductInterestFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = REMOVE_PRODUCT_INTEREST_FAIL;\n    }\n}\nclass AddProductInterest extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);\n        this.payload = payload;\n        this.type = ADD_PRODUCT_INTEREST;\n    }\n}\nclass AddProductInterestSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);\n        this.payload = payload;\n        this.type = ADD_PRODUCT_INTEREST_SUCCESS;\n    }\n}\nclass AddProductInterestFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = ADD_PRODUCT_INTEREST_FAIL;\n    }\n}\nclass ResetAddInterestState extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);\n        this.type = ADD_PRODUCT_INTEREST_RESET;\n    }\n}\nclass ResetRemoveInterestState extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);\n        this.type = REMOVE_PRODUCT_INTEREST_RESET;\n    }\n}\nclass ClearProductInterests extends LoaderResetAction {\n    constructor() {\n        super(PRODUCT_INTERESTS);\n        this.type = CLEAR_PRODUCT_INTERESTS;\n    }\n}\n\nconst CREATE_ORDER_RETURN_REQUEST = '[User] Create Order Return Request';\nconst CREATE_ORDER_RETURN_REQUEST_FAIL = '[User] Create Order Return Request Fail';\nconst CREATE_ORDER_RETURN_REQUEST_SUCCESS = '[User] Create Order Return Request Success';\nconst LOAD_ORDER_RETURN_REQUEST = '[User] Load Order Return Request details';\nconst LOAD_ORDER_RETURN_REQUEST_FAIL = '[User] Load Order Return Request details Fail';\nconst LOAD_ORDER_RETURN_REQUEST_SUCCESS = '[User] Load Order Return Request details Success';\nconst CANCEL_ORDER_RETURN_REQUEST = '[User] Cancel Order Return Request';\nconst CANCEL_ORDER_RETURN_REQUEST_FAIL = '[User] Cancel Order Return Request Fail';\nconst CANCEL_ORDER_RETURN_REQUEST_SUCCESS = '[User] Cancel Order Return Request Success';\nconst LOAD_ORDER_RETURN_REQUEST_LIST = '[User] Load User Order Return Request List';\nconst LOAD_ORDER_RETURN_REQUEST_LIST_FAIL = '[User] Load User Order Return Request List Fail';\nconst LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS = '[User] Load User Order Return Request List Success';\nconst CLEAR_ORDER_RETURN_REQUEST = '[User] Clear Order Return Request Details';\nconst CLEAR_ORDER_RETURN_REQUEST_LIST = '[User] Clear Order Return Request List';\nconst RESET_CANCEL_RETURN_PROCESS = '[User] Reset Cancel Return Request Process';\nclass CreateOrderReturnRequest extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUEST_DETAILS);\n        this.payload = payload;\n        this.type = CREATE_ORDER_RETURN_REQUEST;\n    }\n}\nclass CreateOrderReturnRequestFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUEST_DETAILS, payload);\n        this.payload = payload;\n        this.type = CREATE_ORDER_RETURN_REQUEST_FAIL;\n    }\n}\nclass CreateOrderReturnRequestSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUEST_DETAILS);\n        this.payload = payload;\n        this.type = CREATE_ORDER_RETURN_REQUEST_SUCCESS;\n    }\n}\nclass LoadOrderReturnRequest extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUEST_DETAILS);\n        this.payload = payload;\n        this.type = LOAD_ORDER_RETURN_REQUEST;\n    }\n}\nclass LoadOrderReturnRequestFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUEST_DETAILS, payload);\n        this.payload = payload;\n        this.type = LOAD_ORDER_RETURN_REQUEST_FAIL;\n    }\n}\nclass LoadOrderReturnRequestSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUEST_DETAILS);\n        this.payload = payload;\n        this.type = LOAD_ORDER_RETURN_REQUEST_SUCCESS;\n    }\n}\nclass CancelOrderReturnRequest extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);\n        this.payload = payload;\n        this.type = CANCEL_ORDER_RETURN_REQUEST;\n    }\n}\nclass CancelOrderReturnRequestFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = CANCEL_ORDER_RETURN_REQUEST_FAIL;\n    }\n}\nclass CancelOrderReturnRequestSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);\n        this.type = CANCEL_ORDER_RETURN_REQUEST_SUCCESS;\n    }\n}\nclass LoadOrderReturnRequestList extends LoaderLoadAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUESTS);\n        this.payload = payload;\n        this.type = LOAD_ORDER_RETURN_REQUEST_LIST;\n    }\n}\nclass LoadOrderReturnRequestListFail extends LoaderFailAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUESTS, payload);\n        this.payload = payload;\n        this.type = LOAD_ORDER_RETURN_REQUEST_LIST_FAIL;\n    }\n}\nclass LoadOrderReturnRequestListSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(USER_RETURN_REQUESTS);\n        this.payload = payload;\n        this.type = LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS;\n    }\n}\nclass ClearOrderReturnRequest extends LoaderResetAction {\n    constructor() {\n        super(USER_RETURN_REQUEST_DETAILS);\n        this.type = CLEAR_ORDER_RETURN_REQUEST;\n    }\n}\nclass ClearOrderReturnRequestList extends LoaderResetAction {\n    constructor() {\n        super(USER_RETURN_REQUESTS);\n        this.type = CLEAR_ORDER_RETURN_REQUEST_LIST;\n    }\n}\nclass ResetCancelReturnProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);\n        this.type = RESET_CANCEL_RETURN_PROCESS;\n    }\n}\n\n\n\nvar userGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_BILLING_COUNTRIES: LOAD_BILLING_COUNTRIES,\n    LOAD_BILLING_COUNTRIES_FAIL: LOAD_BILLING_COUNTRIES_FAIL,\n    LOAD_BILLING_COUNTRIES_SUCCESS: LOAD_BILLING_COUNTRIES_SUCCESS,\n    LoadBillingCountries: LoadBillingCountries,\n    LoadBillingCountriesFail: LoadBillingCountriesFail,\n    LoadBillingCountriesSuccess: LoadBillingCountriesSuccess,\n    LOAD_CONSIGNMENT_TRACKING: LOAD_CONSIGNMENT_TRACKING,\n    LOAD_CONSIGNMENT_TRACKING_FAIL: LOAD_CONSIGNMENT_TRACKING_FAIL,\n    LOAD_CONSIGNMENT_TRACKING_SUCCESS: LOAD_CONSIGNMENT_TRACKING_SUCCESS,\n    CLEAR_CONSIGNMENT_TRACKING: CLEAR_CONSIGNMENT_TRACKING,\n    LoadConsignmentTracking: LoadConsignmentTracking,\n    LoadConsignmentTrackingFail: LoadConsignmentTrackingFail,\n    LoadConsignmentTrackingSuccess: LoadConsignmentTrackingSuccess,\n    ClearConsignmentTracking: ClearConsignmentTracking,\n    LOAD_DELIVERY_COUNTRIES: LOAD_DELIVERY_COUNTRIES,\n    LOAD_DELIVERY_COUNTRIES_FAIL: LOAD_DELIVERY_COUNTRIES_FAIL,\n    LOAD_DELIVERY_COUNTRIES_SUCCESS: LOAD_DELIVERY_COUNTRIES_SUCCESS,\n    LoadDeliveryCountries: LoadDeliveryCountries,\n    LoadDeliveryCountriesFail: LoadDeliveryCountriesFail,\n    LoadDeliveryCountriesSuccess: LoadDeliveryCountriesSuccess,\n    FORGOT_PASSWORD_EMAIL_REQUEST: FORGOT_PASSWORD_EMAIL_REQUEST,\n    FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS: FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS,\n    FORGOT_PASSWORD_EMAIL_REQUEST_FAIL: FORGOT_PASSWORD_EMAIL_REQUEST_FAIL,\n    ForgotPasswordEmailRequest: ForgotPasswordEmailRequest,\n    ForgotPasswordEmailRequestFail: ForgotPasswordEmailRequestFail,\n    ForgotPasswordEmailRequestSuccess: ForgotPasswordEmailRequestSuccess,\n    LOAD_ORDER_DETAILS: LOAD_ORDER_DETAILS,\n    LOAD_ORDER_DETAILS_FAIL: LOAD_ORDER_DETAILS_FAIL,\n    LOAD_ORDER_DETAILS_SUCCESS: LOAD_ORDER_DETAILS_SUCCESS,\n    CLEAR_ORDER_DETAILS: CLEAR_ORDER_DETAILS,\n    CANCEL_ORDER: CANCEL_ORDER,\n    CANCEL_ORDER_FAIL: CANCEL_ORDER_FAIL,\n    CANCEL_ORDER_SUCCESS: CANCEL_ORDER_SUCCESS,\n    RESET_CANCEL_ORDER_PROCESS: RESET_CANCEL_ORDER_PROCESS,\n    LoadOrderDetails: LoadOrderDetails,\n    LoadOrderDetailsFail: LoadOrderDetailsFail,\n    LoadOrderDetailsSuccess: LoadOrderDetailsSuccess,\n    ClearOrderDetails: ClearOrderDetails,\n    CancelOrder: CancelOrder,\n    CancelOrderFail: CancelOrderFail,\n    CancelOrderSuccess: CancelOrderSuccess,\n    ResetCancelOrderProcess: ResetCancelOrderProcess,\n    LOAD_USER_PAYMENT_METHODS: LOAD_USER_PAYMENT_METHODS,\n    LOAD_USER_PAYMENT_METHODS_FAIL: LOAD_USER_PAYMENT_METHODS_FAIL,\n    LOAD_USER_PAYMENT_METHODS_SUCCESS: LOAD_USER_PAYMENT_METHODS_SUCCESS,\n    SET_DEFAULT_USER_PAYMENT_METHOD: SET_DEFAULT_USER_PAYMENT_METHOD,\n    SET_DEFAULT_USER_PAYMENT_METHOD_FAIL: SET_DEFAULT_USER_PAYMENT_METHOD_FAIL,\n    SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS: SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS,\n    DELETE_USER_PAYMENT_METHOD: DELETE_USER_PAYMENT_METHOD,\n    DELETE_USER_PAYMENT_METHOD_FAIL: DELETE_USER_PAYMENT_METHOD_FAIL,\n    DELETE_USER_PAYMENT_METHOD_SUCCESS: DELETE_USER_PAYMENT_METHOD_SUCCESS,\n    LoadUserPaymentMethods: LoadUserPaymentMethods,\n    LoadUserPaymentMethodsFail: LoadUserPaymentMethodsFail,\n    LoadUserPaymentMethodsSuccess: LoadUserPaymentMethodsSuccess,\n    SetDefaultUserPaymentMethod: SetDefaultUserPaymentMethod,\n    SetDefaultUserPaymentMethodFail: SetDefaultUserPaymentMethodFail,\n    SetDefaultUserPaymentMethodSuccess: SetDefaultUserPaymentMethodSuccess,\n    DeleteUserPaymentMethod: DeleteUserPaymentMethod,\n    DeleteUserPaymentMethodFail: DeleteUserPaymentMethodFail,\n    DeleteUserPaymentMethodSuccess: DeleteUserPaymentMethodSuccess,\n    LOAD_REGIONS: LOAD_REGIONS,\n    LOAD_REGIONS_SUCCESS: LOAD_REGIONS_SUCCESS,\n    LOAD_REGIONS_FAIL: LOAD_REGIONS_FAIL,\n    CLEAR_REGIONS: CLEAR_REGIONS,\n    LoadRegions: LoadRegions,\n    LoadRegionsFail: LoadRegionsFail,\n    LoadRegionsSuccess: LoadRegionsSuccess,\n    ClearRegions: ClearRegions,\n    RESET_PASSWORD: RESET_PASSWORD,\n    RESET_PASSWORD_SUCCESS: RESET_PASSWORD_SUCCESS,\n    RESET_PASSWORD_FAIL: RESET_PASSWORD_FAIL,\n    ResetPassword: ResetPassword,\n    ResetPasswordFail: ResetPasswordFail,\n    ResetPasswordSuccess: ResetPasswordSuccess,\n    LOAD_TITLES: LOAD_TITLES,\n    LOAD_TITLES_FAIL: LOAD_TITLES_FAIL,\n    LOAD_TITLES_SUCCESS: LOAD_TITLES_SUCCESS,\n    LoadTitles: LoadTitles,\n    LoadTitlesFail: LoadTitlesFail,\n    LoadTitlesSuccess: LoadTitlesSuccess,\n    UPDATE_EMAIL: UPDATE_EMAIL,\n    UPDATE_EMAIL_ERROR: UPDATE_EMAIL_ERROR,\n    UPDATE_EMAIL_SUCCESS: UPDATE_EMAIL_SUCCESS,\n    RESET_EMAIL: RESET_EMAIL,\n    UpdateEmailAction: UpdateEmailAction,\n    UpdateEmailSuccessAction: UpdateEmailSuccessAction,\n    UpdateEmailErrorAction: UpdateEmailErrorAction,\n    ResetUpdateEmailAction: ResetUpdateEmailAction,\n    UPDATE_PASSWORD: UPDATE_PASSWORD,\n    UPDATE_PASSWORD_FAIL: UPDATE_PASSWORD_FAIL,\n    UPDATE_PASSWORD_SUCCESS: UPDATE_PASSWORD_SUCCESS,\n    UPDATE_PASSWORD_RESET: UPDATE_PASSWORD_RESET,\n    UpdatePassword: UpdatePassword,\n    UpdatePasswordFail: UpdatePasswordFail,\n    UpdatePasswordSuccess: UpdatePasswordSuccess,\n    UpdatePasswordReset: UpdatePasswordReset,\n    LOAD_USER_ADDRESSES: LOAD_USER_ADDRESSES,\n    LOAD_USER_ADDRESSES_FAIL: LOAD_USER_ADDRESSES_FAIL,\n    LOAD_USER_ADDRESSES_SUCCESS: LOAD_USER_ADDRESSES_SUCCESS,\n    ADD_USER_ADDRESS: ADD_USER_ADDRESS,\n    ADD_USER_ADDRESS_FAIL: ADD_USER_ADDRESS_FAIL,\n    ADD_USER_ADDRESS_SUCCESS: ADD_USER_ADDRESS_SUCCESS,\n    UPDATE_USER_ADDRESS: UPDATE_USER_ADDRESS,\n    UPDATE_USER_ADDRESS_FAIL: UPDATE_USER_ADDRESS_FAIL,\n    UPDATE_USER_ADDRESS_SUCCESS: UPDATE_USER_ADDRESS_SUCCESS,\n    DELETE_USER_ADDRESS: DELETE_USER_ADDRESS,\n    DELETE_USER_ADDRESS_FAIL: DELETE_USER_ADDRESS_FAIL,\n    DELETE_USER_ADDRESS_SUCCESS: DELETE_USER_ADDRESS_SUCCESS,\n    LoadUserAddresses: LoadUserAddresses,\n    LoadUserAddressesFail: LoadUserAddressesFail,\n    LoadUserAddressesSuccess: LoadUserAddressesSuccess,\n    AddUserAddress: AddUserAddress,\n    AddUserAddressFail: AddUserAddressFail,\n    AddUserAddressSuccess: AddUserAddressSuccess,\n    UpdateUserAddress: UpdateUserAddress,\n    UpdateUserAddressFail: UpdateUserAddressFail,\n    UpdateUserAddressSuccess: UpdateUserAddressSuccess,\n    DeleteUserAddress: DeleteUserAddress,\n    DeleteUserAddressFail: DeleteUserAddressFail,\n    DeleteUserAddressSuccess: DeleteUserAddressSuccess,\n    LOAD_USER_CONSENTS: LOAD_USER_CONSENTS,\n    LOAD_USER_CONSENTS_SUCCESS: LOAD_USER_CONSENTS_SUCCESS,\n    LOAD_USER_CONSENTS_FAIL: LOAD_USER_CONSENTS_FAIL,\n    RESET_LOAD_USER_CONSENTS: RESET_LOAD_USER_CONSENTS,\n    GIVE_USER_CONSENT: GIVE_USER_CONSENT,\n    GIVE_USER_CONSENT_FAIL: GIVE_USER_CONSENT_FAIL,\n    GIVE_USER_CONSENT_SUCCESS: GIVE_USER_CONSENT_SUCCESS,\n    RESET_GIVE_USER_CONSENT_PROCESS: RESET_GIVE_USER_CONSENT_PROCESS,\n    TRANSFER_ANONYMOUS_CONSENT: TRANSFER_ANONYMOUS_CONSENT,\n    WITHDRAW_USER_CONSENT: WITHDRAW_USER_CONSENT,\n    WITHDRAW_USER_CONSENT_FAIL: WITHDRAW_USER_CONSENT_FAIL,\n    WITHDRAW_USER_CONSENT_SUCCESS: WITHDRAW_USER_CONSENT_SUCCESS,\n    RESET_WITHDRAW_USER_CONSENT_PROCESS: RESET_WITHDRAW_USER_CONSENT_PROCESS,\n    LoadUserConsents: LoadUserConsents,\n    LoadUserConsentsFail: LoadUserConsentsFail,\n    LoadUserConsentsSuccess: LoadUserConsentsSuccess,\n    ResetLoadUserConsents: ResetLoadUserConsents,\n    GiveUserConsent: GiveUserConsent,\n    GiveUserConsentFail: GiveUserConsentFail,\n    GiveUserConsentSuccess: GiveUserConsentSuccess,\n    ResetGiveUserConsentProcess: ResetGiveUserConsentProcess,\n    TransferAnonymousConsent: TransferAnonymousConsent,\n    WithdrawUserConsent: WithdrawUserConsent,\n    WithdrawUserConsentFail: WithdrawUserConsentFail,\n    WithdrawUserConsentSuccess: WithdrawUserConsentSuccess,\n    ResetWithdrawUserConsentProcess: ResetWithdrawUserConsentProcess,\n    LOAD_USER_DETAILS: LOAD_USER_DETAILS,\n    LOAD_USER_DETAILS_FAIL: LOAD_USER_DETAILS_FAIL,\n    LOAD_USER_DETAILS_SUCCESS: LOAD_USER_DETAILS_SUCCESS,\n    UPDATE_USER_DETAILS: UPDATE_USER_DETAILS,\n    UPDATE_USER_DETAILS_FAIL: UPDATE_USER_DETAILS_FAIL,\n    UPDATE_USER_DETAILS_SUCCESS: UPDATE_USER_DETAILS_SUCCESS,\n    RESET_USER_DETAILS: RESET_USER_DETAILS,\n    LoadUserDetails: LoadUserDetails,\n    LoadUserDetailsFail: LoadUserDetailsFail,\n    LoadUserDetailsSuccess: LoadUserDetailsSuccess,\n    UpdateUserDetails: UpdateUserDetails,\n    UpdateUserDetailsFail: UpdateUserDetailsFail,\n    UpdateUserDetailsSuccess: UpdateUserDetailsSuccess,\n    ResetUpdateUserDetails: ResetUpdateUserDetails,\n    CLEAR_USER_MISCS_DATA: CLEAR_USER_MISCS_DATA,\n    ClearUserMiscsData: ClearUserMiscsData,\n    LOAD_USER_ORDERS: LOAD_USER_ORDERS,\n    LOAD_USER_ORDERS_FAIL: LOAD_USER_ORDERS_FAIL,\n    LOAD_USER_ORDERS_SUCCESS: LOAD_USER_ORDERS_SUCCESS,\n    CLEAR_USER_ORDERS: CLEAR_USER_ORDERS,\n    LoadUserOrders: LoadUserOrders,\n    LoadUserOrdersFail: LoadUserOrdersFail,\n    LoadUserOrdersSuccess: LoadUserOrdersSuccess,\n    ClearUserOrders: ClearUserOrders,\n    REGISTER_USER: REGISTER_USER,\n    REGISTER_USER_FAIL: REGISTER_USER_FAIL,\n    REGISTER_USER_SUCCESS: REGISTER_USER_SUCCESS,\n    RESET_REGISTER_USER_PROCESS: RESET_REGISTER_USER_PROCESS,\n    REGISTER_GUEST: REGISTER_GUEST,\n    REGISTER_GUEST_FAIL: REGISTER_GUEST_FAIL,\n    REGISTER_GUEST_SUCCESS: REGISTER_GUEST_SUCCESS,\n    REMOVE_USER: REMOVE_USER,\n    REMOVE_USER_FAIL: REMOVE_USER_FAIL,\n    REMOVE_USER_SUCCESS: REMOVE_USER_SUCCESS,\n    REMOVE_USER_RESET: REMOVE_USER_RESET,\n    RegisterUser: RegisterUser,\n    RegisterUserFail: RegisterUserFail,\n    RegisterUserSuccess: RegisterUserSuccess,\n    ResetRegisterUserProcess: ResetRegisterUserProcess,\n    RegisterGuest: RegisterGuest,\n    RegisterGuestFail: RegisterGuestFail,\n    RegisterGuestSuccess: RegisterGuestSuccess,\n    RemoveUser: RemoveUser,\n    RemoveUserFail: RemoveUserFail,\n    RemoveUserSuccess: RemoveUserSuccess,\n    RemoveUserReset: RemoveUserReset,\n    LOAD_CUSTOMER_COUPONS: LOAD_CUSTOMER_COUPONS,\n    LOAD_CUSTOMER_COUPONS_FAIL: LOAD_CUSTOMER_COUPONS_FAIL,\n    LOAD_CUSTOMER_COUPONS_SUCCESS: LOAD_CUSTOMER_COUPONS_SUCCESS,\n    RESET_LOAD_CUSTOMER_COUPONS: RESET_LOAD_CUSTOMER_COUPONS,\n    SUBSCRIBE_CUSTOMER_COUPON: SUBSCRIBE_CUSTOMER_COUPON,\n    SUBSCRIBE_CUSTOMER_COUPON_FAIL: SUBSCRIBE_CUSTOMER_COUPON_FAIL,\n    SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: SUBSCRIBE_CUSTOMER_COUPON_SUCCESS,\n    RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS,\n    UNSUBSCRIBE_CUSTOMER_COUPON: UNSUBSCRIBE_CUSTOMER_COUPON,\n    UNSUBSCRIBE_CUSTOMER_COUPON_FAIL: UNSUBSCRIBE_CUSTOMER_COUPON_FAIL,\n    UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS,\n    RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS,\n    CLAIM_CUSTOMER_COUPON: CLAIM_CUSTOMER_COUPON,\n    CLAIM_CUSTOMER_COUPON_FAIL: CLAIM_CUSTOMER_COUPON_FAIL,\n    CLAIM_CUSTOMER_COUPON_SUCCESS: CLAIM_CUSTOMER_COUPON_SUCCESS,\n    LoadCustomerCoupons: LoadCustomerCoupons,\n    LoadCustomerCouponsFail: LoadCustomerCouponsFail,\n    LoadCustomerCouponsSuccess: LoadCustomerCouponsSuccess,\n    ResetLoadCustomerCoupons: ResetLoadCustomerCoupons,\n    SubscribeCustomerCoupon: SubscribeCustomerCoupon,\n    SubscribeCustomerCouponFail: SubscribeCustomerCouponFail,\n    SubscribeCustomerCouponSuccess: SubscribeCustomerCouponSuccess,\n    ResetSubscribeCustomerCouponProcess: ResetSubscribeCustomerCouponProcess,\n    UnsubscribeCustomerCoupon: UnsubscribeCustomerCoupon,\n    UnsubscribeCustomerCouponFail: UnsubscribeCustomerCouponFail,\n    UnsubscribeCustomerCouponSuccess: UnsubscribeCustomerCouponSuccess,\n    ResetUnsubscribeCustomerCouponProcess: ResetUnsubscribeCustomerCouponProcess,\n    ClaimCustomerCoupon: ClaimCustomerCoupon,\n    ClaimCustomerCouponFail: ClaimCustomerCouponFail,\n    ClaimCustomerCouponSuccess: ClaimCustomerCouponSuccess,\n    LOAD_NOTIFICATION_PREFERENCES: LOAD_NOTIFICATION_PREFERENCES,\n    LOAD_NOTIFICATION_PREFERENCES_FAIL: LOAD_NOTIFICATION_PREFERENCES_FAIL,\n    LOAD_NOTIFICATION_PREFERENCES_SUCCESS: LOAD_NOTIFICATION_PREFERENCES_SUCCESS,\n    UPDATE_NOTIFICATION_PREFERENCES: UPDATE_NOTIFICATION_PREFERENCES,\n    UPDATE_NOTIFICATION_PREFERENCES_FAIL: UPDATE_NOTIFICATION_PREFERENCES_FAIL,\n    UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: UPDATE_NOTIFICATION_PREFERENCES_SUCCESS,\n    RESET_NOTIFICATION_PREFERENCES: RESET_NOTIFICATION_PREFERENCES,\n    CLEAR_NOTIFICATION_PREFERENCES: CLEAR_NOTIFICATION_PREFERENCES,\n    LoadNotificationPreferences: LoadNotificationPreferences,\n    LoadNotificationPreferencesFail: LoadNotificationPreferencesFail,\n    LoadNotificationPreferencesSuccess: LoadNotificationPreferencesSuccess,\n    UpdateNotificationPreferences: UpdateNotificationPreferences,\n    UpdateNotificationPreferencesFail: UpdateNotificationPreferencesFail,\n    UpdateNotificationPreferencesSuccess: UpdateNotificationPreferencesSuccess,\n    ResetNotificationPreferences: ResetNotificationPreferences,\n    ClearNotificationPreferences: ClearNotificationPreferences,\n    LOAD_PRODUCT_INTERESTS: LOAD_PRODUCT_INTERESTS,\n    LOAD_PRODUCT_INTERESTS_FAIL: LOAD_PRODUCT_INTERESTS_FAIL,\n    LOAD_PRODUCT_INTERESTS_SUCCESS: LOAD_PRODUCT_INTERESTS_SUCCESS,\n    REMOVE_PRODUCT_INTEREST: REMOVE_PRODUCT_INTEREST,\n    REMOVE_PRODUCT_INTEREST_SUCCESS: REMOVE_PRODUCT_INTEREST_SUCCESS,\n    REMOVE_PRODUCT_INTEREST_FAIL: REMOVE_PRODUCT_INTEREST_FAIL,\n    ADD_PRODUCT_INTEREST: ADD_PRODUCT_INTEREST,\n    ADD_PRODUCT_INTEREST_FAIL: ADD_PRODUCT_INTEREST_FAIL,\n    ADD_PRODUCT_INTEREST_SUCCESS: ADD_PRODUCT_INTEREST_SUCCESS,\n    ADD_PRODUCT_INTEREST_RESET: ADD_PRODUCT_INTEREST_RESET,\n    REMOVE_PRODUCT_INTEREST_RESET: REMOVE_PRODUCT_INTEREST_RESET,\n    CLEAR_PRODUCT_INTERESTS: CLEAR_PRODUCT_INTERESTS,\n    LoadProductInterests: LoadProductInterests,\n    LoadProductInterestsFail: LoadProductInterestsFail,\n    LoadProductInterestsSuccess: LoadProductInterestsSuccess,\n    RemoveProductInterest: RemoveProductInterest,\n    RemoveProductInterestSuccess: RemoveProductInterestSuccess,\n    RemoveProductInterestFail: RemoveProductInterestFail,\n    AddProductInterest: AddProductInterest,\n    AddProductInterestSuccess: AddProductInterestSuccess,\n    AddProductInterestFail: AddProductInterestFail,\n    ResetAddInterestState: ResetAddInterestState,\n    ResetRemoveInterestState: ResetRemoveInterestState,\n    ClearProductInterests: ClearProductInterests,\n    CREATE_ORDER_RETURN_REQUEST: CREATE_ORDER_RETURN_REQUEST,\n    CREATE_ORDER_RETURN_REQUEST_FAIL: CREATE_ORDER_RETURN_REQUEST_FAIL,\n    CREATE_ORDER_RETURN_REQUEST_SUCCESS: CREATE_ORDER_RETURN_REQUEST_SUCCESS,\n    LOAD_ORDER_RETURN_REQUEST: LOAD_ORDER_RETURN_REQUEST,\n    LOAD_ORDER_RETURN_REQUEST_FAIL: LOAD_ORDER_RETURN_REQUEST_FAIL,\n    LOAD_ORDER_RETURN_REQUEST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_SUCCESS,\n    CANCEL_ORDER_RETURN_REQUEST: CANCEL_ORDER_RETURN_REQUEST,\n    CANCEL_ORDER_RETURN_REQUEST_FAIL: CANCEL_ORDER_RETURN_REQUEST_FAIL,\n    CANCEL_ORDER_RETURN_REQUEST_SUCCESS: CANCEL_ORDER_RETURN_REQUEST_SUCCESS,\n    LOAD_ORDER_RETURN_REQUEST_LIST: LOAD_ORDER_RETURN_REQUEST_LIST,\n    LOAD_ORDER_RETURN_REQUEST_LIST_FAIL: LOAD_ORDER_RETURN_REQUEST_LIST_FAIL,\n    LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS,\n    CLEAR_ORDER_RETURN_REQUEST: CLEAR_ORDER_RETURN_REQUEST,\n    CLEAR_ORDER_RETURN_REQUEST_LIST: CLEAR_ORDER_RETURN_REQUEST_LIST,\n    RESET_CANCEL_RETURN_PROCESS: RESET_CANCEL_RETURN_PROCESS,\n    CreateOrderReturnRequest: CreateOrderReturnRequest,\n    CreateOrderReturnRequestFail: CreateOrderReturnRequestFail,\n    CreateOrderReturnRequestSuccess: CreateOrderReturnRequestSuccess,\n    LoadOrderReturnRequest: LoadOrderReturnRequest,\n    LoadOrderReturnRequestFail: LoadOrderReturnRequestFail,\n    LoadOrderReturnRequestSuccess: LoadOrderReturnRequestSuccess,\n    CancelOrderReturnRequest: CancelOrderReturnRequest,\n    CancelOrderReturnRequestFail: CancelOrderReturnRequestFail,\n    CancelOrderReturnRequestSuccess: CancelOrderReturnRequestSuccess,\n    LoadOrderReturnRequestList: LoadOrderReturnRequestList,\n    LoadOrderReturnRequestListFail: LoadOrderReturnRequestListFail,\n    LoadOrderReturnRequestListSuccess: LoadOrderReturnRequestListSuccess,\n    ClearOrderReturnRequest: ClearOrderReturnRequest,\n    ClearOrderReturnRequestList: ClearOrderReturnRequestList,\n    ResetCancelReturnProcess: ResetCancelReturnProcess\n});\n\nconst getUserState = createFeatureSelector(USER_FEATURE);\n\nconst ɵ0$b = (state) => state.billingCountries;\nconst getBillingCountriesState = createSelector(getUserState, ɵ0$b);\nconst ɵ1$7 = (state) => state.entities;\nconst getBillingCountriesEntites = createSelector(getBillingCountriesState, ɵ1$7);\nconst ɵ2$3 = entites => Object.keys(entites).map(isocode => entites[isocode]);\nconst getAllBillingCountries = createSelector(getBillingCountriesEntites, ɵ2$3);\n\nconst ɵ0$c = (state) => state.consignmentTracking;\nconst getConsignmentTrackingState = createSelector(getUserState, ɵ0$c);\nconst ɵ1$8 = (state) => state.tracking;\nconst getConsignmentTracking = createSelector(getConsignmentTrackingState, ɵ1$8);\n\nconst ɵ0$d = (state) => state.countries;\nconst getDeliveryCountriesState = createSelector(getUserState, ɵ0$d);\nconst ɵ1$9 = (state) => state.entities;\nconst getDeliveryCountriesEntites = createSelector(getDeliveryCountriesState, ɵ1$9);\nconst ɵ2$4 = entites => Object.keys(entites).map(isocode => entites[isocode]);\nconst getAllDeliveryCountries = createSelector(getDeliveryCountriesEntites, ɵ2$4);\nconst countrySelectorFactory = (isocode) => createSelector(getDeliveryCountriesEntites, entities => (Object.keys(entities).length !== 0 ? entities[isocode] : null));\n\nconst ɵ0$e = (state) => state.order;\nconst getOrderState = createSelector(getUserState, ɵ0$e);\nconst ɵ1$a = (state) => loaderValueSelector(state);\nconst getOrderDetails = createSelector(getOrderState, ɵ1$a);\n\nconst ɵ0$f = (state) => state.orderReturn;\nconst getOrderReturnRequestState = createSelector(getUserState, ɵ0$f);\nconst ɵ1$b = (state) => loaderValueSelector(state);\nconst getOrderReturnRequest = createSelector(getOrderReturnRequestState, ɵ1$b);\nconst ɵ2$5 = (state) => loaderLoadingSelector(state);\nconst getOrderReturnRequestLoading = createSelector(getOrderReturnRequestState, ɵ2$5);\nconst ɵ3$3 = (state) => loaderSuccessSelector(state) &&\n    !loaderLoadingSelector(state);\nconst getOrderReturnRequestSuccess = createSelector(getOrderReturnRequestState, ɵ3$3);\nconst ɵ4 = (state) => state.orderReturnList;\nconst getOrderReturnRequestListState = createSelector(getUserState, ɵ4);\nconst ɵ5 = (state) => loaderValueSelector(state);\nconst getOrderReturnRequestList = createSelector(getOrderReturnRequestListState, ɵ5);\n\nconst ɵ0$g = (state) => state.payments;\nconst getPaymentMethodsState = createSelector(getUserState, ɵ0$g);\nconst ɵ1$c = (state) => loaderValueSelector(state);\nconst getPaymentMethods = createSelector(getPaymentMethodsState, ɵ1$c);\nconst ɵ2$6 = (state) => loaderLoadingSelector(state);\nconst getPaymentMethodsLoading = createSelector(getPaymentMethodsState, ɵ2$6);\nconst ɵ3$4 = (state) => loaderSuccessSelector(state) &&\n    !loaderLoadingSelector(state);\nconst getPaymentMethodsLoadedSuccess = createSelector(getPaymentMethodsState, ɵ3$4);\n\nconst ɵ0$h = (state) => state.regions;\nconst getRegionsLoaderState = createSelector(getUserState, ɵ0$h);\nconst ɵ1$d = (state) => {\n    return loaderValueSelector(state).entities;\n};\nconst getAllRegions = createSelector(getRegionsLoaderState, ɵ1$d);\nconst ɵ2$7 = (state) => ({\n    loaded: loaderSuccessSelector(state),\n    loading: loaderLoadingSelector(state),\n    regions: loaderValueSelector(state).entities,\n    country: loaderValueSelector(state).country,\n});\nconst getRegionsDataAndLoading = createSelector(getRegionsLoaderState, ɵ2$7);\nconst ɵ3$5 = (state) => loaderValueSelector(state).country;\nconst getRegionsCountry = createSelector(getRegionsLoaderState, ɵ3$5);\nconst ɵ4$1 = (state) => loaderLoadingSelector(state);\nconst getRegionsLoading = createSelector(getRegionsLoaderState, ɵ4$1);\nconst ɵ5$1 = (state) => loaderSuccessSelector(state);\nconst getRegionsLoaded = createSelector(getRegionsLoaderState, ɵ5$1);\n\nconst ɵ0$i = (state) => state.resetPassword;\nconst getResetPassword = createSelector(getUserState, ɵ0$i);\n\nconst ɵ0$j = (state) => state.titles;\nconst getTitlesState = createSelector(getUserState, ɵ0$j);\nconst ɵ1$e = (state) => state.entities;\nconst getTitlesEntites = createSelector(getTitlesState, ɵ1$e);\nconst ɵ2$8 = entites => Object.keys(entites).map(code => entites[code]);\nconst getAllTitles = createSelector(getTitlesEntites, ɵ2$8);\nconst titleSelectorFactory = (code) => createSelector(getTitlesEntites, entities => (Object.keys(entities).length !== 0 ? entities[code] : null));\n\nconst ɵ0$k = (state) => state.addresses;\nconst getAddressesLoaderState = createSelector(getUserState, ɵ0$k);\nconst ɵ1$f = (state) => loaderValueSelector(state);\nconst getAddresses = createSelector(getAddressesLoaderState, ɵ1$f);\nconst ɵ2$9 = (state) => loaderLoadingSelector(state);\nconst getAddressesLoading = createSelector(getAddressesLoaderState, ɵ2$9);\nconst ɵ3$6 = (state) => loaderSuccessSelector(state) &&\n    !loaderLoadingSelector(state);\nconst getAddressesLoadedSuccess = createSelector(getAddressesLoaderState, ɵ3$6);\n\nconst ɵ0$l = (state) => state.consents;\nconst getConsentsState = createSelector(getUserState, ɵ0$l);\nconst getConsentsValue = createSelector(getConsentsState, loaderValueSelector);\nconst getConsentByTemplateId = (templateId) => createSelector(getConsentsValue, templates => templates.find(template => template.id === templateId));\nconst getConsentsLoading = createSelector(getConsentsState, loaderLoadingSelector);\nconst getConsentsSuccess = createSelector(getConsentsState, loaderSuccessSelector);\nconst getConsentsError = createSelector(getConsentsState, loaderErrorSelector);\n\nconst ɵ0$m = (state) => state.account;\nconst getDetailsState = createSelector(getUserState, ɵ0$m);\nconst ɵ1$g = (state) => state.details;\nconst getDetails = createSelector(getDetailsState, ɵ1$g);\n\nconst ɵ0$n = (state) => state.orders;\nconst getOrdersState = createSelector(getUserState, ɵ0$n);\nconst ɵ1$h = (state) => loaderSuccessSelector(state);\nconst getOrdersLoaded = createSelector(getOrdersState, ɵ1$h);\nconst ɵ2$a = (state) => loaderValueSelector(state);\nconst getOrders = createSelector(getOrdersState, ɵ2$a);\n\nconst ɵ0$o = (state) => state.customerCoupons;\nconst getCustomerCouponsState = createSelector(getUserState, ɵ0$o);\nconst ɵ1$i = (state) => loaderSuccessSelector(state);\nconst getCustomerCouponsLoaded = createSelector(getCustomerCouponsState, ɵ1$i);\nconst ɵ2$b = (state) => loaderLoadingSelector(state);\nconst getCustomerCouponsLoading = createSelector(getCustomerCouponsState, ɵ2$b);\nconst ɵ3$7 = (state) => loaderValueSelector(state);\nconst getCustomerCoupons = createSelector(getCustomerCouponsState, ɵ3$7);\n\nconst ɵ0$p = (state) => state.notificationPreferences;\nconst getPreferencesLoaderState = createSelector(getUserState, ɵ0$p);\nconst ɵ1$j = (state) => loaderValueSelector(state);\nconst getPreferences = createSelector(getPreferencesLoaderState, ɵ1$j);\nconst ɵ2$c = (state) => loaderValueSelector(state).filter(p => p.enabled);\nconst getEnabledPreferences = createSelector(getPreferencesLoaderState, ɵ2$c);\nconst ɵ3$8 = (state) => loaderLoadingSelector(state);\nconst getPreferencesLoading = createSelector(getPreferencesLoaderState, ɵ3$8);\n\nconst ɵ0$q = (state) => state.productInterests;\nconst getInterestsState = createSelector(getUserState, ɵ0$q);\nconst ɵ1$k = (state) => loaderValueSelector(state);\nconst getInterests = createSelector(getInterestsState, ɵ1$k);\nconst ɵ2$d = (state) => loaderLoadingSelector(state);\nconst getInterestsLoading = createSelector(getInterestsState, ɵ2$d);\n\n\n\nvar usersGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getBillingCountriesState: getBillingCountriesState,\n    getBillingCountriesEntites: getBillingCountriesEntites,\n    getAllBillingCountries: getAllBillingCountries,\n    ɵ0: ɵ0$b,\n    ɵ1: ɵ1$7,\n    ɵ2: ɵ2$3,\n    getConsignmentTrackingState: getConsignmentTrackingState,\n    getConsignmentTracking: getConsignmentTracking,\n    getDeliveryCountriesState: getDeliveryCountriesState,\n    getDeliveryCountriesEntites: getDeliveryCountriesEntites,\n    getAllDeliveryCountries: getAllDeliveryCountries,\n    countrySelectorFactory: countrySelectorFactory,\n    getUserState: getUserState,\n    getOrderState: getOrderState,\n    getOrderDetails: getOrderDetails,\n    getOrderReturnRequestState: getOrderReturnRequestState,\n    getOrderReturnRequest: getOrderReturnRequest,\n    getOrderReturnRequestLoading: getOrderReturnRequestLoading,\n    getOrderReturnRequestSuccess: getOrderReturnRequestSuccess,\n    getOrderReturnRequestListState: getOrderReturnRequestListState,\n    getOrderReturnRequestList: getOrderReturnRequestList,\n    ɵ3: ɵ3$3,\n    ɵ4: ɵ4,\n    ɵ5: ɵ5,\n    getPaymentMethodsState: getPaymentMethodsState,\n    getPaymentMethods: getPaymentMethods,\n    getPaymentMethodsLoading: getPaymentMethodsLoading,\n    getPaymentMethodsLoadedSuccess: getPaymentMethodsLoadedSuccess,\n    getRegionsLoaderState: getRegionsLoaderState,\n    getAllRegions: getAllRegions,\n    getRegionsDataAndLoading: getRegionsDataAndLoading,\n    getRegionsCountry: getRegionsCountry,\n    getRegionsLoading: getRegionsLoading,\n    getRegionsLoaded: getRegionsLoaded,\n    getResetPassword: getResetPassword,\n    getTitlesState: getTitlesState,\n    getTitlesEntites: getTitlesEntites,\n    getAllTitles: getAllTitles,\n    titleSelectorFactory: titleSelectorFactory,\n    getAddressesLoaderState: getAddressesLoaderState,\n    getAddresses: getAddresses,\n    getAddressesLoading: getAddressesLoading,\n    getAddressesLoadedSuccess: getAddressesLoadedSuccess,\n    getConsentsState: getConsentsState,\n    getConsentsValue: getConsentsValue,\n    getConsentByTemplateId: getConsentByTemplateId,\n    getConsentsLoading: getConsentsLoading,\n    getConsentsSuccess: getConsentsSuccess,\n    getConsentsError: getConsentsError,\n    getDetailsState: getDetailsState,\n    getDetails: getDetails,\n    getOrdersState: getOrdersState,\n    getOrdersLoaded: getOrdersLoaded,\n    getOrders: getOrders,\n    getCustomerCouponsState: getCustomerCouponsState,\n    getCustomerCouponsLoaded: getCustomerCouponsLoaded,\n    getCustomerCouponsLoading: getCustomerCouponsLoading,\n    getCustomerCoupons: getCustomerCoupons,\n    getPreferencesLoaderState: getPreferencesLoaderState,\n    getPreferences: getPreferences,\n    getEnabledPreferences: getEnabledPreferences,\n    getPreferencesLoading: getPreferencesLoading,\n    getInterestsState: getInterestsState,\n    getInterests: getInterests,\n    getInterestsLoading: getInterestsLoading\n});\n\nlet UserConsentService = class UserConsentService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Retrieves all consents.\n     */\n    loadConsents() {\n        this.withUserId(userId => this.store.dispatch(new LoadUserConsents(userId)));\n    }\n    /**\n     * Returns all consent templates. If `loadIfMissing` parameter is set to `true`, the method triggers the load if consent templates.\n     * @param loadIfMissing is set to `true`, the method will load templates if those are not already present. The default value is `false`.\n     */\n    getConsents(loadIfMissing = false) {\n        return iif(() => loadIfMissing, this.store.pipe(select(getConsentsValue), withLatestFrom(this.getConsentsResultLoading(), this.getConsentsResultSuccess()), filter(([_templates, loading, _success]) => !loading), tap(([templates, _loading, success]) => {\n            if (!templates || templates.length === 0) {\n                // avoid infite loop - if we've already attempted to load templates and we got an empty array as the response\n                if (!success) {\n                    this.loadConsents();\n                }\n            }\n        }), filter(([templates, _loading]) => Boolean(templates)), map(([templates, _loading]) => templates)), this.store.pipe(select(getConsentsValue)));\n    }\n    /**\n     * Returns the consents loading flag\n     */\n    getConsentsResultLoading() {\n        return this.store.pipe(select(getConsentsLoading));\n    }\n    /**\n     * Returns the consents success flag\n     */\n    getConsentsResultSuccess() {\n        return this.store.pipe(select(getConsentsSuccess));\n    }\n    /**\n     * Returns the consents error flag\n     */\n    getConsentsResultError() {\n        return this.store.pipe(select(getConsentsError));\n    }\n    /**\n     * Resets the processing state for consent retrieval\n     */\n    resetConsentsProcessState() {\n        this.store.dispatch(new ResetLoadUserConsents());\n    }\n    /**\n     * Returns the registered consent for the given template ID.\n     *\n     * As a side-effect, the method will call `getConsents(true)` to load the templates if those are not present.\n     *\n     * @param templateId a template ID by which to filter the registered templates.\n     */\n    getConsent(templateId) {\n        return this.authService.isUserLoggedIn().pipe(filter(Boolean), tap(_ => this.getConsents(true)), switchMap(_ => this.store.pipe(select(getConsentByTemplateId(templateId)))), filter(template => Boolean(template)), map(template => template.currentConsent));\n    }\n    /**\n     * Returns `true` if the consent is truthy and if `consentWithdrawnDate` doesn't exist.\n     * Otherwise, `false` is returned.\n     *\n     * @param consent to check\n     */\n    isConsentGiven(consent) {\n        return (Boolean(consent) &&\n            Boolean(consent.consentGivenDate) &&\n            !Boolean(consent.consentWithdrawnDate));\n    }\n    /**\n     * Returns `true` if the consent is either falsy or if `consentWithdrawnDate` is present.\n     * Otherwise, `false` is returned.\n     *\n     * @param consent to check\n     */\n    isConsentWithdrawn(consent) {\n        if (Boolean(consent)) {\n            return Boolean(consent.consentWithdrawnDate);\n        }\n        return true;\n    }\n    /**\n     * Give consent for specified consent template ID and version.\n     * @param consentTemplateId a template ID for which to give a consent\n     * @param consentTemplateVersion a template version for which to give a consent\n     */\n    giveConsent(consentTemplateId, consentTemplateVersion) {\n        this.withUserId(userId => this.store.dispatch(new GiveUserConsent({\n            userId,\n            consentTemplateId,\n            consentTemplateVersion,\n        })));\n    }\n    /**\n     * Returns the give consent process loading flag\n     */\n    getGiveConsentResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(GIVE_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the give consent process success flag\n     */\n    getGiveConsentResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(GIVE_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the give consent process error flag\n     */\n    getGiveConsentResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(GIVE_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Resents the give consent process flags\n     */\n    resetGiveConsentProcessState() {\n        return this.store.dispatch(new ResetGiveUserConsentProcess());\n    }\n    /**\n     * Withdraw consent for the given `consentCode`\n     * @param consentCode for which to withdraw the consent\n     */\n    withdrawConsent(consentCode) {\n        this.withUserId(userId => this.store.dispatch(new WithdrawUserConsent({\n            userId,\n            consentCode,\n        })));\n    }\n    /**\n     * Returns the withdraw consent process loading flag\n     */\n    getWithdrawConsentResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(WITHDRAW_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the withdraw consent process success flag\n     */\n    getWithdrawConsentResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(WITHDRAW_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the withdraw consent process error flag\n     */\n    getWithdrawConsentResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(WITHDRAW_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Resets the process flags for withdraw consent\n     */\n    resetWithdrawConsentProcessState() {\n        return this.store.dispatch(new ResetWithdrawUserConsentProcess());\n    }\n    /**\n     * Filters the provided `templateList`' templates by hiding the template IDs specified in `hideTemplateIds`.\n     * If the `hideTemplateIds` is empty, the provided `templateList` is returned.\n     *\n     * @param templateList a list of consent templates to filter\n     * @param hideTemplateIds template IDs to hide\n     */\n    filterConsentTemplates(templateList, hideTemplateIds = []) {\n        if (hideTemplateIds.length === 0) {\n            return templateList;\n        }\n        const updatedTemplateList = [];\n        for (const template of templateList) {\n            const show = !hideTemplateIds.includes(template.id);\n            if (show) {\n                updatedTemplateList.push(template);\n            }\n        }\n        return updatedTemplateList;\n    }\n    /**\n     * Utility method to distinquish pre / post 1.3.0 in a convenient way.\n     *\n     */\n    withUserId(callback) {\n        if (this.authService) {\n            this.authService\n                .getOccUserId()\n                .pipe(take(1))\n                .subscribe(userId => callback(userId));\n        }\n        else {\n            // TODO(issue:#5628) Deprecated since 1.3.0\n            callback(OCC_USER_ID_CURRENT);\n        }\n    }\n};\nUserConsentService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nUserConsentService.ɵprov = ɵɵdefineInjectable({ factory: function UserConsentService_Factory() { return new UserConsentService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserConsentService, providedIn: \"root\" });\nUserConsentService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserConsentService);\n\nlet AnonymousConsentTemplatesConnector = class AnonymousConsentTemplatesConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    loadAnonymousConsentTemplates() {\n        return this.adapter.loadAnonymousConsentTemplates();\n    }\n};\nAnonymousConsentTemplatesConnector.ctorParameters = () => [\n    { type: AnonymousConsentTemplatesAdapter }\n];\nAnonymousConsentTemplatesConnector.ɵprov = ɵɵdefineInjectable({ factory: function AnonymousConsentTemplatesConnector_Factory() { return new AnonymousConsentTemplatesConnector(ɵɵinject(AnonymousConsentTemplatesAdapter)); }, token: AnonymousConsentTemplatesConnector, providedIn: \"root\" });\nAnonymousConsentTemplatesConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AnonymousConsentTemplatesConnector);\n\nlet AnonymousConsentsEffects = class AnonymousConsentsEffects {\n    constructor(actions$, anonymousConsentTemplatesConnector, authService, anonymousConsentsConfig, anonymousConsentService, userConsentService) {\n        this.actions$ = actions$;\n        this.anonymousConsentTemplatesConnector = anonymousConsentTemplatesConnector;\n        this.authService = authService;\n        this.anonymousConsentsConfig = anonymousConsentsConfig;\n        this.anonymousConsentService = anonymousConsentService;\n        this.userConsentService = userConsentService;\n        this.loadAnonymousConsentTemplates$ = this.actions$.pipe(ofType(LOAD_ANONYMOUS_CONSENT_TEMPLATES), concatMap(_ => this.anonymousConsentTemplatesConnector\n            .loadAnonymousConsentTemplates()\n            .pipe(withLatestFrom(this.anonymousConsentService.getTemplates()), mergeMap(([newConsentTemplates, currentConsentTemplates]) => {\n            let updated = false;\n            if (Boolean(currentConsentTemplates) &&\n                currentConsentTemplates.length !== 0) {\n                updated = this.anonymousConsentService.detectUpdatedTemplates(currentConsentTemplates, newConsentTemplates);\n            }\n            return [\n                new LoadAnonymousConsentTemplatesSuccess(newConsentTemplates),\n                new ToggleAnonymousConsentTemplatesUpdated(updated),\n            ];\n        }), catchError(error => of(new LoadAnonymousConsentTemplatesFail(makeErrorSerializable(error)))))));\n        this.transferAnonymousConsentsToUser$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), filter(() => isFeatureEnabled(this.anonymousConsentsConfig, ANONYMOUS_CONSENTS_FEATURE) && Boolean(this.anonymousConsentsConfig.anonymousConsents)), withLatestFrom(this.actions$.pipe(ofType(REGISTER_USER_SUCCESS))), filter(([, registerAction]) => Boolean(registerAction)), switchMap(() => this.anonymousConsentService.getConsents().pipe(withLatestFrom(this.authService.getOccUserId(), this.anonymousConsentService.getTemplates(), this.authService.isUserLoggedIn()), filter(([, , , loggedIn]) => loggedIn), concatMap(([consents, userId, templates, _loggedIn]) => {\n            const actions = [];\n            for (const consent of consents) {\n                if (this.anonymousConsentService.isConsentGiven(consent) &&\n                    (!this.anonymousConsentsConfig.anonymousConsents\n                        .requiredConsents ||\n                        !this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(consent.templateCode))) {\n                    for (const template of templates) {\n                        if (template.id === consent.templateCode) {\n                            actions.push(new TransferAnonymousConsent({\n                                userId,\n                                consentTemplateId: template.id,\n                                consentTemplateVersion: template.version,\n                            }));\n                            break;\n                        }\n                    }\n                }\n            }\n            if (actions.length > 0) {\n                return actions;\n            }\n            return EMPTY;\n        }))));\n        this.giveRequiredConsentsToUser$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), filter(action => isFeatureEnabled(this.anonymousConsentsConfig, ANONYMOUS_CONSENTS_FEATURE) &&\n            Boolean(this.anonymousConsentsConfig.anonymousConsents) &&\n            Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents) &&\n            Boolean(action)), concatMap(() => this.userConsentService.getConsentsResultSuccess().pipe(withLatestFrom(this.authService.getOccUserId(), this.userConsentService.getConsents(), this.authService.isUserLoggedIn()), filter(([, , , loggedIn]) => loggedIn), tap(([loaded, _userId, _templates, _loggedIn]) => {\n            if (!loaded) {\n                this.userConsentService.loadConsents();\n            }\n        }), map(([_loaded, userId, templates, _loggedIn]) => {\n            return { userId, templates };\n        }), concatMap(({ userId, templates }) => {\n            const actions = [];\n            for (const template of templates) {\n                if (this.userConsentService.isConsentWithdrawn(template.currentConsent) &&\n                    this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id)) {\n                    actions.push(new GiveUserConsent({\n                        userId,\n                        consentTemplateId: template.id,\n                        consentTemplateVersion: template.version,\n                    }));\n                }\n            }\n            if (actions.length > 0) {\n                return actions;\n            }\n            return EMPTY;\n        }))));\n    }\n};\nAnonymousConsentsEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: AnonymousConsentTemplatesConnector },\n    { type: AuthService },\n    { type: AnonymousConsentsConfig },\n    { type: AnonymousConsentsService },\n    { type: UserConsentService }\n];\n__decorate([\n    Effect()\n], AnonymousConsentsEffects.prototype, \"loadAnonymousConsentTemplates$\", void 0);\n__decorate([\n    Effect()\n], AnonymousConsentsEffects.prototype, \"transferAnonymousConsentsToUser$\", void 0);\n__decorate([\n    Effect()\n], AnonymousConsentsEffects.prototype, \"giveRequiredConsentsToUser$\", void 0);\nAnonymousConsentsEffects = __decorate([\n    Injectable()\n], AnonymousConsentsEffects);\n\nconst effects$1 = [AnonymousConsentsEffects];\n\nlet SiteConnector = class SiteConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    getLanguages() {\n        return this.adapter.loadLanguages();\n    }\n    getCurrencies() {\n        return this.adapter.loadCurrencies();\n    }\n    getCountries(type) {\n        return this.adapter.loadCountries(type);\n    }\n    getRegions(countryIsoCode) {\n        return this.adapter.loadRegions(countryIsoCode);\n    }\n    getBaseSite() {\n        return this.adapter.loadBaseSite();\n    }\n};\nSiteConnector.ctorParameters = () => [\n    { type: SiteAdapter }\n];\nSiteConnector.ɵprov = ɵɵdefineInjectable({ factory: function SiteConnector_Factory() { return new SiteConnector(ɵɵinject(SiteAdapter)); }, token: SiteConnector, providedIn: \"root\" });\nSiteConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SiteConnector);\n\nclass ContextServiceMap {\n}\nfunction serviceMapFactory() {\n    return {\n        [LANGUAGE_CONTEXT_ID]: LanguageService,\n        [CURRENCY_CONTEXT_ID]: CurrencyService,\n        [BASE_SITE_CONTEXT_ID]: BaseSiteService,\n    };\n}\nconst contextServiceMapProvider = {\n    provide: ContextServiceMap,\n    useFactory: serviceMapFactory,\n};\n\n/**\n * @deprecated since 1.3 - should be removed from public API and the logic should be moved to the function `initializeContext`\n */\nfunction inititializeContext(baseSiteService, langService, currService) {\n    return () => {\n        baseSiteService.initialize();\n        langService.initialize();\n        currService.initialize();\n    };\n}\nfunction initializeContext(baseSiteService, langService, currService, configInit) {\n    return () => {\n        const initialize = inititializeContext(baseSiteService, langService, currService);\n        configInit.getStableConfig('context').then(() => {\n            initialize();\n        });\n    };\n}\n/**\n * @deprecated since 1.3 - should be removed\n */\nconst deprecatedContextServiceProviders = [\n    BaseSiteService,\n    LanguageService,\n    CurrencyService,\n    {\n        provide: APP_INITIALIZER,\n        useFactory: inititializeContext,\n        deps: [BaseSiteService, LanguageService, CurrencyService],\n        multi: true,\n    },\n];\nconst contextServiceProviders = [\n    BaseSiteService,\n    LanguageService,\n    CurrencyService,\n    {\n        provide: APP_INITIALIZER,\n        useFactory: initializeContext,\n        deps: [\n            BaseSiteService,\n            LanguageService,\n            CurrencyService,\n            ConfigInitializerService,\n        ],\n        multi: true,\n    },\n];\n\nlet SiteContextParamsService = class SiteContextParamsService {\n    constructor(config, injector, serviceMap) {\n        this.config = config;\n        this.injector = injector;\n        this.serviceMap = serviceMap;\n    }\n    getContextParameters() {\n        if (this.config.context) {\n            return Object.keys(this.config.context).filter(param => param !== 'urlParameters');\n        }\n        return [];\n    }\n    getUrlEncodingParameters() {\n        return (this.config.context && this.config.context.urlParameters) || [];\n    }\n    getParamValues(param) {\n        return getContextParameterValues(this.config, param);\n    }\n    getParamDefaultValue(param) {\n        return getContextParameterDefault(this.config, param);\n    }\n    getSiteContextService(param) {\n        if (this.serviceMap[param]) {\n            return this.injector.get(this.serviceMap[param], null);\n        }\n    }\n    getValue(param) {\n        let value;\n        const service = this.getSiteContextService(param);\n        if (service) {\n            service\n                .getActive()\n                .subscribe(val => (value = val))\n                .unsubscribe();\n        }\n        return value !== undefined ? value : this.getParamDefaultValue(param);\n    }\n    setValue(param, value) {\n        const service = this.getSiteContextService(param);\n        if (service) {\n            service.setActive(value);\n        }\n    }\n};\nSiteContextParamsService.ctorParameters = () => [\n    { type: SiteContextConfig },\n    { type: Injector },\n    { type: ContextServiceMap }\n];\nSiteContextParamsService = __decorate([\n    Injectable()\n], SiteContextParamsService);\n\nconst UrlSplit = /(^[^#?]*)(.*)/; // used to split url into path and query/fragment parts\nlet SiteContextUrlSerializer = class SiteContextUrlSerializer extends DefaultUrlSerializer {\n    constructor(siteContextParams) {\n        super();\n        this.siteContextParams = siteContextParams;\n    }\n    get urlEncodingParameters() {\n        return this.siteContextParams.getUrlEncodingParameters();\n    }\n    get hasContextInRoutes() {\n        return this.urlEncodingParameters.length > 0;\n    }\n    parse(url) {\n        if (this.hasContextInRoutes) {\n            const urlWithParams = this.urlExtractContextParameters(url);\n            const parsed = super.parse(urlWithParams.url);\n            this.urlTreeIncludeContextParameters(parsed, urlWithParams.params);\n            return parsed;\n        }\n        else {\n            return super.parse(url);\n        }\n    }\n    urlExtractContextParameters(url) {\n        const [, urlPart, queryPart] = url.match(UrlSplit);\n        const segments = urlPart.split('/');\n        if (segments[0] === '') {\n            segments.shift();\n        }\n        const params = {};\n        let paramId = 0;\n        let segmentId = 0;\n        while (paramId < this.urlEncodingParameters.length &&\n            segmentId < segments.length) {\n            const paramName = this.urlEncodingParameters[paramId];\n            const paramValues = this.siteContextParams.getParamValues(paramName);\n            if (paramValues.includes(segments[segmentId])) {\n                params[paramName] = segments[segmentId];\n                segmentId++;\n            }\n            paramId++;\n        }\n        url = segments.slice(Object.keys(params).length).join('/') + queryPart;\n        return { url, params };\n    }\n    urlTreeIncludeContextParameters(urlTree, params) {\n        urlTree.siteContext = params;\n    }\n    serialize(tree) {\n        const params = this.urlTreeExtractContextParameters(tree);\n        const url = super.serialize(tree);\n        const serialized = this.urlIncludeContextParameters(url, params);\n        return serialized;\n    }\n    urlTreeExtractContextParameters(urlTree) {\n        return urlTree.siteContext ? urlTree.siteContext : {};\n    }\n    urlIncludeContextParameters(url, params) {\n        const contextRoutePart = this.urlEncodingParameters\n            .map(param => {\n            return params[param]\n                ? params[param]\n                : this.siteContextParams.getValue(param);\n        })\n            .join('/');\n        return contextRoutePart + url;\n    }\n};\nSiteContextUrlSerializer.ctorParameters = () => [\n    { type: SiteContextParamsService }\n];\nSiteContextUrlSerializer = __decorate([\n    Injectable()\n], SiteContextUrlSerializer);\n\nlet SiteContextRoutesHandler = class SiteContextRoutesHandler {\n    constructor(siteContextParams, serializer, injector) {\n        this.siteContextParams = siteContextParams;\n        this.serializer = serializer;\n        this.injector = injector;\n        this.subscription = new Subscription();\n        this.contextValues = {};\n        this.isNavigating = false;\n    }\n    init() {\n        this.router = this.injector.get(Router);\n        this.location = this.injector.get(Location);\n        const routingParams = this.siteContextParams.getUrlEncodingParameters();\n        if (routingParams.length) {\n            this.setContextParamsFromRoute(this.router.url);\n            this.subscribeChanges(routingParams);\n            this.subscribeRouting();\n        }\n    }\n    subscribeChanges(params) {\n        params.forEach(param => {\n            const service = this.siteContextParams.getSiteContextService(param);\n            if (service) {\n                this.subscription.add(service.getActive().subscribe(value => {\n                    if (!this.isNavigating &&\n                        this.contextValues[param] &&\n                        this.contextValues[param] !== value) {\n                        const parsed = this.router.parseUrl(this.router.url);\n                        const serialized = this.router.serializeUrl(parsed);\n                        this.location.replaceState(serialized);\n                    }\n                    this.contextValues[param] = value;\n                }));\n            }\n        });\n    }\n    subscribeRouting() {\n        this.subscription.add(this.router.events\n            .pipe(filter(event => event instanceof NavigationStart ||\n            event instanceof NavigationEnd ||\n            event instanceof NavigationError ||\n            event instanceof NavigationCancel))\n            .subscribe((event) => {\n            this.isNavigating = event instanceof NavigationStart;\n            if (this.isNavigating) {\n                this.setContextParamsFromRoute(event.url);\n            }\n        }));\n    }\n    setContextParamsFromRoute(url) {\n        const { params } = this.serializer.urlExtractContextParameters(url);\n        Object.keys(params).forEach(param => this.siteContextParams.setValue(param, params[param]));\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n};\nSiteContextRoutesHandler.ctorParameters = () => [\n    { type: SiteContextParamsService },\n    { type: SiteContextUrlSerializer },\n    { type: Injector }\n];\nSiteContextRoutesHandler.ɵprov = ɵɵdefineInjectable({ factory: function SiteContextRoutesHandler_Factory() { return new SiteContextRoutesHandler(ɵɵinject(SiteContextParamsService), ɵɵinject(SiteContextUrlSerializer), ɵɵinject(INJECTOR)); }, token: SiteContextRoutesHandler, providedIn: \"root\" });\nSiteContextRoutesHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SiteContextRoutesHandler);\n\n// functions below should not be exposed in public API:\nfunction initSiteContextRoutesHandler(siteContextRoutesHandler, configInit) {\n    return () => {\n        configInit.getStableConfig('context').then(() => {\n            siteContextRoutesHandler.init();\n        });\n    };\n}\nconst siteContextParamsProviders = [\n    SiteContextParamsService,\n    SiteContextUrlSerializer,\n    { provide: UrlSerializer, useExisting: SiteContextUrlSerializer },\n    {\n        provide: APP_INITIALIZER,\n        useFactory: initSiteContextRoutesHandler,\n        deps: [SiteContextRoutesHandler, ConfigInitializerService],\n        multi: true,\n    },\n];\n/**\n * @deprecated since 1.3.1; TODO: remove\n */\nfunction deprecatedInitSiteContextRoutesHandler(siteContextRoutesHandler) {\n    return () => {\n        siteContextRoutesHandler.init();\n    };\n}\n/**\n * @deprecated since 1.3.1; TODO: remove\n */\nconst deprecatedSiteContextParamsProviders = [\n    SiteContextParamsService,\n    SiteContextUrlSerializer,\n    { provide: UrlSerializer, useExisting: SiteContextUrlSerializer },\n    {\n        provide: APP_INITIALIZER,\n        useFactory: deprecatedInitSiteContextRoutesHandler,\n        deps: [SiteContextRoutesHandler],\n        multi: true,\n    },\n];\n\nfunction baseSiteConfigValidator(config) {\n    if (getContextParameterDefault(config, BASE_SITE_CONTEXT_ID) === undefined) {\n        return 'Please configure context.parameters.baseSite before using storefront library!';\n    }\n}\n\nfunction defaultSiteContextConfigFactory() {\n    return {\n        context: {\n            [LANGUAGE_CONTEXT_ID]: [\n                'en',\n                'de',\n                'ja',\n                'zh',\n                'ru',\n                'fr',\n                'tr',\n                'it',\n                'es',\n                'uk',\n                'pl',\n                'nl',\n                'hi',\n                'ar',\n                'pt',\n                'bn',\n                'pa',\n            ],\n            [CURRENCY_CONTEXT_ID]: [\n                'USD',\n                'EUR',\n                'JPY',\n                'GBP',\n                'AUD',\n                'CAD',\n                'CHF',\n                'CNY',\n                'SEK',\n                'NZD',\n                'MXN',\n                'SGD',\n                'HKD',\n                'NOK',\n                'KRW',\n                'TRY',\n                'RUB',\n                'INR',\n                'BRL',\n                'ZAR',\n            ],\n        },\n    };\n}\n\nlet LanguagesEffects = class LanguagesEffects {\n    constructor(actions$, siteConnector, winRef) {\n        this.actions$ = actions$;\n        this.siteConnector = siteConnector;\n        this.winRef = winRef;\n        this.loadLanguages$ = this.actions$.pipe(ofType(LOAD_LANGUAGES), exhaustMap(() => {\n            return this.siteConnector.getLanguages().pipe(map(languages => new LoadLanguagesSuccess(languages)), catchError(error => of(new LoadLanguagesFail(makeErrorSerializable(error)))));\n        }));\n        this.activateLanguage$ = this.actions$.pipe(ofType(SET_ACTIVE_LANGUAGE), tap((action) => {\n            if (this.winRef.sessionStorage) {\n                this.winRef.sessionStorage.setItem('language', action.payload);\n            }\n        }), map(() => new LanguageChange()));\n    }\n};\nLanguagesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: SiteConnector },\n    { type: WindowRef }\n];\n__decorate([\n    Effect()\n], LanguagesEffects.prototype, \"loadLanguages$\", void 0);\n__decorate([\n    Effect()\n], LanguagesEffects.prototype, \"activateLanguage$\", void 0);\nLanguagesEffects = __decorate([\n    Injectable()\n], LanguagesEffects);\n\nlet CurrenciesEffects = class CurrenciesEffects {\n    constructor(actions$, siteConnector, winRef) {\n        this.actions$ = actions$;\n        this.siteConnector = siteConnector;\n        this.winRef = winRef;\n        this.loadCurrencies$ = this.actions$.pipe(ofType(LOAD_CURRENCIES), exhaustMap(() => {\n            return this.siteConnector.getCurrencies().pipe(map(currencies => new LoadCurrenciesSuccess(currencies)), catchError(error => of(new LoadCurrenciesFail(makeErrorSerializable(error)))));\n        }));\n        this.activateCurrency$ = this.actions$.pipe(ofType(SET_ACTIVE_CURRENCY), tap((action) => {\n            if (this.winRef.sessionStorage) {\n                this.winRef.sessionStorage.setItem('currency', action.payload);\n            }\n        }), map(() => new CurrencyChange()));\n    }\n};\nCurrenciesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: SiteConnector },\n    { type: WindowRef }\n];\n__decorate([\n    Effect()\n], CurrenciesEffects.prototype, \"loadCurrencies$\", void 0);\n__decorate([\n    Effect()\n], CurrenciesEffects.prototype, \"activateCurrency$\", void 0);\nCurrenciesEffects = __decorate([\n    Injectable()\n], CurrenciesEffects);\n\nlet BaseSiteEffects = class BaseSiteEffects {\n    constructor(actions$, siteConnector) {\n        this.actions$ = actions$;\n        this.siteConnector = siteConnector;\n        this.loadBaseSite$ = this.actions$.pipe(ofType(LOAD_BASE_SITE), exhaustMap(() => {\n            return this.siteConnector.getBaseSite().pipe(map(baseSite => new LoadBaseSiteSuccess(baseSite)), catchError(error => of(new LoadBaseSiteFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nBaseSiteEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: SiteConnector }\n];\n__decorate([\n    Effect()\n], BaseSiteEffects.prototype, \"loadBaseSite$\", void 0);\nBaseSiteEffects = __decorate([\n    Injectable()\n], BaseSiteEffects);\n\nconst effects$2 = [\n    LanguagesEffects,\n    CurrenciesEffects,\n    BaseSiteEffects,\n];\n\nconst initialState$1 = {\n    details: {},\n    activeSite: '',\n};\nfunction reducer$1(state = initialState$1, action) {\n    switch (action.type) {\n        case LOAD_BASE_SITE_SUCCESS: {\n            return Object.assign(Object.assign({}, state), { details: action.payload });\n        }\n        case SET_ACTIVE_BASE_SITE: {\n            return Object.assign(Object.assign({}, state), { activeSite: action.payload });\n        }\n    }\n    return state;\n}\n\nconst initialState$2 = {\n    entities: null,\n    activeCurrency: null,\n};\nfunction reducer$2(state = initialState$2, action) {\n    switch (action.type) {\n        case LOAD_CURRENCIES_SUCCESS: {\n            const currencies = action.payload;\n            const entities = currencies.reduce((currEntities, currency) => {\n                return Object.assign(Object.assign({}, currEntities), { [currency.isocode]: currency });\n            }, Object.assign({}, state.entities));\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n        case SET_ACTIVE_CURRENCY: {\n            const isocode = action.payload;\n            return Object.assign(Object.assign({}, state), { activeCurrency: isocode });\n        }\n    }\n    return state;\n}\n\nconst initialState$3 = {\n    entities: null,\n    activeLanguage: null,\n};\nfunction reducer$3(state = initialState$3, action) {\n    switch (action.type) {\n        case LOAD_LANGUAGES_SUCCESS: {\n            const languages = action.payload;\n            const entities = languages.reduce((langEntities, language) => {\n                return Object.assign(Object.assign({}, langEntities), { [language.isocode]: language });\n            }, Object.assign({}, state.entities));\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n        case SET_ACTIVE_LANGUAGE: {\n            const isocode = action.payload;\n            return Object.assign(Object.assign({}, state), { activeLanguage: isocode });\n        }\n    }\n    return state;\n}\n\nfunction getReducers$1() {\n    return {\n        languages: reducer$3,\n        currencies: reducer$2,\n        baseSite: reducer$1,\n    };\n}\nconst reducerToken$1 = new InjectionToken('SiteContextReducers');\nconst reducerProvider$1 = {\n    provide: reducerToken$1,\n    useFactory: getReducers$1,\n};\n\nfunction siteContextStoreConfigFactory() {\n    // if we want to reuse SITE_CONTEXT_FEATURE const in config, we have to use factory instead of plain object\n    const config = {\n        state: {\n            ssrTransfer: {\n                keys: { [SITE_CONTEXT_FEATURE]: StateTransferType.TRANSFER_STATE },\n            },\n        },\n    };\n    return config;\n}\nlet SiteContextStoreModule = class SiteContextStoreModule {\n};\nSiteContextStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StoreModule.forFeature(SITE_CONTEXT_FEATURE, reducerToken$1),\n            EffectsModule.forFeature(effects$2),\n            ConfigModule.withConfigFactory(siteContextStoreConfigFactory),\n        ],\n        providers: [reducerProvider$1],\n    })\n], SiteContextStoreModule);\n\nvar SiteContextModule_1;\n// @dynamic\nlet SiteContextModule = SiteContextModule_1 = class SiteContextModule {\n    static forRoot() {\n        return {\n            ngModule: SiteContextModule_1,\n            providers: [\n                contextServiceMapProvider,\n                ...contextServiceProviders,\n                ...siteContextParamsProviders,\n                { provide: SiteContextConfig, useExisting: Config },\n                provideConfigValidator(baseSiteConfigValidator),\n            ],\n        };\n    }\n};\nSiteContextModule = SiteContextModule_1 = __decorate([\n    NgModule({\n        imports: [\n            ConfigModule.withConfigFactory(defaultSiteContextConfigFactory),\n            StateModule,\n            SiteContextStoreModule,\n        ],\n    })\n], SiteContextModule);\n\nconst initialState$4 = false;\nfunction reducer$4(state = initialState$4, action) {\n    switch (action.type) {\n        case TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: {\n            return action.dismissed;\n        }\n    }\n    return state;\n}\n\nconst initialState$5 = false;\nfunction reducer$5(state = initialState$5, action) {\n    switch (action.type) {\n        case TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: {\n            return action.updated;\n        }\n    }\n    return state;\n}\n\nconst initialState$6 = [];\nfunction toggleConsentStatus(consents, templateCode, status) {\n    if (!consents) {\n        return [];\n    }\n    return consents.map(consent => {\n        if (consent.templateCode === templateCode) {\n            consent = Object.assign(Object.assign({}, consent), { consentState: status });\n        }\n        return consent;\n    });\n}\nfunction reducer$6(state = initialState$6, action) {\n    switch (action.type) {\n        case GIVE_ANONYMOUS_CONSENT: {\n            return toggleConsentStatus(state, action.templateCode, ANONYMOUS_CONSENT_STATUS.GIVEN);\n        }\n        case WITHDRAW_ANONYMOUS_CONSENT: {\n            return toggleConsentStatus(state, action.templateCode, ANONYMOUS_CONSENT_STATUS.WITHDRAWN);\n        }\n        case SET_ANONYMOUS_CONSENTS: {\n            return action.payload;\n        }\n    }\n    return state;\n}\n\nfunction getReducers$2() {\n    return {\n        templates: loaderReducer(ANONYMOUS_CONSENTS),\n        consents: reducer$6,\n        ui: combineReducers({\n            bannerDismissed: reducer$4,\n            updated: reducer$5,\n        }),\n    };\n}\nconst reducerToken$2 = new InjectionToken('AnonymousConsentsReducers');\nconst reducerProvider$2 = {\n    provide: reducerToken$2,\n    useFactory: getReducers$2,\n};\nfunction clearAnonymousConsentTemplates(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT ||\n            action.type === LANGUAGE_CHANGE) {\n            state = Object.assign(Object.assign({}, state), { templates: undefined });\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers$1 = [\n    clearAnonymousConsentTemplates,\n];\n\nfunction anonymousConsentsStoreConfigFactory() {\n    const config = {\n        state: {\n            storageSync: {\n                keys: {\n                    [ANONYMOUS_CONSENTS_STORE_FEATURE]: StorageSyncType.LOCAL_STORAGE,\n                },\n            },\n        },\n    };\n    return config;\n}\nlet AnonymousConsentsStoreModule = class AnonymousConsentsStoreModule {\n};\nAnonymousConsentsStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            ReactiveFormsModule,\n            StateModule,\n            StoreModule.forFeature(ANONYMOUS_CONSENTS_STORE_FEATURE, reducerToken$2, {\n                metaReducers: metaReducers$1,\n            }),\n            EffectsModule.forFeature(effects$1),\n            ConfigModule.withConfigFactory(anonymousConsentsStoreConfigFactory),\n        ],\n        providers: [reducerProvider$2],\n    })\n], AnonymousConsentsStoreModule);\n\nvar AnonymousConsentsModule_1;\nlet AnonymousConsentsModule = AnonymousConsentsModule_1 = class AnonymousConsentsModule {\n    static forRoot() {\n        return {\n            ngModule: AnonymousConsentsModule_1,\n            providers: [\n                ...interceptors$1,\n                AnonymousConsentsService,\n                { provide: AnonymousConsentsConfig, useExisting: Config },\n            ],\n        };\n    }\n};\nAnonymousConsentsModule = AnonymousConsentsModule_1 = __decorate([\n    NgModule({\n        imports: [\n            AnonymousConsentsStoreModule,\n            ConfigModule.withConfig(defaultAnonymousConsentsConfig),\n        ],\n    })\n], AnonymousConsentsModule);\n\nconst defaultAsmConfig = {\n    asm: {\n        agentSessionTimer: {\n            startingDelayInSeconds: 600,\n        },\n        customerSearch: {\n            maxResults: 20,\n        },\n    },\n};\n\nconst ASM_FEATURE = 'asm';\nconst CUSTOMER_SEARCH_DATA = '[asm] Customer search data';\nconst CSAGENT_TOKEN_DATA = '[Auth] Customer Support Agent Token Data';\n\nlet AsmConnector = class AsmConnector {\n    constructor(asmAdapter) {\n        this.asmAdapter = asmAdapter;\n    }\n    customerSearch(options) {\n        return this.asmAdapter.customerSearch(options);\n    }\n};\nAsmConnector.ctorParameters = () => [\n    { type: AsmAdapter }\n];\nAsmConnector.ɵprov = ɵɵdefineInjectable({ factory: function AsmConnector_Factory() { return new AsmConnector(ɵɵinject(AsmAdapter)); }, token: AsmConnector, providedIn: \"root\" });\nAsmConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AsmConnector);\n\nconst ASM_UI_UPDATE = '[Asm] UI Update';\nclass AsmUiUpdate {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ASM_UI_UPDATE;\n    }\n}\n\nconst CUSTOMER_SEARCH = '[Asm] Customer Search';\nconst CUSTOMER_SEARCH_FAIL = '[Asm] Customer Search Fail';\nconst CUSTOMER_SEARCH_SUCCESS = '[Asm] Customer Search Success';\nconst CUSTOMER_SEARCH_RESET = '[Asm] Customer Search Reset';\nclass CustomerSearch extends LoaderLoadAction {\n    constructor(payload) {\n        super(CUSTOMER_SEARCH_DATA);\n        this.payload = payload;\n        this.type = CUSTOMER_SEARCH;\n    }\n}\nclass CustomerSearchFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CUSTOMER_SEARCH_DATA);\n        this.payload = payload;\n        this.type = CUSTOMER_SEARCH_FAIL;\n    }\n}\nclass CustomerSearchSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CUSTOMER_SEARCH_DATA);\n        this.payload = payload;\n        this.type = CUSTOMER_SEARCH_SUCCESS;\n    }\n}\nclass CustomerSearchReset extends LoaderResetAction {\n    constructor() {\n        super(CUSTOMER_SEARCH_DATA);\n        this.type = CUSTOMER_SEARCH_RESET;\n    }\n}\n\nconst LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN = '[Auth] Load Customer Service Agent Token';\nconst LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL = '[Auth] Load Customer Service Agent Token Fail';\nconst LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS = '[Auth] Load Customer Service Agent Token Success';\nclass LoadCustomerSupportAgentToken extends LoaderLoadAction {\n    constructor(payload) {\n        super(CSAGENT_TOKEN_DATA);\n        this.payload = payload;\n        this.type = LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN;\n    }\n}\nclass LoadCustomerSupportAgentTokenFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CSAGENT_TOKEN_DATA);\n        this.payload = payload;\n        this.type = LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL;\n    }\n}\nclass LoadCustomerSupportAgentTokenSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CSAGENT_TOKEN_DATA);\n        this.payload = payload;\n        this.type = LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS;\n    }\n}\nclass LogoutCustomerSupportAgent {\n    constructor() {\n        this.type = LOGOUT_CUSTOMER_SUPPORT_AGENT;\n    }\n}\n\n\n\nvar customerGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ASM_UI_UPDATE: ASM_UI_UPDATE,\n    AsmUiUpdate: AsmUiUpdate,\n    CUSTOMER_SEARCH: CUSTOMER_SEARCH,\n    CUSTOMER_SEARCH_FAIL: CUSTOMER_SEARCH_FAIL,\n    CUSTOMER_SEARCH_SUCCESS: CUSTOMER_SEARCH_SUCCESS,\n    CUSTOMER_SEARCH_RESET: CUSTOMER_SEARCH_RESET,\n    CustomerSearch: CustomerSearch,\n    CustomerSearchFail: CustomerSearchFail,\n    CustomerSearchSuccess: CustomerSearchSuccess,\n    CustomerSearchReset: CustomerSearchReset,\n    LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN: LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN,\n    LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL: LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL,\n    LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS: LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS,\n    LoadCustomerSupportAgentToken: LoadCustomerSupportAgentToken,\n    LoadCustomerSupportAgentTokenFail: LoadCustomerSupportAgentTokenFail,\n    LoadCustomerSupportAgentTokenSuccess: LoadCustomerSupportAgentTokenSuccess,\n    LogoutCustomerSupportAgent: LogoutCustomerSupportAgent\n});\n\nlet CustomerEffects = class CustomerEffects {\n    constructor(actions$, asmConnector) {\n        this.actions$ = actions$;\n        this.asmConnector = asmConnector;\n        this.customerSearch$ = this.actions$.pipe(ofType(CUSTOMER_SEARCH), map((action) => action.payload), switchMap(options => this.asmConnector.customerSearch(options).pipe(map((customerSearchResults) => {\n            return new CustomerSearchSuccess(customerSearchResults);\n        }), catchError(error => of(new CustomerSearchFail(makeErrorSerializable(error)))))));\n    }\n};\nCustomerEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: AsmConnector }\n];\n__decorate([\n    Effect()\n], CustomerEffects.prototype, \"customerSearch$\", void 0);\nCustomerEffects = __decorate([\n    Injectable()\n], CustomerEffects);\n\nlet CustomerSupportAgentTokenEffects = class CustomerSupportAgentTokenEffects {\n    constructor(actions$, userTokenService) {\n        this.actions$ = actions$;\n        this.userTokenService = userTokenService;\n        this.loadCustomerSupportAgentToken$ = this.actions$.pipe(ofType(LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN), map((action) => action.payload), switchMap(({ userId, password }) => this.userTokenService.loadToken(userId, password).pipe(map((token) => {\n            const date = new Date();\n            date.setSeconds(date.getSeconds() + token.expires_in);\n            token.expiration_time = date.toJSON();\n            return new LoadCustomerSupportAgentTokenSuccess(token);\n        }), catchError(error => of(new LoadCustomerSupportAgentTokenFail(makeErrorSerializable(error)))))));\n    }\n};\nCustomerSupportAgentTokenEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserAuthenticationTokenService }\n];\n__decorate([\n    Effect()\n], CustomerSupportAgentTokenEffects.prototype, \"loadCustomerSupportAgentToken$\", void 0);\nCustomerSupportAgentTokenEffects = __decorate([\n    Injectable()\n], CustomerSupportAgentTokenEffects);\n\nconst effects$3 = [\n    CustomerEffects,\n    CustomerSupportAgentTokenEffects,\n];\n\nconst initialState$7 = { collapsed: false };\nfunction reducer$7(state = initialState$7, action) {\n    switch (action.type) {\n        case ASM_UI_UPDATE: {\n            return Object.assign(Object.assign({}, state), action.payload);\n        }\n        default: {\n            return state;\n        }\n    }\n}\n\nfunction getReducers$3() {\n    return {\n        customerSearchResult: loaderReducer(CUSTOMER_SEARCH_DATA),\n        asmUi: reducer$7,\n        csagentToken: loaderReducer(CSAGENT_TOKEN_DATA),\n    };\n}\nconst reducerToken$3 = new InjectionToken('AsmReducers');\nconst reducerProvider$3 = {\n    provide: reducerToken$3,\n    useFactory: getReducers$3,\n};\nfunction clearCustomerSupportAgentAsmState(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT_CUSTOMER_SUPPORT_AGENT) {\n            state = Object.assign(Object.assign({}, state), { customerSearchResult: undefined, csagentToken: undefined });\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers$2 = [\n    clearCustomerSupportAgentAsmState,\n];\n\nfunction asmStoreConfigFactory() {\n    const config = {\n        state: {\n            storageSync: {\n                keys: {\n                    'asm.asmUi': StorageSyncType.LOCAL_STORAGE,\n                    'asm.csagentToken.value.access_token': StorageSyncType.LOCAL_STORAGE,\n                    'asm.csagentToken.value.token_type': StorageSyncType.LOCAL_STORAGE,\n                    'asm.csagentToken.value.expires_in': StorageSyncType.LOCAL_STORAGE,\n                    'asm.csagentToken.value.expiration_time': StorageSyncType.LOCAL_STORAGE,\n                    'asm.csagentToken.value.scope': StorageSyncType.LOCAL_STORAGE,\n                    'asm.csagentToken.value.userId': StorageSyncType.LOCAL_STORAGE,\n                },\n            },\n        },\n    };\n    return config;\n}\nlet AsmStoreModule = class AsmStoreModule {\n};\nAsmStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StateModule,\n            StoreModule.forFeature(ASM_FEATURE, reducerToken$3, { metaReducers: metaReducers$2 }),\n            EffectsModule.forFeature(effects$3),\n            ConfigModule.withConfigFactory(asmStoreConfigFactory),\n        ],\n        providers: [reducerProvider$3],\n    })\n], AsmStoreModule);\n\nconst getAsmState = createFeatureSelector(ASM_FEATURE);\n\nconst ɵ0$r = (state) => state.asmUi;\nconst getAsmUi = createSelector(getAsmState, ɵ0$r);\n\nconst ɵ0$s = (state) => state.customerSearchResult;\nconst getCustomerSearchResultsLoaderState = createSelector(getAsmState, ɵ0$s);\nconst ɵ1$l = state => loaderValueSelector(state);\nconst getCustomerSearchResults = createSelector(getCustomerSearchResultsLoaderState, ɵ1$l);\nconst ɵ2$e = state => loaderLoadingSelector(state);\nconst getCustomerSearchResultsLoading = createSelector(getCustomerSearchResultsLoaderState, ɵ2$e);\n\nconst ɵ0$t = (state) => state.csagentToken;\nconst getCustomerSupportAgentTokenState = createSelector(getAsmState, ɵ0$t);\nconst ɵ1$m = state => loaderValueSelector(state);\nconst getCustomerSupportAgentToken = createSelector(getCustomerSupportAgentTokenState, ɵ1$m);\nconst ɵ2$f = state => loaderLoadingSelector(state);\nconst getCustomerSupportAgentTokenLoading = createSelector(getCustomerSupportAgentTokenState, ɵ2$f);\n\n\n\nvar asmGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getAsmUi: getAsmUi,\n    ɵ0: ɵ0$r,\n    getCustomerSearchResultsLoaderState: getCustomerSearchResultsLoaderState,\n    getCustomerSearchResults: getCustomerSearchResults,\n    getCustomerSearchResultsLoading: getCustomerSearchResultsLoading,\n    ɵ1: ɵ1$l,\n    ɵ2: ɵ2$e,\n    getAsmState: getAsmState,\n    getCustomerSupportAgentTokenState: getCustomerSupportAgentTokenState,\n    getCustomerSupportAgentToken: getCustomerSupportAgentToken,\n    getCustomerSupportAgentTokenLoading: getCustomerSupportAgentTokenLoading\n});\n\nlet AsmAuthService = class AsmAuthService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Loads a user token for a customer support agent\n     * @param userId\n     * @param password\n     */\n    authorizeCustomerSupportAgent(userId, password) {\n        this.store.dispatch(new LoadCustomerSupportAgentToken({\n            userId: userId,\n            password: password,\n        }));\n    }\n    /**\n     * Starts an ASM customer emulation session.\n     * A customer emulation session is stoped by calling logout().\n     * @param customerSupportAgentToken\n     * @param customerId\n     */\n    startCustomerEmulationSession(customerSupportAgentToken, customerId) {\n        this.authService.authorizeWithToken(Object.assign(Object.assign({}, customerSupportAgentToken), { userId: customerId }));\n    }\n    /**\n     * Utility function to determine if a given token is a customer emulation session token.\n     * @param userToken\n     */\n    isCustomerEmulationToken(userToken) {\n        return (Boolean(userToken) &&\n            Boolean(userToken.userId) &&\n            userToken.userId !== OCC_USER_ID_CURRENT);\n    }\n    /**\n     * Returns the customer support agent's token\n     */\n    getCustomerSupportAgentToken() {\n        return this.store.pipe(select(getCustomerSupportAgentToken));\n    }\n    /**\n     * Returns the customer support agent's token loading status\n     */\n    getCustomerSupportAgentTokenLoading() {\n        return this.store.pipe(select(getCustomerSupportAgentTokenLoading));\n    }\n    /**\n     * Logout a customer support agent\n     */\n    logoutCustomerSupportAgent() {\n        this.getCustomerSupportAgentToken()\n            .pipe(take(1))\n            .subscribe(userToken => {\n            this.store.dispatch(new LogoutCustomerSupportAgent());\n            this.store.dispatch(new RevokeUserToken(userToken));\n        });\n    }\n};\nAsmAuthService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nAsmAuthService.ɵprov = ɵɵdefineInjectable({ factory: function AsmAuthService_Factory() { return new AsmAuthService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: AsmAuthService, providedIn: \"root\" });\nAsmAuthService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AsmAuthService);\n\nlet CustomerSupportAgentTokenInterceptor = class CustomerSupportAgentTokenInterceptor {\n    constructor(asmAuthService) {\n        this.asmAuthService = asmAuthService;\n    }\n    intercept(request, next) {\n        return this.getCustomerSupportAgentToken(request).pipe(take(1), switchMap((token) => {\n            if (token) {\n                request = request.clone({\n                    setHeaders: {\n                        Authorization: `${token.token_type} ${token.access_token}`,\n                    },\n                });\n            }\n            return next.handle(request);\n        }));\n    }\n    getCustomerSupportAgentToken(request) {\n        if (InterceptorUtil.getInterceptorParam(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request.headers)) {\n            return this.asmAuthService.getCustomerSupportAgentToken();\n        }\n        return of(null);\n    }\n};\nCustomerSupportAgentTokenInterceptor.ctorParameters = () => [\n    { type: AsmAuthService }\n];\nCustomerSupportAgentTokenInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function CustomerSupportAgentTokenInterceptor_Factory() { return new CustomerSupportAgentTokenInterceptor(ɵɵinject(AsmAuthService)); }, token: CustomerSupportAgentTokenInterceptor, providedIn: \"root\" });\nCustomerSupportAgentTokenInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], CustomerSupportAgentTokenInterceptor);\n\nvar GlobalMessageType;\n(function (GlobalMessageType) {\n    GlobalMessageType[\"MSG_TYPE_CONFIRMATION\"] = \"[GlobalMessage] Confirmation\";\n    GlobalMessageType[\"MSG_TYPE_ERROR\"] = \"[GlobalMessage] Error\";\n    GlobalMessageType[\"MSG_TYPE_INFO\"] = \"[GlobalMessage] Information\";\n    GlobalMessageType[\"MSG_TYPE_WARNING\"] = \"[GlobalMessage] Warning\";\n})(GlobalMessageType || (GlobalMessageType = {}));\n\nclass GlobalMessageConfig {\n}\n\nconst ADD_MESSAGE = '[Global-message] Add a Message';\nconst REMOVE_MESSAGE = '[Global-message] Remove a Message';\nconst REMOVE_MESSAGES_BY_TYPE = '[Global-message] Remove messages by type';\nclass AddMessage {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ADD_MESSAGE;\n    }\n}\nclass RemoveMessage {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REMOVE_MESSAGE;\n    }\n}\nclass RemoveMessagesByType {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = REMOVE_MESSAGES_BY_TYPE;\n    }\n}\n\n\n\nvar globalMessageGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ADD_MESSAGE: ADD_MESSAGE,\n    REMOVE_MESSAGE: REMOVE_MESSAGE,\n    REMOVE_MESSAGES_BY_TYPE: REMOVE_MESSAGES_BY_TYPE,\n    AddMessage: AddMessage,\n    RemoveMessage: RemoveMessage,\n    RemoveMessagesByType: RemoveMessagesByType\n});\n\nconst GLOBAL_MESSAGE_FEATURE = 'global-message';\n\nconst getGlobalMessageState = createFeatureSelector(GLOBAL_MESSAGE_FEATURE);\n\nconst ɵ0$u = (state) => state.entities;\nconst getGlobalMessageEntities = createSelector(getGlobalMessageState, ɵ0$u);\nconst getGlobalMessageEntitiesByType = (type) => {\n    return createSelector(getGlobalMessageEntities, entities => entities && entities[type]);\n};\nconst getGlobalMessageCountByType = (type) => {\n    return createSelector(getGlobalMessageEntitiesByType(type), entities => entities && entities.length);\n};\n\n\n\nvar globalMessageGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getGlobalMessageState: getGlobalMessageState,\n    getGlobalMessageEntities: getGlobalMessageEntities,\n    getGlobalMessageEntitiesByType: getGlobalMessageEntitiesByType,\n    getGlobalMessageCountByType: getGlobalMessageCountByType,\n    ɵ0: ɵ0$u\n});\n\nlet GlobalMessageService = class GlobalMessageService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Get all global messages\n     */\n    get() {\n        return this.store.pipe(select(getGlobalMessageEntities), filter(data => data !== undefined));\n    }\n    /**\n     * Add one message into store\n     * @param text: string | Translatable\n     * @param type: GlobalMessageType object\n     * @param timeout: number\n     */\n    add(text, type, timeout) {\n        this.store.dispatch(new AddMessage({\n            text: typeof text === 'string' ? { raw: text } : text,\n            type,\n            timeout,\n        }));\n    }\n    /**\n     * Remove message(s) from store\n     * @param type: GlobalMessageType\n     * @param index:optional. Without it, messages will be removed by type; otherwise,\n     * message will be removed from list by index.\n     */\n    remove(type, index) {\n        this.store.dispatch(index !== undefined\n            ? new RemoveMessage({\n                type: type,\n                index: index,\n            })\n            : new RemoveMessagesByType(type));\n    }\n};\nGlobalMessageService.ctorParameters = () => [\n    { type: Store }\n];\nGlobalMessageService = __decorate([\n    Injectable()\n], GlobalMessageService);\n\nvar HttpResponseStatus;\n(function (HttpResponseStatus) {\n    HttpResponseStatus[HttpResponseStatus[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n    HttpResponseStatus[HttpResponseStatus[\"BAD_REQUEST\"] = 400] = \"BAD_REQUEST\";\n    HttpResponseStatus[HttpResponseStatus[\"FORBIDDEN\"] = 403] = \"FORBIDDEN\";\n    HttpResponseStatus[HttpResponseStatus[\"NOT_FOUND\"] = 404] = \"NOT_FOUND\";\n    HttpResponseStatus[HttpResponseStatus[\"CONFLICT\"] = 409] = \"CONFLICT\";\n    HttpResponseStatus[HttpResponseStatus[\"BAD_GATEWAY\"] = 502] = \"BAD_GATEWAY\";\n    HttpResponseStatus[HttpResponseStatus[\"GATEWAY_TIMEOUT\"] = 504] = \"GATEWAY_TIMEOUT\";\n    HttpResponseStatus[HttpResponseStatus[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n})(HttpResponseStatus || (HttpResponseStatus = {}));\n\nlet HttpErrorHandler = class HttpErrorHandler {\n    constructor(globalMessageService) {\n        this.globalMessageService = globalMessageService;\n    }\n};\nHttpErrorHandler.ctorParameters = () => [\n    { type: GlobalMessageService }\n];\nHttpErrorHandler.ɵprov = ɵɵdefineInjectable({ factory: function HttpErrorHandler_Factory() { return new HttpErrorHandler(ɵɵinject(GlobalMessageService)); }, token: HttpErrorHandler, providedIn: \"root\" });\nHttpErrorHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], HttpErrorHandler);\n\nlet BadGatewayHandler = class BadGatewayHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.BAD_GATEWAY;\n    }\n    handleError() {\n        this.globalMessageService.add({ key: 'httpHandlers.badGateway' }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n};\nBadGatewayHandler.ɵprov = ɵɵdefineInjectable({ factory: function BadGatewayHandler_Factory() { return new BadGatewayHandler(ɵɵinject(GlobalMessageService)); }, token: BadGatewayHandler, providedIn: \"root\" });\nBadGatewayHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], BadGatewayHandler);\n\nconst OAUTH_ENDPOINT$1 = '/authorizationserver/oauth/token';\nlet BadRequestHandler = class BadRequestHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.BAD_REQUEST;\n    }\n    handleError(request, response) {\n        if (response.url.includes(OAUTH_ENDPOINT$1) &&\n            response.error &&\n            response.error.error === 'invalid_grant' &&\n            request.body.get('grant_type') === 'password') {\n            this.globalMessageService.add({\n                key: 'httpHandlers.badRequestPleaseLoginAgain',\n                params: {\n                    errorMessage: response.error.error_description || response.message || '',\n                },\n            }, GlobalMessageType.MSG_TYPE_ERROR);\n            this.globalMessageService.remove(GlobalMessageType.MSG_TYPE_CONFIRMATION);\n        }\n        else {\n            if (response.error &&\n                response.error.errors &&\n                response.error.errors instanceof Array) {\n                response.error.errors.forEach((error) => {\n                    let errorMessage;\n                    if (error.type === 'PasswordMismatchError') {\n                        // uses en translation error message instead of backend exception error\n                        // @todo: this condition could be removed if backend gives better message\n                        errorMessage = {\n                            key: 'httpHandlers.badRequestOldPasswordIncorrect',\n                        };\n                    }\n                    else if (error.subjectType === 'cart' &&\n                        error.reason === 'notFound') {\n                        errorMessage = { key: 'httpHandlers.cartNotFound' };\n                    }\n                    else if (error.type === 'ValidationError') {\n                        // build translation key in case of backend field validation error\n                        errorMessage = {\n                            key: `httpHandlers.validationErrors.${error.reason}.${error.subject}`,\n                        };\n                    }\n                    else {\n                        // this is currently showing up in case we have a page not found. It should be a 404.\n                        // see https://jira.hybris.com/browse/CMSX-8516\n                        errorMessage = { raw: error.message || '' };\n                    }\n                    this.globalMessageService.add(errorMessage, GlobalMessageType.MSG_TYPE_ERROR);\n                });\n            }\n        }\n    }\n};\nBadRequestHandler.ɵprov = ɵɵdefineInjectable({ factory: function BadRequestHandler_Factory() { return new BadRequestHandler(ɵɵinject(GlobalMessageService)); }, token: BadRequestHandler, providedIn: \"root\" });\nBadRequestHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], BadRequestHandler);\n\nlet ConflictHandler = class ConflictHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.CONFLICT;\n    }\n    handleError() {\n        this.globalMessageService.add({ key: 'httpHandlers.conflict' }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n};\nConflictHandler.ɵprov = ɵɵdefineInjectable({ factory: function ConflictHandler_Factory() { return new ConflictHandler(ɵɵinject(GlobalMessageService)); }, token: ConflictHandler, providedIn: \"root\" });\nConflictHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ConflictHandler);\n\nlet ForbiddenHandler = class ForbiddenHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.FORBIDDEN;\n    }\n    handleError() {\n        this.globalMessageService.add({ key: 'httpHandlers.forbidden' }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n};\nForbiddenHandler.ɵprov = ɵɵdefineInjectable({ factory: function ForbiddenHandler_Factory() { return new ForbiddenHandler(ɵɵinject(GlobalMessageService)); }, token: ForbiddenHandler, providedIn: \"root\" });\nForbiddenHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ForbiddenHandler);\n\nlet GatewayTimeoutHandler = class GatewayTimeoutHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.GATEWAY_TIMEOUT;\n    }\n    handleError() {\n        this.globalMessageService.add({ key: 'httpHandlers.gatewayTimeout' }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n};\nGatewayTimeoutHandler.ɵprov = ɵɵdefineInjectable({ factory: function GatewayTimeoutHandler_Factory() { return new GatewayTimeoutHandler(ɵɵinject(GlobalMessageService)); }, token: GatewayTimeoutHandler, providedIn: \"root\" });\nGatewayTimeoutHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], GatewayTimeoutHandler);\n\nlet InternalServerErrorHandler = class InternalServerErrorHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.INTERNAL_SERVER_ERROR;\n    }\n    handleError() {\n        this.globalMessageService.add({ key: 'httpHandlers.internalServerError' }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n};\nInternalServerErrorHandler.ɵprov = ɵɵdefineInjectable({ factory: function InternalServerErrorHandler_Factory() { return new InternalServerErrorHandler(ɵɵinject(GlobalMessageService)); }, token: InternalServerErrorHandler, providedIn: \"root\" });\nInternalServerErrorHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], InternalServerErrorHandler);\n\nlet NotFoundHandler = class NotFoundHandler extends HttpErrorHandler {\n    constructor() {\n        super(...arguments);\n        this.responseStatus = HttpResponseStatus.NOT_FOUND;\n    }\n    // empty error handler to avoid we fallabck to the unknown error handler\n    handleError() { }\n};\nNotFoundHandler.ɵprov = ɵɵdefineInjectable({ factory: function NotFoundHandler_Factory() { return new NotFoundHandler(ɵɵinject(GlobalMessageService)); }, token: NotFoundHandler, providedIn: \"root\" });\nNotFoundHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], NotFoundHandler);\n\nlet UnknownErrorHandler = class UnknownErrorHandler extends HttpErrorHandler {\n    constructor(globalMessageService) {\n        super(globalMessageService);\n        this.globalMessageService = globalMessageService;\n        this.responseStatus = HttpResponseStatus.UNKNOWN;\n    }\n    handleError() {\n        if (isDevMode()) {\n            console.warn(`Unknown http response error: ${this.responseStatus}`);\n        }\n    }\n};\nUnknownErrorHandler.ctorParameters = () => [\n    { type: GlobalMessageService }\n];\nUnknownErrorHandler.ɵprov = ɵɵdefineInjectable({ factory: function UnknownErrorHandler_Factory() { return new UnknownErrorHandler(ɵɵinject(GlobalMessageService)); }, token: UnknownErrorHandler, providedIn: \"root\" });\nUnknownErrorHandler = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UnknownErrorHandler);\n\nlet HttpErrorInterceptor = class HttpErrorInterceptor {\n    constructor(handlers) {\n        this.handlers = handlers;\n        // We reverse the handlers to allow for custom handlers\n        // that replace standard handlers\n        this.handlers.reverse();\n    }\n    intercept(request, next) {\n        return next.handle(request).pipe(catchError((response) => {\n            if (response instanceof HttpErrorResponse) {\n                this.handleErrorResponse(request, response);\n                return throwError(response);\n            }\n        }));\n    }\n    handleErrorResponse(request, response) {\n        const handler = this.getResponseHandler(response);\n        if (handler) {\n            handler.handleError(request, response);\n        }\n    }\n    /**\n     * return the error handler that matches the `HttpResponseStatus` code.\n     * If no handler is available, the UNKNOWN handler is returned.\n     */\n    getResponseHandler(response) {\n        const status = response.status;\n        let handler = this.handlers.find(h => h.responseStatus === status);\n        if (!handler) {\n            handler = this.handlers.find(h => h.responseStatus === HttpResponseStatus.UNKNOWN);\n        }\n        return handler;\n    }\n};\nHttpErrorInterceptor.ctorParameters = () => [\n    { type: Array, decorators: [{ type: Inject, args: [HttpErrorHandler,] }] }\n];\nHttpErrorInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function HttpErrorInterceptor_Factory() { return new HttpErrorInterceptor(ɵɵinject(HttpErrorHandler)); }, token: HttpErrorInterceptor, providedIn: \"root\" });\nHttpErrorInterceptor = __decorate([\n    Injectable({ providedIn: 'root' }),\n    __param(0, Inject(HttpErrorHandler))\n], HttpErrorInterceptor);\n\nconst errorHandlers = [\n    {\n        provide: HttpErrorHandler,\n        useExisting: UnknownErrorHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: BadGatewayHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: BadRequestHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: ConflictHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: ForbiddenHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: GatewayTimeoutHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: InternalServerErrorHandler,\n        multi: true,\n    },\n    {\n        provide: HttpErrorHandler,\n        useExisting: NotFoundHandler,\n        multi: true,\n    },\n];\nconst httpErrorInterceptors = [\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: HttpErrorInterceptor,\n        multi: true,\n    },\n];\n\nconst initialState$8 = {\n    entities: {},\n};\nfunction reducer$8(state = initialState$8, action) {\n    switch (action.type) {\n        case ADD_MESSAGE: {\n            const message = action.payload;\n            if (state.entities[message.type] === undefined) {\n                return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), { [message.type]: [message.text] }) });\n            }\n            else {\n                const currentMessages = state.entities[message.type];\n                return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), { [message.type]: [...currentMessages, message.text] }) });\n            }\n        }\n        case REMOVE_MESSAGE: {\n            const msgType = action.payload.type;\n            const msgIndex = action.payload.index;\n            if (Object.keys(state.entities).length === 0 ||\n                !state.entities[msgType]) {\n                return state;\n            }\n            const messages = [...state.entities[msgType]];\n            messages.splice(msgIndex, 1);\n            return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), { [msgType]: messages }) });\n        }\n        case REMOVE_MESSAGES_BY_TYPE: {\n            const entities = Object.assign(Object.assign({}, state.entities), { [action.payload]: [] });\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n    }\n    return state;\n}\n\nfunction getReducers$4() {\n    return reducer$8;\n}\nconst reducerToken$4 = new InjectionToken('GlobalMessageReducers');\nconst reducerProvider$4 = {\n    provide: reducerToken$4,\n    useFactory: getReducers$4,\n};\n\nlet GlobalMessageStoreModule = class GlobalMessageStoreModule {\n};\nGlobalMessageStoreModule = __decorate([\n    NgModule({\n        imports: [\n            StateModule,\n            StoreModule.forFeature(GLOBAL_MESSAGE_FEATURE, reducerToken$4),\n        ],\n        providers: [reducerProvider$4],\n    })\n], GlobalMessageStoreModule);\n\nfunction shallowEqualObjects(objA, objB) {\n    if (objA === objB) {\n        return true;\n    }\n    if (!objA || !objB) {\n        return false;\n    }\n    const aKeys = Object.keys(objA);\n    const bKeys = Object.keys(objB);\n    const aKeysLen = aKeys.length;\n    const bKeysLen = bKeys.length;\n    if (aKeysLen !== bKeysLen) {\n        return false;\n    }\n    for (let i = 0; i < aKeysLen; i++) {\n        const key = aKeys[i];\n        if (objA[key] !== objB[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction deepEqualObjects(objA, objB) {\n    if (objA === objB) {\n        return true; // if both objA and objB are null or undefined and exactly the same\n    }\n    else if (!(objA instanceof Object) || !(objB instanceof Object)) {\n        return false; // if they are not strictly equal, they both need to be Objects\n    }\n    else if (objA.constructor !== objB.constructor) {\n        // they must have the exact same prototype chain, the closest we can do is\n        // test their constructor.\n        return false;\n    }\n    else {\n        for (const key in objA) {\n            if (!objA.hasOwnProperty(key)) {\n                continue; // other properties were tested using objA.constructor === y.constructor\n            }\n            if (!objB.hasOwnProperty(key)) {\n                return false; // allows to compare objA[ key ] and objB[ key ] when set to undefined\n            }\n            if (objA[key] === objB[key]) {\n                continue; // if they have the same strict value or identity then they are equal\n            }\n            if (typeof objA[key] !== 'object') {\n                return false; // Numbers, Strings, Functions, Booleans must be strictly equal\n            }\n            if (!deepEqualObjects(objA[key], objB[key])) {\n                return false;\n            }\n        }\n        for (const key in objB) {\n            if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction countOfDeepEqualObjects(obj, arr) {\n    return arr.reduce((acc, curr) => {\n        if (deepEqualObjects(obj, curr)) {\n            acc++;\n        }\n        return acc;\n    }, 0);\n}\nfunction indexOfFirstOccurrence(obj, arr) {\n    for (let index = 0; index < arr.length; index++) {\n        if (deepEqualObjects(arr[index], obj)) {\n            return index;\n        }\n    }\n}\n\nlet GlobalMessageEffect = class GlobalMessageEffect {\n    constructor(actions$, store, config, platformId) {\n        this.actions$ = actions$;\n        this.store = store;\n        this.config = config;\n        this.platformId = platformId;\n        this.removeDuplicated$ = this.actions$.pipe(ofType(ADD_MESSAGE), pluck('payload'), switchMap((message) => of(message.text).pipe(withLatestFrom(this.store.pipe(select(getGlobalMessageEntitiesByType(message.type)))), filter(([text, messages]) => countOfDeepEqualObjects(text, messages) > 1), map(([text, messages]) => new RemoveMessage({\n            type: message.type,\n            index: indexOfFirstOccurrence(text, messages),\n        })))));\n        this.hideAfterDelay$ = isPlatformBrowser(this.platformId) // we don't want to run this logic when doing SSR\n            ? this.actions$.pipe(ofType(ADD_MESSAGE), pluck('payload'), concatMap((message) => {\n                const config = this.config.globalMessages[message.type];\n                return this.store.pipe(select(getGlobalMessageCountByType(message.type)), take(1), filter((count) => ((config && config.timeout !== undefined) || message.timeout) &&\n                    count &&\n                    count > 0), delay(message.timeout || config.timeout), switchMap(() => of(new RemoveMessage({\n                    type: message.type,\n                    index: 0,\n                }))));\n            }))\n            : EMPTY;\n    }\n};\nGlobalMessageEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: Store },\n    { type: GlobalMessageConfig },\n    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n__decorate([\n    Effect()\n], GlobalMessageEffect.prototype, \"removeDuplicated$\", void 0);\n__decorate([\n    Effect()\n], GlobalMessageEffect.prototype, \"hideAfterDelay$\", void 0);\nGlobalMessageEffect = __decorate([\n    Injectable(),\n    __param(3, Inject(PLATFORM_ID))\n], GlobalMessageEffect);\n\nfunction defaultGlobalMessageConfigFactory() {\n    return {\n        globalMessages: {\n            [GlobalMessageType.MSG_TYPE_CONFIRMATION]: {\n                timeout: 3000,\n            },\n            [GlobalMessageType.MSG_TYPE_INFO]: {\n                timeout: 3000,\n            },\n            [GlobalMessageType.MSG_TYPE_ERROR]: {\n                timeout: 7000,\n            },\n            [GlobalMessageType.MSG_TYPE_WARNING]: {\n                timeout: 7000,\n            },\n        },\n    };\n}\n\nvar GlobalMessageModule_1;\nlet GlobalMessageModule = GlobalMessageModule_1 = class GlobalMessageModule {\n    static forRoot() {\n        return {\n            ngModule: GlobalMessageModule_1,\n            providers: [...errorHandlers, ...httpErrorInterceptors],\n        };\n    }\n};\nGlobalMessageModule = GlobalMessageModule_1 = __decorate([\n    NgModule({\n        imports: [\n            GlobalMessageStoreModule,\n            EffectsModule.forFeature([GlobalMessageEffect]),\n            ConfigModule.withConfigFactory(defaultGlobalMessageConfigFactory),\n        ],\n        providers: [\n            GlobalMessageService,\n            { provide: GlobalMessageConfig, useExisting: Config },\n        ],\n    })\n], GlobalMessageModule);\n\nlet CustomerSupportAgentErrorHandlingService = class CustomerSupportAgentErrorHandlingService {\n    constructor(asmAuthService, globalMessageService) {\n        this.asmAuthService = asmAuthService;\n        this.globalMessageService = globalMessageService;\n    }\n    terminateCustomerSupportAgentExpiredSession() {\n        this.asmAuthService.logoutCustomerSupportAgent();\n        this.globalMessageService.add({\n            key: 'asm.csagentTokenExpired',\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n};\nCustomerSupportAgentErrorHandlingService.ctorParameters = () => [\n    { type: AsmAuthService },\n    { type: GlobalMessageService }\n];\nCustomerSupportAgentErrorHandlingService.ɵprov = ɵɵdefineInjectable({ factory: function CustomerSupportAgentErrorHandlingService_Factory() { return new CustomerSupportAgentErrorHandlingService(ɵɵinject(AsmAuthService), ɵɵinject(GlobalMessageService)); }, token: CustomerSupportAgentErrorHandlingService, providedIn: \"root\" });\nCustomerSupportAgentErrorHandlingService = __decorate([\n    Injectable({ providedIn: 'root' })\n], CustomerSupportAgentErrorHandlingService);\n\nlet CustomerSupportAgentAuthErrorInterceptor = class CustomerSupportAgentAuthErrorInterceptor {\n    constructor(csagentErrorHandlingService) {\n        this.csagentErrorHandlingService = csagentErrorHandlingService;\n    }\n    intercept(request, next) {\n        const isCustomerSupportAgentRequest = this.isCustomerSupportAgentRequest(request);\n        if (isCustomerSupportAgentRequest) {\n            request = InterceptorUtil.removeHeader(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request);\n        }\n        return next.handle(request).pipe(catchError((errResponse) => {\n            if (errResponse instanceof HttpErrorResponse) {\n                // Unauthorized\n                if (isCustomerSupportAgentRequest && errResponse.status === 401) {\n                    this.csagentErrorHandlingService.terminateCustomerSupportAgentExpiredSession();\n                    return of(undefined);\n                }\n            }\n            return throwError(errResponse);\n        }));\n    }\n    isCustomerSupportAgentRequest(request) {\n        const isRequestMapping = InterceptorUtil.getInterceptorParam(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request.headers);\n        return Boolean(isRequestMapping);\n    }\n};\nCustomerSupportAgentAuthErrorInterceptor.ctorParameters = () => [\n    { type: CustomerSupportAgentErrorHandlingService }\n];\nCustomerSupportAgentAuthErrorInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function CustomerSupportAgentAuthErrorInterceptor_Factory() { return new CustomerSupportAgentAuthErrorInterceptor(ɵɵinject(CustomerSupportAgentErrorHandlingService)); }, token: CustomerSupportAgentAuthErrorInterceptor, providedIn: \"root\" });\nCustomerSupportAgentAuthErrorInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], CustomerSupportAgentAuthErrorInterceptor);\n\nconst interceptors$2 = [\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: CustomerSupportAgentTokenInterceptor,\n        multi: true,\n    },\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: CustomerSupportAgentAuthErrorInterceptor,\n        multi: true,\n    },\n];\n\nvar AsmModule_1;\nlet AsmModule = AsmModule_1 = class AsmModule {\n    static forRoot() {\n        return {\n            ngModule: AsmModule_1,\n            providers: [{ provide: AsmConfig, useExisting: Config }, ...interceptors$2],\n        };\n    }\n};\nAsmModule = AsmModule_1 = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            AsmStoreModule,\n            ConfigModule.withConfig(defaultAsmConfig),\n        ],\n    })\n], AsmModule);\n\nlet AsmService = class AsmService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Search for customers\n     * @param options\n     */\n    customerSearch(options) {\n        this.store.dispatch(new CustomerSearch(options));\n    }\n    /**\n     * Reset the customer search result data to the initial state.\n     */\n    customerSearchReset() {\n        this.store.dispatch(new CustomerSearchReset());\n    }\n    /**\n     * Returns the customer search result data.\n     */\n    getCustomerSearchResults() {\n        return this.store.pipe(select(getCustomerSearchResults));\n    }\n    /**\n     * Returns the customer search result loading status.\n     */\n    getCustomerSearchResultsLoading() {\n        return this.store.pipe(select(getCustomerSearchResultsLoading));\n    }\n    /**\n     * Updates the state of the ASM UI\n     */\n    updateAsmUiState(asmUi) {\n        this.store.dispatch(new AsmUiUpdate(asmUi));\n    }\n    /**\n     * Get the state of the ASM UI\n     */\n    getAsmUiState() {\n        return this.store.pipe(select(getAsmUi));\n    }\n};\nAsmService.ctorParameters = () => [\n    { type: Store }\n];\nAsmService.ɵprov = ɵɵdefineInjectable({ factory: function AsmService_Factory() { return new AsmService(ɵɵinject(Store)); }, token: AsmService, providedIn: \"root\" });\nAsmService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], AsmService);\n\nclass PageMetaResolver {\n    getScore(page) {\n        let score = 0;\n        if (this.pageType) {\n            score += page.type === this.pageType ? 1 : -1;\n        }\n        if (this.pageTemplate) {\n            score += page.template === this.pageTemplate ? 1 : -1;\n        }\n        return score;\n    }\n}\n\n// Email Standard RFC 5322:\nconst EMAIL_PATTERN = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // tslint:disable-line\nconst PASSWORD_PATTERN = /^(?=.*?[A-Z])(?=.*?[0-9])(?=.*?[!@#$%^*()_\\-+{};:.,]).{6,}$/;\n\nconst CART_FEATURE = 'cart';\nconst CART_DATA = '[Cart] Cart Data';\nconst ADD_VOUCHER_PROCESS_ID = 'addVoucher';\n\nconst getCartContentSelector = (state) => state.content;\nconst ɵ0$v = getCartContentSelector;\nconst getCartRefreshSelector = (state) => state.refresh;\nconst ɵ1$n = getCartRefreshSelector;\nconst getCartEntriesSelector = (state) => state.entries;\nconst ɵ2$g = getCartEntriesSelector;\nconst getCartMergeCompleteSelector = (state) => state.cartMergeComplete;\nconst ɵ3$9 = getCartMergeCompleteSelector;\nconst getCartsState = createFeatureSelector(CART_FEATURE);\nconst ɵ4$2 = (cartsState) => cartsState.active;\nconst getActiveCartState = createSelector(getCartsState, ɵ4$2);\nconst ɵ5$2 = state => loaderValueSelector(state);\nconst getCartState = createSelector(getActiveCartState, ɵ5$2);\nconst getCartContent = createSelector(getCartState, getCartContentSelector);\nconst getCartRefresh = createSelector(getCartState, getCartRefreshSelector);\nconst ɵ6 = state => (loaderSuccessSelector(state) &&\n    !loaderLoadingSelector(state) &&\n    !loaderValueSelector(state).refresh) ||\n    (loaderErrorSelector(state) &&\n        !loaderLoadingSelector(state) &&\n        !loaderValueSelector(state).refresh);\nconst getCartLoaded = createSelector(getActiveCartState, ɵ6);\nconst ɵ7 = state => loaderLoadingSelector(state);\nconst getCartLoading = createSelector(getActiveCartState, ɵ7);\nconst getCartMergeComplete = createSelector(getCartState, getCartMergeCompleteSelector);\nconst getCartEntriesMap = createSelector(getCartState, getCartEntriesSelector);\nconst getCartEntrySelectorFactory = (productCode) => {\n    return createSelector(getCartEntriesMap, entries => {\n        if (entries) {\n            return entries[productCode];\n        }\n    });\n};\nconst ɵ8 = entities => {\n    return Object.keys(entities).map(code => entities[code]);\n};\nconst getCartEntries = createSelector(getCartEntriesMap, ɵ8);\nconst ɵ9 = content => content.user;\nconst getCartUser = createSelector(getCartContent, ɵ9);\n\n\n\nvar cartGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getCartsState: getCartsState,\n    getActiveCartState: getActiveCartState,\n    getCartState: getCartState,\n    getCartContent: getCartContent,\n    getCartRefresh: getCartRefresh,\n    getCartLoaded: getCartLoaded,\n    getCartLoading: getCartLoading,\n    getCartMergeComplete: getCartMergeComplete,\n    getCartEntriesMap: getCartEntriesMap,\n    getCartEntrySelectorFactory: getCartEntrySelectorFactory,\n    getCartEntries: getCartEntries,\n    getCartUser: getCartUser,\n    ɵ0: ɵ0$v,\n    ɵ1: ɵ1$n,\n    ɵ2: ɵ2$g,\n    ɵ3: ɵ3$9,\n    ɵ4: ɵ4$2,\n    ɵ5: ɵ5$2,\n    ɵ6: ɵ6,\n    ɵ7: ɵ7,\n    ɵ8: ɵ8,\n    ɵ9: ɵ9\n});\n\nconst MULTI_CART_FEATURE = 'multi-cart';\nconst MULTI_CART_DATA = '[Multi Cart] Multi Cart Data';\n\nconst getMultiCartState = createFeatureSelector(MULTI_CART_FEATURE);\nconst ɵ0$w = (state) => state.carts;\nconst getMultiCartEntities = createSelector(getMultiCartState, ɵ0$w);\nconst getCartEntitySelectorFactory = (cartId) => {\n    return createSelector(getMultiCartEntities, (state) => entityProcessesLoaderStateSelector(state, cartId));\n};\nconst getCartSelectorFactory = (cartId) => {\n    return createSelector(getMultiCartEntities, (state) => entityValueSelector(state, cartId));\n};\nconst getCartIsStableSelectorFactory = (cartId) => {\n    return createSelector(getMultiCartEntities, (state) => entityIsStableSelector(state, cartId));\n};\nconst getCartHasPendingProcessesSelectorFactory = (cartId) => {\n    return createSelector(getMultiCartEntities, (state) => entityHasPendingProcessesSelector(state, cartId));\n};\nconst getCartEntriesSelectorFactory = (cartId) => {\n    return createSelector(getCartSelectorFactory(cartId), (state) => {\n        return state && state.entries ? state.entries : [];\n    });\n};\nconst getCartEntrySelectorFactory$1 = (cartId, productCode) => {\n    return createSelector(getCartEntriesSelectorFactory(cartId), (state) => {\n        return state\n            ? state.find(entry => entry.product.code === productCode)\n            : undefined;\n    });\n};\nconst ɵ1$o = (state) => state.active;\nconst getActiveCartId = createSelector(getMultiCartState, ɵ1$o);\nconst ɵ2$h = (state) => state.wishList;\nconst getWishListId = createSelector(getMultiCartState, ɵ2$h);\n\n\n\nvar multiCartGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getMultiCartState: getMultiCartState,\n    getMultiCartEntities: getMultiCartEntities,\n    getCartEntitySelectorFactory: getCartEntitySelectorFactory,\n    getCartSelectorFactory: getCartSelectorFactory,\n    getCartIsStableSelectorFactory: getCartIsStableSelectorFactory,\n    getCartHasPendingProcessesSelectorFactory: getCartHasPendingProcessesSelectorFactory,\n    getCartEntriesSelectorFactory: getCartEntriesSelectorFactory,\n    getCartEntrySelectorFactory: getCartEntrySelectorFactory$1,\n    getActiveCartId: getActiveCartId,\n    getWishListId: getWishListId,\n    ɵ0: ɵ0$w,\n    ɵ1: ɵ1$o,\n    ɵ2: ɵ2$h\n});\n\nfunction getCartIdByUserId(cart, userId) {\n    if (userId === OCC_USER_ID_ANONYMOUS) {\n        return cart.guid;\n    }\n    return cart.code;\n}\n/**\n * What is a temporary cart?\n * - frontend only cart entity!\n * - can be identified in store by `temp-` prefix with some unique id (multiple carts can be created at the same time eg. active cart, wishlist)\n *\n * Why we need temporary carts?\n * - to have information about cart creation process (meta flags: loading, error - for showing loader, error message)\n * - to know if there is currently a cart creation process in progress (eg. so, we don't create more than one active cart at the same time)\n * - cart identifiers are created in the backend, so those are only known after cart is created\n *\n * Temporary cart lifecycle\n * - create cart method invoked\n * - new `temp-${uuid}` cart is created with `loading=true` state\n * - backend returns created cart\n * - normal cart entity is saved under correct id (eg. for logged user under cart `code` key)\n * - temporary cart value is set to backend response (anyone observing this cart can read code/guid from it and switch selector to normal cart)\n * - in next tick temporary cart is removed\n */\nfunction isTempCartId(cartId) {\n    return cartId.startsWith('temp-');\n}\n\nconst CREATE_CART = '[Cart] Create Cart';\nconst CREATE_CART_FAIL = '[Cart] Create Cart Fail';\nconst CREATE_CART_SUCCESS = '[Cart] Create Cart Success';\nconst LOAD_CART = '[Cart] Load Cart';\nconst LOAD_CART_FAIL = '[Cart] Load Cart Fail';\nconst LOAD_CART_SUCCESS = '[Cart] Load Cart Success';\nconst ADD_EMAIL_TO_CART = '[Cart] Add Email to Cart';\nconst ADD_EMAIL_TO_CART_FAIL = '[Cart] Add Email to Cart Fail';\nconst ADD_EMAIL_TO_CART_SUCCESS = '[Cart] Add Email to Cart Success';\nconst MERGE_CART = '[Cart] Merge Cart';\nconst MERGE_CART_SUCCESS = '[Cart] Merge Cart Success';\nconst RESET_CART_DETAILS = '[Cart] Reset Cart Details';\nconst CLEAR_EXPIRED_COUPONS = '[Cart] Clear Expired Coupon';\nconst CLEAR_CART = '[Cart] Clear Cart';\nconst DELETE_CART = '[Cart] Delete Cart';\nconst DELETE_CART_FAIL = '[Cart] Delete Cart Fail';\nclass CreateCart extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CREATE_CART;\n    }\n}\nclass CreateCartFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = CREATE_CART_FAIL;\n    }\n}\nclass CreateCartSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CREATE_CART_SUCCESS;\n    }\n}\nclass AddEmailToCart extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = ADD_EMAIL_TO_CART;\n    }\n}\nclass AddEmailToCartFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = ADD_EMAIL_TO_CART_FAIL;\n    }\n}\nclass AddEmailToCartSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = ADD_EMAIL_TO_CART_SUCCESS;\n    }\n}\nclass LoadCart extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = LOAD_CART;\n    }\n}\nclass LoadCartFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = LOAD_CART_FAIL;\n    }\n}\nclass LoadCartSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = LOAD_CART_SUCCESS;\n    }\n}\nclass MergeCart {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = MERGE_CART;\n    }\n}\nclass MergeCartSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = MERGE_CART_SUCCESS;\n    }\n}\nclass ResetCartDetails {\n    constructor() {\n        this.type = RESET_CART_DETAILS;\n    }\n}\nclass ClearExpiredCoupons {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_EXPIRED_COUPONS;\n    }\n}\nclass ClearCart extends LoaderResetAction {\n    constructor() {\n        super(CART_DATA);\n        this.type = CLEAR_CART;\n    }\n}\nclass DeleteCart extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = DELETE_CART;\n    }\n}\nclass DeleteCartFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = DELETE_CART_FAIL;\n    }\n}\n\nconst CART_ADD_ENTRY = '[Cart-entry] Add Entry';\nconst CART_ADD_ENTRY_SUCCESS = '[Cart-entry] Add Entry Success';\nconst CART_ADD_ENTRY_FAIL = '[Cart-entry] Add Entry Fail';\nconst CART_REMOVE_ENTRY = '[Cart-entry] Remove Entry';\nconst CART_REMOVE_ENTRY_SUCCESS = '[Cart-entry] Remove Entry Success';\nconst CART_REMOVE_ENTRY_FAIL = '[Cart-entry] Remove Entry Fail';\nconst CART_UPDATE_ENTRY = '[Cart-entry] Update Entry';\nconst CART_UPDATE_ENTRY_SUCCESS = '[Cart-entry] Update Entry Success';\nconst CART_UPDATE_ENTRY_FAIL = '[Cart-entry] Update Entry Fail';\nclass CartAddEntry extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_ADD_ENTRY;\n    }\n}\nclass CartAddEntrySuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_ADD_ENTRY_SUCCESS;\n    }\n}\nclass CartAddEntryFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = CART_ADD_ENTRY_FAIL;\n    }\n}\nclass CartRemoveEntry extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_REMOVE_ENTRY;\n    }\n}\nclass CartRemoveEntrySuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_REMOVE_ENTRY_SUCCESS;\n    }\n}\nclass CartRemoveEntryFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = CART_REMOVE_ENTRY_FAIL;\n    }\n}\nclass CartUpdateEntry extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_UPDATE_ENTRY;\n    }\n}\nclass CartUpdateEntrySuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_UPDATE_ENTRY_SUCCESS;\n    }\n}\nclass CartUpdateEntryFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = CART_UPDATE_ENTRY_FAIL;\n    }\n}\n\nconst CART_ADD_VOUCHER = '[Cart-voucher] Add Cart Vouchers';\nconst CART_ADD_VOUCHER_FAIL = '[Cart-voucher] Add Cart Voucher Fail';\nconst CART_ADD_VOUCHER_SUCCESS = '[Cart-voucher] Add Cart Voucher Success';\nconst CART_RESET_ADD_VOUCHER = '[Cart-voucher] Reset Add Cart Voucher';\nconst CART_REMOVE_VOUCHER = '[Cart-voucher] Remove Cart Voucher';\nconst CART_REMOVE_VOUCHER_FAIL = '[Cart-voucher] Remove Cart Voucher Fail';\nconst CART_REMOVE_VOUCHER_SUCCESS = '[Cart-voucher] Remove Cart Voucher Success';\n// Adding cart voucher actions\nclass CartAddVoucher extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);\n        this.payload = payload;\n        this.type = CART_ADD_VOUCHER;\n    }\n}\nclass CartAddVoucherFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = CART_ADD_VOUCHER_FAIL;\n    }\n}\nclass CartAddVoucherSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);\n        this.payload = payload;\n        this.type = CART_ADD_VOUCHER_SUCCESS;\n    }\n}\nclass CartResetAddVoucher extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);\n        this.type = CART_RESET_ADD_VOUCHER;\n    }\n}\n// Deleting cart voucher\nclass CartRemoveVoucher extends LoaderLoadAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_REMOVE_VOUCHER;\n    }\n}\nclass CartRemoveVoucherFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CART_DATA, payload);\n        this.payload = payload;\n        this.type = CART_REMOVE_VOUCHER_FAIL;\n    }\n}\nclass CartRemoveVoucherSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CART_DATA);\n        this.payload = payload;\n        this.type = CART_REMOVE_VOUCHER_SUCCESS;\n    }\n}\n\nconst REMOVE_TEMP_CART = '[Multi Cart] Remove Temp Cart';\nconst CREATE_MULTI_CART = '[Multi Cart] Create Cart';\nconst CREATE_MULTI_CART_FAIL = '[Multi Cart] Create Cart Fail';\nconst CREATE_MULTI_CART_SUCCESS = '[Multi Cart] Create Cart Success';\nconst LOAD_MULTI_CART = '[Multi Cart] Load Cart';\nconst LOAD_MULTI_CART_FAIL = '[Multi Cart] Load Cart Fail';\nconst LOAD_MULTI_CART_SUCCESS = '[Multi Cart] Load Cart Success';\nconst MERGE_MULTI_CART = '[Multi Cart] Merge Cart';\nconst MERGE_MULTI_CART_SUCCESS = '[Multi Cart] Merge Cart Success';\nconst RESET_MULTI_CART_DETAILS = '[Multi Cart] Reset Cart Details';\nconst SET_TEMP_CART = '[Multi Cart] Set Temp Cart';\nconst REMOVE_CART = '[Multi Cart] Remove Cart';\nconst ADD_EMAIL_TO_MULTI_CART = '[Multi Cart] Add Email';\nconst ADD_EMAIL_TO_MULTI_CART_FAIL = '[Multi Cart] Add Email Fail';\nconst ADD_EMAIL_TO_MULTI_CART_SUCCESS = '[Multi Cart] Add Email Success';\nconst CART_PROCESSES_INCREMENT = '[Multi Cart] Cart Processes Increment';\nconst CART_PROCESSES_DECREMENT = '[Multi Cart] Cart Processes Decrement';\n/**\n * To keep track of cart creation process we use cart with `temp-${uuid}` id.\n * After creating cart we switch to entity with `code` or `guid`.\n * We need `temp-${uuid}` cart entities for loading/error state.\n */\nclass RemoveTempCart extends EntityRemoveAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.tempCartId);\n        this.payload = payload;\n        this.type = REMOVE_TEMP_CART;\n    }\n}\nclass SetTempCart extends EntitySuccessAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.tempCartId, payload.cart);\n        this.payload = payload;\n        this.type = SET_TEMP_CART;\n    }\n}\nclass CreateMultiCart extends EntityLoadAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.tempCartId);\n        this.payload = payload;\n        this.type = CREATE_MULTI_CART;\n    }\n}\nclass CreateMultiCartFail extends EntityFailAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.tempCartId);\n        this.payload = payload;\n        this.type = CREATE_MULTI_CART_FAIL;\n    }\n}\nclass CreateMultiCartSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));\n        this.payload = payload;\n        this.type = CREATE_MULTI_CART_SUCCESS;\n    }\n}\nclass LoadMultiCart extends EntityLoadAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.cartId);\n        this.payload = payload;\n        this.type = LOAD_MULTI_CART;\n    }\n}\nclass LoadMultiCartFail extends EntityFailAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.cartId, payload.error);\n        this.payload = payload;\n        this.type = LOAD_MULTI_CART_FAIL;\n    }\n}\nclass LoadMultiCartSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));\n        this.payload = payload;\n        this.type = LOAD_MULTI_CART_SUCCESS;\n    }\n}\nclass MergeMultiCart {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = MERGE_MULTI_CART;\n    }\n}\nclass MergeMultiCartSuccess extends EntityRemoveAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.oldCartId);\n        this.payload = payload;\n        this.type = MERGE_MULTI_CART_SUCCESS;\n    }\n}\nclass ResetMultiCartDetails extends EntityProcessesLoaderResetAction {\n    constructor() {\n        super(MULTI_CART_FEATURE, undefined);\n        this.type = RESET_MULTI_CART_DETAILS;\n    }\n}\nclass RemoveCart extends EntityRemoveAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload);\n        this.payload = payload;\n        this.type = REMOVE_CART;\n    }\n}\nclass AddEmailToMultiCart extends EntityLoadAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.cartId);\n        this.payload = payload;\n        this.type = ADD_EMAIL_TO_MULTI_CART;\n    }\n}\nclass AddEmailToMultiCartFail extends EntityFailAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.cartId, payload.error);\n        this.payload = payload;\n        this.type = ADD_EMAIL_TO_MULTI_CART_FAIL;\n    }\n}\nclass AddEmailToMultiCartSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.cartId);\n        this.payload = payload;\n        this.type = ADD_EMAIL_TO_MULTI_CART_SUCCESS;\n    }\n}\nclass CartProcessesIncrement extends EntityProcessesIncrementAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload);\n        this.payload = payload;\n        this.type = CART_PROCESSES_INCREMENT;\n    }\n}\nclass CartProcessesDecrement extends EntityProcessesDecrementAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload);\n        this.payload = payload;\n        this.type = CART_PROCESSES_DECREMENT;\n    }\n}\n\nconst CREATE_WISH_LIST = '[Wish List] Create Wish List';\nconst CREATE_WISH_LIST_FAIL = '[Wish List] Create Wish List Fail';\nconst CREATE_WISH_LIST_SUCCESS = '[Wish List] Create Wish List Success';\nconst LOAD_WISH_LIST = '[Wish List] Load Wish List';\nconst LOAD_WISH_LIST_SUCCESS = '[Wish List] Load Wish List Success';\nconst RESET_WISH_LIST_DETAILS = '[Wish List] Reset Wish List';\nclass CreateWishList {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CREATE_WISH_LIST;\n    }\n}\nclass CreateWishListSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));\n        this.payload = payload;\n        this.type = CREATE_WISH_LIST_SUCCESS;\n    }\n}\nclass CreateWishListFail extends EntityFailAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, payload.cartId, payload.error);\n        this.payload = payload;\n        this.type = CREATE_WISH_LIST_FAIL;\n    }\n}\nclass LoadWishList {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_WISH_LIST;\n    }\n}\nclass LoadWishListSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));\n        this.payload = payload;\n        this.type = LOAD_WISH_LIST_SUCCESS;\n    }\n}\n\n\n\nvar cartGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CART_ADD_ENTRY: CART_ADD_ENTRY,\n    CART_ADD_ENTRY_SUCCESS: CART_ADD_ENTRY_SUCCESS,\n    CART_ADD_ENTRY_FAIL: CART_ADD_ENTRY_FAIL,\n    CART_REMOVE_ENTRY: CART_REMOVE_ENTRY,\n    CART_REMOVE_ENTRY_SUCCESS: CART_REMOVE_ENTRY_SUCCESS,\n    CART_REMOVE_ENTRY_FAIL: CART_REMOVE_ENTRY_FAIL,\n    CART_UPDATE_ENTRY: CART_UPDATE_ENTRY,\n    CART_UPDATE_ENTRY_SUCCESS: CART_UPDATE_ENTRY_SUCCESS,\n    CART_UPDATE_ENTRY_FAIL: CART_UPDATE_ENTRY_FAIL,\n    CartAddEntry: CartAddEntry,\n    CartAddEntrySuccess: CartAddEntrySuccess,\n    CartAddEntryFail: CartAddEntryFail,\n    CartRemoveEntry: CartRemoveEntry,\n    CartRemoveEntrySuccess: CartRemoveEntrySuccess,\n    CartRemoveEntryFail: CartRemoveEntryFail,\n    CartUpdateEntry: CartUpdateEntry,\n    CartUpdateEntrySuccess: CartUpdateEntrySuccess,\n    CartUpdateEntryFail: CartUpdateEntryFail,\n    CART_ADD_VOUCHER: CART_ADD_VOUCHER,\n    CART_ADD_VOUCHER_FAIL: CART_ADD_VOUCHER_FAIL,\n    CART_ADD_VOUCHER_SUCCESS: CART_ADD_VOUCHER_SUCCESS,\n    CART_RESET_ADD_VOUCHER: CART_RESET_ADD_VOUCHER,\n    CART_REMOVE_VOUCHER: CART_REMOVE_VOUCHER,\n    CART_REMOVE_VOUCHER_FAIL: CART_REMOVE_VOUCHER_FAIL,\n    CART_REMOVE_VOUCHER_SUCCESS: CART_REMOVE_VOUCHER_SUCCESS,\n    CartAddVoucher: CartAddVoucher,\n    CartAddVoucherFail: CartAddVoucherFail,\n    CartAddVoucherSuccess: CartAddVoucherSuccess,\n    CartResetAddVoucher: CartResetAddVoucher,\n    CartRemoveVoucher: CartRemoveVoucher,\n    CartRemoveVoucherFail: CartRemoveVoucherFail,\n    CartRemoveVoucherSuccess: CartRemoveVoucherSuccess,\n    CREATE_CART: CREATE_CART,\n    CREATE_CART_FAIL: CREATE_CART_FAIL,\n    CREATE_CART_SUCCESS: CREATE_CART_SUCCESS,\n    LOAD_CART: LOAD_CART,\n    LOAD_CART_FAIL: LOAD_CART_FAIL,\n    LOAD_CART_SUCCESS: LOAD_CART_SUCCESS,\n    ADD_EMAIL_TO_CART: ADD_EMAIL_TO_CART,\n    ADD_EMAIL_TO_CART_FAIL: ADD_EMAIL_TO_CART_FAIL,\n    ADD_EMAIL_TO_CART_SUCCESS: ADD_EMAIL_TO_CART_SUCCESS,\n    MERGE_CART: MERGE_CART,\n    MERGE_CART_SUCCESS: MERGE_CART_SUCCESS,\n    RESET_CART_DETAILS: RESET_CART_DETAILS,\n    CLEAR_EXPIRED_COUPONS: CLEAR_EXPIRED_COUPONS,\n    CLEAR_CART: CLEAR_CART,\n    DELETE_CART: DELETE_CART,\n    DELETE_CART_FAIL: DELETE_CART_FAIL,\n    CreateCart: CreateCart,\n    CreateCartFail: CreateCartFail,\n    CreateCartSuccess: CreateCartSuccess,\n    AddEmailToCart: AddEmailToCart,\n    AddEmailToCartFail: AddEmailToCartFail,\n    AddEmailToCartSuccess: AddEmailToCartSuccess,\n    LoadCart: LoadCart,\n    LoadCartFail: LoadCartFail,\n    LoadCartSuccess: LoadCartSuccess,\n    MergeCart: MergeCart,\n    MergeCartSuccess: MergeCartSuccess,\n    ResetCartDetails: ResetCartDetails,\n    ClearExpiredCoupons: ClearExpiredCoupons,\n    ClearCart: ClearCart,\n    DeleteCart: DeleteCart,\n    DeleteCartFail: DeleteCartFail,\n    REMOVE_TEMP_CART: REMOVE_TEMP_CART,\n    CREATE_MULTI_CART: CREATE_MULTI_CART,\n    CREATE_MULTI_CART_FAIL: CREATE_MULTI_CART_FAIL,\n    CREATE_MULTI_CART_SUCCESS: CREATE_MULTI_CART_SUCCESS,\n    LOAD_MULTI_CART: LOAD_MULTI_CART,\n    LOAD_MULTI_CART_FAIL: LOAD_MULTI_CART_FAIL,\n    LOAD_MULTI_CART_SUCCESS: LOAD_MULTI_CART_SUCCESS,\n    MERGE_MULTI_CART: MERGE_MULTI_CART,\n    MERGE_MULTI_CART_SUCCESS: MERGE_MULTI_CART_SUCCESS,\n    RESET_MULTI_CART_DETAILS: RESET_MULTI_CART_DETAILS,\n    SET_TEMP_CART: SET_TEMP_CART,\n    REMOVE_CART: REMOVE_CART,\n    ADD_EMAIL_TO_MULTI_CART: ADD_EMAIL_TO_MULTI_CART,\n    ADD_EMAIL_TO_MULTI_CART_FAIL: ADD_EMAIL_TO_MULTI_CART_FAIL,\n    ADD_EMAIL_TO_MULTI_CART_SUCCESS: ADD_EMAIL_TO_MULTI_CART_SUCCESS,\n    CART_PROCESSES_INCREMENT: CART_PROCESSES_INCREMENT,\n    CART_PROCESSES_DECREMENT: CART_PROCESSES_DECREMENT,\n    RemoveTempCart: RemoveTempCart,\n    SetTempCart: SetTempCart,\n    CreateMultiCart: CreateMultiCart,\n    CreateMultiCartFail: CreateMultiCartFail,\n    CreateMultiCartSuccess: CreateMultiCartSuccess,\n    LoadMultiCart: LoadMultiCart,\n    LoadMultiCartFail: LoadMultiCartFail,\n    LoadMultiCartSuccess: LoadMultiCartSuccess,\n    MergeMultiCart: MergeMultiCart,\n    MergeMultiCartSuccess: MergeMultiCartSuccess,\n    ResetMultiCartDetails: ResetMultiCartDetails,\n    RemoveCart: RemoveCart,\n    AddEmailToMultiCart: AddEmailToMultiCart,\n    AddEmailToMultiCartFail: AddEmailToMultiCartFail,\n    AddEmailToMultiCartSuccess: AddEmailToMultiCartSuccess,\n    CartProcessesIncrement: CartProcessesIncrement,\n    CartProcessesDecrement: CartProcessesDecrement,\n    CREATE_WISH_LIST: CREATE_WISH_LIST,\n    CREATE_WISH_LIST_FAIL: CREATE_WISH_LIST_FAIL,\n    CREATE_WISH_LIST_SUCCESS: CREATE_WISH_LIST_SUCCESS,\n    LOAD_WISH_LIST: LOAD_WISH_LIST,\n    LOAD_WISH_LIST_SUCCESS: LOAD_WISH_LIST_SUCCESS,\n    RESET_WISH_LIST_DETAILS: RESET_WISH_LIST_DETAILS,\n    CreateWishList: CreateWishList,\n    CreateWishListSuccess: CreateWishListSuccess,\n    CreateWishListFail: CreateWishListFail,\n    LoadWishList: LoadWishList,\n    LoadWishListSuccess: LoadWishListSuccess\n});\n\nlet MultiCartService = class MultiCartService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Returns cart from store as an observable\n     *\n     * @param cartId\n     */\n    getCart(cartId) {\n        return this.store.pipe(select(getCartSelectorFactory(cartId)));\n    }\n    /**\n     * Returns cart entity from store (cart with loading, error, success flags) as an observable\n     *\n     * @param cartId\n     */\n    getCartEntity(cartId) {\n        return this.store.pipe(select(getCartEntitySelectorFactory(cartId)));\n    }\n    /**\n     * Returns true when there are no operations on that in progress and it is not currently loading\n     *\n     * @param cartId\n     */\n    isStable(cartId) {\n        return this.store.pipe(select(getCartIsStableSelectorFactory(cartId)), \n        // We dispatch a lot of actions just after finishing some process or loading, so we want this flag not to flicker.\n        // This flickering should only be avoided when switching from false to true\n        // Start of loading should be showed instantly (no debounce)\n        // Extra actions are only dispatched after some loading\n        debounce(isStable => (isStable ? timer(0) : EMPTY)), distinctUntilChanged());\n    }\n    /**\n     * Simple random temp cart id generator\n     */\n    generateTempCartId() {\n        const pseudoUuid = Math.random()\n            .toString(36)\n            .substr(2, 9);\n        return `temp-${pseudoUuid}`;\n    }\n    /**\n     * Create or merge cart\n     *\n     * @param params Object with userId, oldCartId, toMergeCartGuid and extraData\n     */\n    createCart({ userId, oldCartId, toMergeCartGuid, extraData, }) {\n        // to support creating multiple carts at the same time we need to use different entity for every process\n        // simple random uuid generator is used here for entity names\n        const tempCartId = this.generateTempCartId();\n        this.store.dispatch(new CreateCart({\n            extraData,\n            userId,\n            oldCartId,\n            toMergeCartGuid,\n            tempCartId,\n        }));\n        return this.getCartEntity(tempCartId);\n    }\n    /**\n     * Merge provided cart to current user cart\n     *\n     * @param params Object with userId, cartId and extraData\n     */\n    mergeToCurrentCart({ userId, cartId, extraData }) {\n        const tempCartId = this.generateTempCartId();\n        this.store.dispatch(new MergeCart({\n            userId,\n            cartId,\n            extraData,\n            tempCartId,\n        }));\n    }\n    /**\n     * Load cart\n     *\n     * @param params Object with userId, cartId and extraData\n     */\n    loadCart({ cartId, userId, extraData, }) {\n        this.store.dispatch(new LoadCart({\n            userId,\n            cartId,\n            extraData,\n        }));\n    }\n    /**\n     * Get cart entries as an observable\n     * @param cartId\n     */\n    getEntries(cartId) {\n        return this.store.pipe(select(getCartEntriesSelectorFactory(cartId)));\n    }\n    /**\n     * Add entry to cart\n     *\n     * @param userId\n     * @param cartId\n     * @param productCode\n     * @param quantity\n     */\n    addEntry(userId, cartId, productCode, quantity) {\n        this.store.dispatch(new CartAddEntry({\n            userId,\n            cartId,\n            productCode,\n            quantity,\n        }));\n    }\n    /**\n     * Add multiple entries to cart\n     *\n     * @param userId\n     * @param cartId\n     * @param products Array with items (productCode and quantity)\n     */\n    addEntries(userId, cartId, products) {\n        products.forEach(product => {\n            this.store.dispatch(new CartAddEntry({\n                userId,\n                cartId,\n                productCode: product.productCode,\n                quantity: product.quantity,\n            }));\n        });\n    }\n    /**\n     * Remove entry from cart\n     *\n     * @param userId\n     * @param cartId\n     * @param entryNumber\n     */\n    removeEntry(userId, cartId, entryNumber) {\n        this.store.dispatch(new CartRemoveEntry({\n            userId,\n            cartId,\n            entry: entryNumber,\n        }));\n    }\n    /**\n     * Update entry in cart. For quantity = 0 it removes entry\n     *\n     * @param userId\n     * @param cartId\n     * @param entryNumber\n     * @param quantity\n     */\n    updateEntry(userId, cartId, entryNumber, quantity) {\n        if (quantity > 0) {\n            this.store.dispatch(new CartUpdateEntry({\n                userId,\n                cartId,\n                entry: entryNumber,\n                qty: quantity,\n            }));\n        }\n        else {\n            this.removeEntry(userId, cartId, entryNumber);\n        }\n    }\n    /**\n     * Get specific entry from cart\n     *\n     * @param cartId\n     * @param productCode\n     */\n    getEntry(cartId, productCode) {\n        return this.store.pipe(select(getCartEntrySelectorFactory$1(cartId, productCode)));\n    }\n    /**\n     * Assign email to the cart\n     *\n     * @param cartId\n     * @param userId\n     * @param email\n     */\n    assignEmail(cartId, userId, email) {\n        this.store.dispatch(new AddEmailToCart({\n            userId,\n            cartId,\n            email,\n        }));\n    }\n    /**\n     * Delete cart\n     *\n     * @param cartId\n     * @param userId\n     */\n    deleteCart(cartId, userId) {\n        this.store.dispatch(new DeleteCart({\n            userId,\n            cartId,\n        }));\n    }\n};\nMultiCartService.ctorParameters = () => [\n    { type: Store }\n];\nMultiCartService = __decorate([\n    Injectable()\n], MultiCartService);\n\nlet ActiveCartService = class ActiveCartService {\n    constructor(store, authService, multiCartService) {\n        this.store = store;\n        this.authService = authService;\n        this.multiCartService = multiCartService;\n        this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';\n        this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;\n        this.userId = OCC_USER_ID_ANONYMOUS;\n        this.activeCartId$ = this.store.pipe(select(getActiveCartId), map(cartId => {\n            if (!cartId) {\n                return OCC_CART_ID_CURRENT;\n            }\n            return cartId;\n        }));\n        this.cartSelector$ = this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getCartEntity(cartId)));\n        this.authService.getOccUserId().subscribe(userId => {\n            this.userId = userId;\n            if (this.userId !== OCC_USER_ID_ANONYMOUS) {\n                if (this.isJustLoggedIn(userId)) {\n                    this.loadOrMerge(this.cartId);\n                }\n            }\n            this.previousUserId = userId;\n        });\n        this.activeCartId$.subscribe(cartId => {\n            this.cartId = cartId;\n        });\n        this.initActiveCart();\n    }\n    initActiveCart() {\n        this.activeCart$ = this.cartSelector$.pipe(withLatestFrom(this.activeCartId$), map(([cartEntity, activeCartId]) => {\n            return {\n                cart: cartEntity.value,\n                cartId: activeCartId,\n                isStable: !cartEntity.loading && cartEntity.processesCount === 0,\n                loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading,\n            };\n        }), \n        // we want to emit empty carts even if those are not stable\n        // on merge cart action we want to switch to empty cart so no one would use old cartId which can be already obsolete\n        // so on merge action the resulting stream looks like this: old_cart -> {} -> new_cart\n        filter(({ isStable, cart }) => isStable || this.isEmpty(cart)), tap(({ cart, cartId, loaded, isStable }) => {\n            if (isStable &&\n                this.isEmpty(cart) &&\n                !loaded &&\n                !isTempCartId(cartId)) {\n                this.load(cartId);\n            }\n        }), map(({ cart }) => (cart ? cart : {})), tap(cart => {\n            if (cart) {\n                this.cartUser = cart.user;\n            }\n        }), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));\n    }\n    /**\n     * Returns active cart\n     */\n    getActive() {\n        return this.activeCart$;\n    }\n    /**\n     * Returns active cart id\n     */\n    getActiveCartId() {\n        return this.activeCart$.pipe(map(cart => getCartIdByUserId(cart, this.userId)), distinctUntilChanged());\n    }\n    /**\n     * Returns cart entries\n     */\n    getEntries() {\n        return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getEntries(cartId)), distinctUntilChanged());\n    }\n    /**\n     * Returns true when cart is stable (not loading and not pending processes on cart)\n     */\n    getLoaded() {\n        // Debounce is used here, to avoid flickering when we switch between different cart entities.\n        // For example during `addEntry` method. We might try to load current cart, so `current cart will be then active id.\n        // After load fails we might create new cart so we switch to `temp-${uuid}` cart entity used when creating cart.\n        // At the end we finally switch to cart `code` for cart id. Between those switches cart `getLoaded` function should not flicker.\n        return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.isStable(cartId)), debounce(state => (state ? timer(0) : EMPTY)), distinctUntilChanged());\n    }\n    loadOrMerge(cartId) {\n        // for login user, whenever there's an existing cart, we will load the user\n        // current cart and merge it into the existing cart\n        if (!cartId || cartId === OCC_CART_ID_CURRENT) {\n            this.multiCartService.loadCart({\n                userId: this.userId,\n                cartId: OCC_CART_ID_CURRENT,\n                extraData: {\n                    active: true,\n                },\n            });\n        }\n        else if (this.isGuestCart()) {\n            this.guestCartMerge(cartId);\n        }\n        else {\n            this.multiCartService.mergeToCurrentCart({\n                userId: this.userId,\n                cartId,\n                extraData: {\n                    active: true,\n                },\n            });\n        }\n    }\n    load(cartId) {\n        if (this.userId !== OCC_USER_ID_ANONYMOUS) {\n            this.multiCartService.loadCart({\n                userId: this.userId,\n                cartId: cartId ? cartId : OCC_CART_ID_CURRENT,\n                extraData: {\n                    active: true,\n                },\n            });\n        }\n        else if (cartId && cartId !== OCC_CART_ID_CURRENT) {\n            this.multiCartService.loadCart({\n                userId: this.userId,\n                cartId: cartId,\n                extraData: {\n                    active: true,\n                },\n            });\n        }\n    }\n    addEntriesGuestMerge(cartEntries) {\n        const entriesToAdd = cartEntries.map(entry => ({\n            productCode: entry.product.code,\n            quantity: entry.quantity,\n        }));\n        this.requireLoadedCartForGuestMerge().subscribe(cartState => {\n            this.multiCartService.addEntries(this.userId, getCartIdByUserId(cartState.value, this.userId), entriesToAdd);\n        });\n    }\n    requireLoadedCartForGuestMerge() {\n        return this.requireLoadedCart(this.cartSelector$.pipe(filter(() => !this.isGuestCart())));\n    }\n    isCartCreating(cartState) {\n        // cart creating is always represented with loading flags\n        // when all loading flags are false it means that we restored wrong cart id\n        // could happen on context change or reload right in the middle on cart create call\n        return (isTempCartId(this.cartId) &&\n            (cartState.loading || cartState.success || cartState.error));\n    }\n    requireLoadedCart(customCartSelector$) {\n        // For guest cart merge we want to filter guest cart in the whole stream\n        // We have to wait with load/create/addEntry after guest cart will be deleted.\n        // That's why you can provide custom selector with this filter applied.\n        const cartSelector$ = customCartSelector$\n            ? customCartSelector$\n            : this.cartSelector$;\n        return cartSelector$.pipe(filter(cartState => !cartState.loading), \n        // Avoid load/create call when there are new cart creating at the moment\n        filter(cartState => !this.isCartCreating(cartState)), take(1), switchMap(cartState => {\n            // Try to load the cart, because it might have been created on another device between our login and add entry call\n            if (this.isEmpty(cartState.value) &&\n                this.userId !== OCC_USER_ID_ANONYMOUS) {\n                this.load(undefined);\n            }\n            return cartSelector$;\n        }), filter(cartState => !cartState.loading), \n        // create cart can happen to anonymous user if it is not empty or to any other user if it is loaded and empty\n        filter(cartState => this.userId === OCC_USER_ID_ANONYMOUS ||\n            (cartState.success || cartState.error)), take(1), switchMap(cartState => {\n            if (this.isEmpty(cartState.value)) {\n                this.multiCartService.createCart({\n                    userId: this.userId,\n                    extraData: {\n                        active: true,\n                    },\n                });\n            }\n            return cartSelector$;\n        }), filter(cartState => !cartState.loading), filter(cartState => cartState.success || cartState.error), \n        // wait for active cart id to point to code/guid to avoid some work on temp cart entity\n        filter(cartState => !this.isCartCreating(cartState)), filter(cartState => !this.isEmpty(cartState.value)), take(1));\n    }\n    /**\n     * Add entry to active cart\n     *\n     * @param productCode\n     * @param quantity\n     */\n    addEntry(productCode, quantity) {\n        this.requireLoadedCart().subscribe(cartState => {\n            this.multiCartService.addEntry(this.userId, getCartIdByUserId(cartState.value, this.userId), productCode, quantity);\n        });\n    }\n    /**\n     * Remove entry\n     *\n     * @param entry\n     */\n    removeEntry(entry) {\n        this.multiCartService.removeEntry(this.userId, this.cartId, entry.entryNumber);\n    }\n    /**\n     * Update entry\n     *\n     * @param entryNumber\n     * @param quantity\n     */\n    updateEntry(entryNumber, quantity) {\n        this.multiCartService.updateEntry(this.userId, this.cartId, entryNumber, quantity);\n    }\n    /**\n     * Returns cart entry\n     *\n     * @param productCode\n     */\n    getEntry(productCode) {\n        return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getEntry(cartId, productCode)), distinctUntilChanged());\n    }\n    /**\n     * Assign email to cart\n     *\n     * @param email\n     */\n    addEmail(email) {\n        this.multiCartService.assignEmail(this.cartId, this.userId, email);\n    }\n    /**\n     * Get assigned user to cart\n     */\n    getAssignedUser() {\n        return this.getActive().pipe(map(cart => cart.user));\n    }\n    /**\n     * Returns true for guest cart\n     */\n    isGuestCart() {\n        return (this.cartUser &&\n            (this.cartUser.name === OCC_USER_ID_GUEST ||\n                this.isEmail(this.cartUser.uid\n                    .split('|')\n                    .slice(1)\n                    .join('|'))));\n    }\n    /**\n     * Add multiple entries to a cart\n     *\n     * @param cartEntries : list of entries to add (OrderEntry[])\n     */\n    addEntries(cartEntries) {\n        cartEntries.forEach(entry => {\n            this.addEntry(entry.product.code, entry.quantity);\n        });\n    }\n    isEmail(str) {\n        if (str) {\n            return str.match(EMAIL_PATTERN) ? true : false;\n        }\n        return false;\n    }\n    // TODO: Remove once backend is updated\n    /**\n     * Temporary method to merge guest cart with user cart because of backend limitation\n     * This is for an edge case\n     */\n    guestCartMerge(cartId) {\n        let cartEntries;\n        this.getEntries()\n            .pipe(take(1))\n            .subscribe(entries => {\n            cartEntries = entries;\n        });\n        this.multiCartService.deleteCart(cartId, OCC_USER_ID_ANONYMOUS);\n        this.addEntriesGuestMerge(cartEntries);\n    }\n    isEmpty(cart) {\n        return (!cart || (typeof cart === 'object' && Object.keys(cart).length === 0));\n    }\n    isJustLoggedIn(userId) {\n        return (this.previousUserId !== userId && // *just* logged in\n            this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization\n        );\n    }\n};\nActiveCartService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService },\n    { type: MultiCartService }\n];\nActiveCartService = __decorate([\n    Injectable()\n], ActiveCartService);\n\n/**\n * @license\n * The MIT License\n * Copyright (c) 2010-2019 Google LLC. http://angular.io/license\n *\n * See:\n * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/glob.ts\n * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/aio/tests/deployment/shared/helpers.ts#L17\n * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/generator.ts#L86\n */\nconst QUESTION_MARK = '[^/]';\nconst WILD_SINGLE = '[^/]*';\nconst WILD_OPEN = '(?:.+\\\\/)?';\nconst TO_ESCAPE_BASE = [\n    { replace: /\\./g, with: '\\\\.' },\n    { replace: /\\+/g, with: '\\\\+' },\n    { replace: /\\*/g, with: WILD_SINGLE },\n];\nconst TO_ESCAPE_WILDCARD_QM = [\n    ...TO_ESCAPE_BASE,\n    { replace: /\\?/g, with: QUESTION_MARK },\n];\nconst TO_ESCAPE_LITERAL_QM = [\n    ...TO_ESCAPE_BASE,\n    { replace: /\\?/g, with: '\\\\?' },\n];\n/**\n * Converts the glob-like pattern into regex string.\n *\n * Patterns use a limited glob format:\n * `**` matches 0 or more path segments\n * `*` matches 0 or more characters excluding `/`\n * `?` matches exactly one character excluding `/` (but when @param literalQuestionMark is true, `?` is treated as normal character)\n * The `!` prefix marks the pattern as being negative, meaning that only URLs that don't match the pattern will be included\n *\n * @param glob glob-like pattern\n * @param literalQuestionMark when true, it tells that `?` is treated as a normal character\n */\nfunction globToRegex(glob, literalQuestionMark = false) {\n    const toEscape = literalQuestionMark\n        ? TO_ESCAPE_LITERAL_QM\n        : TO_ESCAPE_WILDCARD_QM;\n    const segments = glob.split('/').reverse();\n    let regex = '';\n    while (segments.length > 0) {\n        const segment = segments.pop();\n        if (segment === '**') {\n            if (segments.length > 0) {\n                regex += WILD_OPEN;\n            }\n            else {\n                regex += '.*';\n            }\n        }\n        else {\n            const processed = toEscape.reduce((seg, escape) => seg.replace(escape.replace, escape.with), segment);\n            regex += processed;\n            if (segments.length > 0) {\n                regex += '\\\\/';\n            }\n        }\n    }\n    return regex;\n}\n/**\n * For given list of glob-like patterns, returns a matcher function.\n *\n * The matcher returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.\n */\nfunction getGlobMatcher(patterns) {\n    const processedPatterns = processGlobPatterns(patterns).map(({ positive, regex }) => ({\n        positive,\n        regex: new RegExp(regex),\n    }));\n    const includePatterns = processedPatterns.filter(spec => spec.positive);\n    const excludePatterns = processedPatterns.filter(spec => !spec.positive);\n    return (url) => includePatterns.some(pattern => pattern.regex.test(url)) &&\n        !excludePatterns.some(pattern => pattern.regex.test(url));\n}\n/**\n * Converts list of glob-like patterns into list of RegExps with information whether the glob pattern is positive or negative\n */\nfunction processGlobPatterns(urls) {\n    return urls.map(url => {\n        const positive = !url.startsWith('!');\n        url = positive ? url : url.substr(1);\n        return { positive, regex: `^${globToRegex(url)}$` };\n    });\n}\n\nlet GlobService = class GlobService {\n    /**\n     * For given list of glob-like patterns, returns a validator function.\n     *\n     * The validator returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.\n     */\n    getValidator(patterns) {\n        const processedPatterns = processGlobPatterns(patterns).map(({ positive, regex }) => ({\n            positive,\n            regex: new RegExp(regex),\n        }));\n        const includePatterns = processedPatterns.filter(spec => spec.positive);\n        const excludePatterns = processedPatterns.filter(spec => !spec.positive);\n        return (url) => includePatterns.some(pattern => pattern.regex.test(url)) &&\n            !excludePatterns.some(pattern => pattern.regex.test(url));\n    }\n};\nGlobService.ɵprov = ɵɵdefineInjectable({ factory: function GlobService_Factory() { return new GlobService(); }, token: GlobService, providedIn: \"root\" });\nGlobService = __decorate([\n    Injectable({ providedIn: 'root' })\n], GlobService);\n\n/**\n *\n * Withdraw from the source observable when notifier emits a value\n *\n * Withdraw will result in resubscribing to the source observable\n * Operator is useful to kill ongoing emission transformation on notifier emission\n *\n * @param notifier\n */\nfunction withdrawOn(notifier) {\n    return (source) => notifier.pipe(startWith(undefined), switchMapTo(source));\n}\n\n/**\n * @deprecated since version 1.4\n * Replace particular methods usage with replacements from other services\n */\nlet CartDataService = class CartDataService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n        this._userId = OCC_USER_ID_ANONYMOUS;\n        this.authService\n            .getUserToken()\n            .pipe(filter(userToken => this.userId !== userToken.userId))\n            .subscribe(userToken => {\n            if (Object.keys(userToken).length !== 0) {\n                this._userId = userToken.userId;\n            }\n            else {\n                this._userId = OCC_USER_ID_ANONYMOUS;\n            }\n        });\n        this.store.pipe(select(getCartContent)).subscribe(cart => {\n            this._cart = cart;\n        });\n    }\n    get hasCart() {\n        return !!this._cart && Object.keys(this._cart).length > 0;\n    }\n    /**\n     * @deprecated since version 1.4\n     * Use `getOccUserId` from `AuthService` instead\n     */\n    get userId() {\n        return this._userId;\n    }\n    /**\n     * @deprecated since version 1.4\n     * Use `getActive` from `ActiveCartService` instead\n     */\n    get cart() {\n        return this._cart;\n    }\n    /**\n     * @deprecated since version 1.4\n     * Use `getActiveCartId` from `ActiveCartService` instead\n     */\n    get cartId() {\n        if (this.hasCart) {\n            return this.userId === OCC_USER_ID_ANONYMOUS\n                ? this.cart.guid\n                : this.cart.code;\n        }\n    }\n    /**\n     * @deprecated since version 1.4\n     * Use `isGuestCart` from `ActiveCartService` instead\n     */\n    get isGuestCart() {\n        return (this.cart.user &&\n            (this.cart.user.name === OCC_USER_ID_GUEST ||\n                this.isEmail(this.cart.user.uid\n                    .split('|')\n                    .slice(1)\n                    .join('|'))));\n    }\n    isEmail(str) {\n        if (str) {\n            return str.match(EMAIL_PATTERN) ? true : false;\n        }\n        return false;\n    }\n};\nCartDataService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nCartDataService = __decorate([\n    Injectable()\n], CartDataService);\n\nlet CartVoucherService = class CartVoucherService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    addVoucher(voucherId, cartId) {\n        this.combineUserAndCartId(cartId).subscribe(([occUserId, cartIdentifier]) => this.store.dispatch(new CartAddVoucher({\n            userId: occUserId,\n            cartId: cartIdentifier,\n            voucherId: voucherId,\n        })));\n    }\n    removeVoucher(voucherId, cartId) {\n        this.combineUserAndCartId(cartId).subscribe(([occUserId, cartIdentifier]) => this.store.dispatch(new CartRemoveVoucher({\n            userId: occUserId,\n            cartId: cartIdentifier,\n            voucherId: voucherId,\n        })));\n    }\n    getAddVoucherResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(ADD_VOUCHER_PROCESS_ID)));\n    }\n    getAddVoucherResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(ADD_VOUCHER_PROCESS_ID)));\n    }\n    getAddVoucherResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(ADD_VOUCHER_PROCESS_ID)));\n    }\n    resetAddVoucherProcessingState() {\n        this.store.dispatch(new CartResetAddVoucher());\n    }\n    combineUserAndCartId(cartId) {\n        if (cartId) {\n            return this.authService.getOccUserId().pipe(take(1), map(userId => [userId, cartId]));\n        }\n        else {\n            return combineLatest([\n                this.authService.getOccUserId(),\n                this.store.pipe(select(getCartContent), map(cart => cart)),\n            ]).pipe(take(1), map(([userId, cart]) => [\n                userId,\n                userId === OCC_USER_ID_ANONYMOUS ? cart.guid : cart.code,\n            ]));\n        }\n    }\n};\nCartVoucherService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nCartVoucherService = __decorate([\n    Injectable()\n], CartVoucherService);\n\n/**\n * @deprecated since version 1.4\n * Use ActiveCartService instead (API is almost the same)\n * From 1.4 version CartService uses ActiveCartService if it is available\n * Fixes and improvements will be only implemented in ActiveCartService\n */\nlet CartService = class CartService {\n    constructor(store, cartData, authService, activeCartService) {\n        this.store = store;\n        this.cartData = cartData;\n        this.authService = authService;\n        this.activeCartService = activeCartService;\n        this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';\n        this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;\n        this._activeCart$ = combineLatest([\n            this.store.select(getCartContent),\n            this.store.select(getCartLoading),\n            this.authService.getUserToken(),\n            this.store.select(getCartLoaded),\n        ]).pipe(\n        // combineLatest emits multiple times on each property update instead of one emit\n        // additionally dispatching actions that changes selectors used here needs to happen in order\n        // for this asyncScheduler is used here\n        debounceTime(0), filter(([, loading]) => !loading), tap(([cart, , userToken, loaded]) => {\n            if (this.isJustLoggedIn(userToken.userId)) {\n                this.loadOrMerge();\n            }\n            else if ((this.isCreated(cart) && this.isIncomplete(cart)) ||\n                (this.isLoggedIn(userToken.userId) &&\n                    !this.isCreated(cart) &&\n                    !loaded) // try to load current cart for logged in user (loaded flag to prevent infinite loop when user doesn't have cart)\n            ) {\n                this.load();\n            }\n            this.previousUserId = userToken.userId;\n        }), filter(([cart]) => !this.isCreated(cart) ||\n            (this.isCreated(cart) && !this.isIncomplete(cart))), map(([cart]) => cart), shareReplay({ bufferSize: 1, refCount: true }));\n    }\n    getActive() {\n        if (this.activeCartService) {\n            return this.activeCartService.getActive();\n        }\n        return this._activeCart$;\n    }\n    getEntries() {\n        if (this.activeCartService) {\n            return this.activeCartService.getEntries();\n        }\n        return this.store.pipe(select(getCartEntries));\n    }\n    // TODO: to remove in 2.0\n    // doesn't seem useful for end developers\n    // there shouldn't be a need for such low level information\n    getCartMergeComplete() {\n        return this.store.pipe(select(getCartMergeComplete));\n    }\n    getLoaded() {\n        if (this.activeCartService) {\n            return this.activeCartService.getLoaded();\n        }\n        return this.store.pipe(select(getCartLoaded));\n    }\n    loadOrMerge() {\n        // for login user, whenever there's an existing cart, we will load the user\n        // current cart and merge it into the existing cart\n        if (!this.isCreated(this.cartData.cart)) {\n            this.store.dispatch(new LoadCart({\n                userId: this.cartData.userId,\n                cartId: OCC_CART_ID_CURRENT,\n            }));\n        }\n        else if (this.isGuestCart()) {\n            this.guestCartMerge();\n        }\n        else {\n            this.store.dispatch(new MergeCart({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cart.guid,\n            }));\n        }\n    }\n    load() {\n        if (this.cartData.userId !== OCC_USER_ID_ANONYMOUS) {\n            this.store.dispatch(new LoadCart({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId\n                    ? this.cartData.cartId\n                    : OCC_CART_ID_CURRENT,\n            }));\n        }\n        else {\n            this.store.dispatch(new LoadCart({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n            }));\n        }\n    }\n    addEntry(productCode, quantity) {\n        if (this.activeCartService) {\n            return this.activeCartService.addEntry(productCode, quantity);\n        }\n        this.store\n            .pipe(select(getActiveCartState), tap(cartState => {\n            if (!this.isCreated(cartState.value.content) && !cartState.loading) {\n                this.store.dispatch(new CreateCart({\n                    userId: this.cartData.userId,\n                }));\n            }\n        }), filter(cartState => this.isCreated(cartState.value.content)), take(1))\n            .subscribe(_ => {\n            this.store.dispatch(new CartAddEntry({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n                productCode: productCode,\n                quantity: quantity,\n            }));\n        });\n    }\n    removeEntry(entry) {\n        if (this.activeCartService) {\n            return this.activeCartService.removeEntry(entry);\n        }\n        this.store.dispatch(new CartRemoveEntry({\n            userId: this.cartData.userId,\n            cartId: this.cartData.cartId,\n            entry: entry.entryNumber,\n        }));\n    }\n    updateEntry(entryNumber, quantity) {\n        if (this.activeCartService) {\n            return this.activeCartService.updateEntry(parseInt(entryNumber, 10), quantity);\n        }\n        if (quantity > 0) {\n            this.store.dispatch(new CartUpdateEntry({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n                entry: entryNumber,\n                qty: quantity,\n            }));\n        }\n        else {\n            this.store.dispatch(new CartRemoveEntry({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n                entry: entryNumber,\n            }));\n        }\n    }\n    getEntry(productCode) {\n        if (this.activeCartService) {\n            return this.activeCartService.getEntry(productCode);\n        }\n        return this.store.pipe(select(getCartEntrySelectorFactory(productCode)));\n    }\n    addEmail(email) {\n        if (this.activeCartService) {\n            return this.activeCartService.addEmail(email);\n        }\n        this.store.dispatch(new AddEmailToCart({\n            userId: this.cartData.userId,\n            cartId: this.cartData.cartId,\n            email: email,\n        }));\n    }\n    getAssignedUser() {\n        if (this.activeCartService) {\n            return this.activeCartService.getAssignedUser();\n        }\n        return this.store.pipe(select(getCartUser));\n    }\n    isGuestCart() {\n        if (this.activeCartService) {\n            return this.activeCartService.isGuestCart();\n        }\n        return this.cartData.isGuestCart;\n    }\n    /**\n     * Add multiple entries to a cart\n     * Requires a created cart\n     * @param cartEntries : list of entries to add (OrderEntry[])\n     */\n    addEntries(cartEntries) {\n        if (this.activeCartService) {\n            return this.activeCartService.addEntries(cartEntries);\n        }\n        let newEntries = 0;\n        this.getEntries()\n            .pipe(tap(() => {\n            // Keep adding entries until the user cart contains the same number of entries\n            // as the guest cart did\n            if (newEntries < cartEntries.length) {\n                this.store.dispatch(new CartAddEntry({\n                    userId: this.cartData.userId,\n                    cartId: this.cartData.cartId,\n                    productCode: cartEntries[newEntries].product.code,\n                    quantity: cartEntries[newEntries].quantity,\n                }));\n                newEntries++;\n            }\n        }), filter(() => newEntries === cartEntries.length), take(1))\n            .subscribe();\n    }\n    isCreated(cart) {\n        return cart && typeof cart.guid !== 'undefined';\n    }\n    /**\n     * Cart is incomplete if it contains only `guid`, `code` and `user` properties, which come from local storage.\n     * To get cart content, we need to load cart from backend.\n     */\n    isIncomplete(cart) {\n        return cart && Object.keys(cart).length <= 3;\n    }\n    isJustLoggedIn(userId) {\n        return (this.isLoggedIn(userId) &&\n            this.previousUserId !== userId && // *just* logged in\n            this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization\n        );\n    }\n    isLoggedIn(userId) {\n        return typeof userId !== 'undefined';\n    }\n    // TODO: Remove once backend is updated\n    /**\n     * Temporary method to merge guest cart with user cart because of backend limitation\n     * This is for an edge case\n     */\n    guestCartMerge() {\n        let cartEntries;\n        this.getEntries()\n            .pipe(take(1))\n            .subscribe(entries => {\n            cartEntries = entries;\n        });\n        this.store.dispatch(new DeleteCart({\n            userId: OCC_USER_ID_ANONYMOUS,\n            cartId: this.cartData.cart.guid,\n        }));\n        this.store\n            .pipe(select(getActiveCartState), filter(cartState => !cartState.loading), tap(cartState => {\n            // If the cart is not created it needs to be created\n            // This step should happen before adding entries to avoid conflicts in the requests\n            if (!this.isCreated(cartState.value.content)) {\n                this.store.dispatch(new CreateCart({\n                    userId: this.cartData.userId,\n                }));\n            }\n        }), filter(cartState => this.isCreated(cartState.value.content)), take(1))\n            .subscribe(() => {\n            this.addEntries(cartEntries);\n        });\n    }\n    addVoucher(voucherId) {\n        this.store.dispatch(new CartAddVoucher({\n            userId: this.cartData.userId,\n            cartId: this.cartData.cartId,\n            voucherId: voucherId,\n        }));\n    }\n};\nCartService.ctorParameters = () => [\n    { type: Store },\n    { type: CartDataService },\n    { type: AuthService },\n    { type: ActiveCartService }\n];\nCartService = __decorate([\n    Injectable()\n], CartService);\n\nlet UserService = class UserService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Returns a user\n     */\n    get() {\n        return this.store.pipe(select(getDetails), tap(details => {\n            if (Object.keys(details).length === 0) {\n                this.load();\n            }\n        }));\n    }\n    /**\n     * Loads the user's details\n     */\n    load() {\n        this.withUserId(userId => {\n            if (userId !== OCC_USER_ID_ANONYMOUS) {\n                this.store.dispatch(new LoadUserDetails(userId));\n            }\n        });\n    }\n    /**\n     * Register a new user\n     *\n     * @param submitFormData as UserRegisterFormData\n     */\n    register(userRegisterFormData) {\n        this.store.dispatch(new RegisterUser(userRegisterFormData));\n    }\n    /**\n     * Register a new user from guest\n     *\n     * @param guid\n     * @param password\n     */\n    registerGuest(guid, password) {\n        this.store.dispatch(new RegisterGuest({ guid, password }));\n    }\n    /**\n     * Returns the register user process loading flag\n     */\n    getRegisterUserResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(REGISTER_USER_PROCESS_ID)));\n    }\n    /**\n     * Returns the register user process success flag\n     */\n    getRegisterUserResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(REGISTER_USER_PROCESS_ID)));\n    }\n    /**\n     * Returns the register user process error flag\n     */\n    getRegisterUserResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(REGISTER_USER_PROCESS_ID)));\n    }\n    /**\n     * Resets the register user process flags\n     */\n    resetRegisterUserProcessState() {\n        return this.store.dispatch(new ResetRegisterUserProcess());\n    }\n    /**\n     * Remove user account, that's also called close user's account\n     */\n    remove() {\n        this.withUserId(userId => this.store.dispatch(new RemoveUser(userId)));\n    }\n    /**\n     * Returns the remove user loading flag\n     */\n    getRemoveUserResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(REMOVE_USER_PROCESS_ID)));\n    }\n    /**\n     * Returns the remove user failure outcome.\n     */\n    getRemoveUserResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(REMOVE_USER_PROCESS_ID)));\n    }\n    /**\n     * Returns the remove user process success outcome.\n     */\n    getRemoveUserResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(REMOVE_USER_PROCESS_ID)));\n    }\n    /**\n     * Resets the remove user process state. The state needs to be reset after the process\n     * concludes, regardless if it's a success or an error\n     */\n    resetRemoveUserProcessState() {\n        this.store.dispatch(new RemoveUserReset());\n    }\n    /**\n     * Returns titles\n     */\n    getTitles() {\n        return this.store.pipe(select(getAllTitles));\n    }\n    /**\n     * Retrieves titles\n     */\n    loadTitles() {\n        this.store.dispatch(new LoadTitles());\n    }\n    /**\n     * Return whether user's password is successfully reset\n     */\n    isPasswordReset() {\n        return this.store.pipe(select(getResetPassword));\n    }\n    /**\n     * Updates the user's details\n     * @param userDetails to be updated\n     */\n    updatePersonalDetails(userDetails) {\n        this.withUserId(userId => this.store.dispatch(new UpdateUserDetails({\n            username: userId,\n            userDetails,\n        })));\n    }\n    /**\n     * Returns the update user's personal details loading flag\n     */\n    getUpdatePersonalDetailsResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(UPDATE_USER_DETAILS_PROCESS_ID)));\n    }\n    /**\n     * Returns the update user's personal details error flag\n     */\n    getUpdatePersonalDetailsResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(UPDATE_USER_DETAILS_PROCESS_ID)));\n    }\n    /**\n     * Returns the update user's personal details success flag\n     */\n    getUpdatePersonalDetailsResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(UPDATE_USER_DETAILS_PROCESS_ID)));\n    }\n    /**\n     * Resets the update user details processing state\n     */\n    resetUpdatePersonalDetailsProcessingState() {\n        this.store.dispatch(new ResetUpdateUserDetails());\n    }\n    /**\n     * Reset new password.  Part of the forgot password flow.\n     * @param token\n     * @param password\n     */\n    resetPassword(token, password) {\n        this.store.dispatch(new ResetPassword({ token, password }));\n    }\n    /*\n     * Request an email to reset a forgotten password.\n     */\n    requestForgotPasswordEmail(userEmailAddress) {\n        this.store.dispatch(new ForgotPasswordEmailRequest(userEmailAddress));\n    }\n    /**\n     * Updates the user's email\n     */\n    updateEmail(password, newUid) {\n        this.withUserId(userId => this.store.dispatch(new UpdateEmailAction({\n            uid: userId,\n            password,\n            newUid,\n        })));\n    }\n    /**\n     * Returns the update user's email success flag\n     */\n    getUpdateEmailResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(UPDATE_EMAIL_PROCESS_ID)));\n    }\n    /**\n     * Returns the update user's email error flag\n     */\n    getUpdateEmailResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(UPDATE_EMAIL_PROCESS_ID)));\n    }\n    /**\n     * Returns the update user's email loading flag\n     */\n    getUpdateEmailResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(UPDATE_EMAIL_PROCESS_ID)));\n    }\n    /**\n     * Resets the update user's email processing state\n     */\n    resetUpdateEmailResultState() {\n        this.store.dispatch(new ResetUpdateEmailAction());\n    }\n    /**\n     * Updates the password for the user\n     * @param oldPassword the current password that will be changed\n     * @param newPassword the new password\n     */\n    updatePassword(oldPassword, newPassword) {\n        this.withUserId(userId => this.store.dispatch(new UpdatePassword({\n            userId,\n            oldPassword,\n            newPassword,\n        })));\n    }\n    /**\n     * Returns the update password loading flag\n     */\n    getUpdatePasswordResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(UPDATE_PASSWORD_PROCESS_ID)));\n    }\n    /**\n     * Returns the update password failure outcome.\n     */\n    getUpdatePasswordResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(UPDATE_PASSWORD_PROCESS_ID)));\n    }\n    /**\n     * Returns the update password process success outcome.\n     */\n    getUpdatePasswordResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(UPDATE_PASSWORD_PROCESS_ID)));\n    }\n    /**\n     * Resets the update password process state. The state needs to be reset after the process\n     * concludes, regardless if it's a success or an error\n     */\n    resetUpdatePasswordProcessState() {\n        this.store.dispatch(new UpdatePasswordReset());\n    }\n    /**\n     * Utility method to distinquish pre / post 1.3.0 in a convenient way.\n     *\n     */\n    withUserId(callback) {\n        if (this.authService) {\n            this.authService\n                .getOccUserId()\n                .pipe(take(1))\n                .subscribe(userId => callback(userId));\n        }\n        else {\n            // TODO(issue:#5628) Deprecated since 1.3.0\n            callback(OCC_USER_ID_CURRENT);\n        }\n    }\n};\nUserService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nUserService = __decorate([\n    Injectable()\n], UserService);\n\nlet SelectiveCartService = class SelectiveCartService {\n    constructor(store, userService, authService, multiCartService, baseSiteService) {\n        this.store = store;\n        this.userService = userService;\n        this.authService = authService;\n        this.multiCartService = multiCartService;\n        this.baseSiteService = baseSiteService;\n        this.cartId$ = new BehaviorSubject(undefined);\n        this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';\n        this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;\n        this.cartSelector$ = this.cartId$.pipe(switchMap(cartId => {\n            this.cartId = cartId;\n            return this.multiCartService.getCartEntity(cartId);\n        }));\n        combineLatest([\n            this.userService.get(),\n            this.baseSiteService.getActive(),\n        ]).subscribe(([user, activeBaseSite]) => {\n            if (user && user.customerId && activeBaseSite) {\n                this.customerId = user.customerId;\n                this.cartId$.next(`selectivecart${activeBaseSite}${this.customerId}`);\n            }\n            else if (user && !user.customerId) {\n                this.cartId$.next(undefined);\n            }\n        });\n        this.authService.getOccUserId().subscribe(userId => {\n            this.userId = userId;\n            if (this.isJustLoggedIn(userId)) {\n                this.load();\n            }\n            this.previousUserId = userId;\n        });\n        this.selectiveCart$ = this.cartSelector$.pipe(map((cartEntity) => {\n            return {\n                cart: cartEntity.value,\n                loading: cartEntity.loading,\n                loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading,\n            };\n        }), filter(({ loading }) => !loading), tap(({ cart, loaded }) => {\n            if (this.cartId && this.isEmpty(cart) && !loaded) {\n                this.load();\n            }\n        }), map(({ cart }) => (cart ? cart : {})), shareReplay({ bufferSize: 1, refCount: true }));\n    }\n    getCart() {\n        return this.selectiveCart$;\n    }\n    getEntries() {\n        return this.multiCartService.getEntries(this.cartId);\n    }\n    getLoaded() {\n        return this.cartSelector$.pipe(map(cart => (cart.success || cart.error) && !cart.loading));\n    }\n    load() {\n        if (this.isLoggedIn(this.userId) && this.cartId) {\n            this.multiCartService.loadCart({\n                userId: this.userId,\n                cartId: this.cartId,\n            });\n        }\n    }\n    addEntry(productCode, quantity) {\n        let loadAttempted = false;\n        this.cartSelector$\n            .pipe(filter(() => !loadAttempted), switchMap(cartState => {\n            if (this.isEmpty(cartState.value) && !cartState.loading) {\n                loadAttempted = true;\n                this.load();\n            }\n            return of(cartState);\n        }), filter(cartState => !this.isEmpty(cartState.value)), take(1))\n            .subscribe(_ => {\n            this.multiCartService.addEntry(this.userId, this.cartId, productCode, quantity);\n        });\n    }\n    removeEntry(entry) {\n        this.multiCartService.removeEntry(this.userId, this.cartId, entry.entryNumber);\n    }\n    updateEntry(entryNumber, quantity) {\n        this.multiCartService.updateEntry(this.userId, this.cartId, entryNumber, quantity);\n    }\n    getEntry(productCode) {\n        return this.multiCartService.getEntry(this.cartId, productCode);\n    }\n    isEmpty(cart) {\n        return (!cart || (typeof cart === 'object' && Object.keys(cart).length === 0));\n    }\n    isJustLoggedIn(userId) {\n        return (this.isLoggedIn(userId) &&\n            this.previousUserId !== userId && // *just* logged in\n            this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization\n        );\n    }\n    isLoggedIn(userId) {\n        return typeof userId !== 'undefined' && userId !== OCC_USER_ID_ANONYMOUS;\n    }\n};\nSelectiveCartService.ctorParameters = () => [\n    { type: Store },\n    { type: UserService },\n    { type: AuthService },\n    { type: MultiCartService },\n    { type: BaseSiteService }\n];\nSelectiveCartService = __decorate([\n    Injectable()\n], SelectiveCartService);\n\nlet WishListService = class WishListService {\n    constructor(store, authService, userService, multiCartService) {\n        this.store = store;\n        this.authService = authService;\n        this.userService = userService;\n        this.multiCartService = multiCartService;\n    }\n    createWishList(userId, name, description) {\n        this.store.dispatch(new CreateWishList({ userId, name, description }));\n    }\n    getWishList() {\n        return combineLatest([\n            this.getWishListId(),\n            this.userService.get(),\n            this.authService.getOccUserId(),\n        ]).pipe(distinctUntilChanged(), tap(([wishListId, user, userId]) => {\n            if (!Boolean(wishListId) &&\n                userId !== OCC_USER_ID_ANONYMOUS &&\n                Boolean(user) &&\n                Boolean(user.customerId)) {\n                this.loadWishList(userId, user.customerId);\n            }\n        }), filter(([wishListId]) => Boolean(wishListId)), switchMap(([wishListId]) => this.multiCartService.getCart(wishListId)));\n    }\n    loadWishList(userId, customerId) {\n        this.store.dispatch(new LoadWishList({ userId, customerId }));\n    }\n    addEntry(productCode) {\n        this.getWishListId()\n            .pipe(distinctUntilChanged(), withLatestFrom(this.authService.getOccUserId(), this.userService.get()), tap(([wishListId, userId, user]) => {\n            if (!Boolean(wishListId) &&\n                Boolean(user) &&\n                Boolean(user.customerId)) {\n                this.loadWishList(userId, user.customerId);\n            }\n        }), filter(([wishListId]) => Boolean(wishListId)), take(1))\n            .subscribe(([wishListId, userId]) => this.multiCartService.addEntry(userId, wishListId, productCode, 1));\n    }\n    removeEntry(entry) {\n        this.getWishListId()\n            .pipe(distinctUntilChanged(), withLatestFrom(this.authService.getOccUserId(), this.userService.get()), tap(([wishListId, userId, user]) => {\n            if (!Boolean(wishListId) &&\n                Boolean(user) &&\n                Boolean(user.customerId)) {\n                this.loadWishList(userId, user.customerId);\n            }\n        }), filter(([wishListId]) => Boolean(wishListId)), take(1))\n            .subscribe(([wishListId, userId]) => this.multiCartService.removeEntry(userId, wishListId, entry.entryNumber));\n    }\n    getWishListLoading() {\n        return this.getWishListId().pipe(switchMap(wishListId => this.multiCartService.isStable(wishListId).pipe(map(stable => !stable))));\n    }\n    getWishListId() {\n        return this.store.pipe(select(getWishListId));\n    }\n};\nWishListService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService },\n    { type: UserService },\n    { type: MultiCartService }\n];\nWishListService = __decorate([\n    Injectable()\n], WishListService);\n\nconst CMS_FEATURE = 'cms';\nconst NAVIGATION_DETAIL_ENTITY = '[Cms] Navigation Entity';\nconst COMPONENT_ENTITY = '[Cms] Component Entity';\n\nconst LOAD_CMS_COMPONENT = '[Cms] Load Component';\nconst LOAD_CMS_COMPONENT_FAIL = '[Cms] Load Component Fail';\nconst LOAD_CMS_COMPONENT_SUCCESS = '[Cms] Load Component Success';\nconst CMS_GET_COMPONENT_FROM_PAGE = '[Cms] Get Component from Page';\nclass LoadCmsComponent extends EntityLoadAction {\n    constructor(payload) {\n        super(COMPONENT_ENTITY, payload.uid);\n        this.payload = payload;\n        this.type = LOAD_CMS_COMPONENT;\n    }\n}\nclass LoadCmsComponentFail extends EntityFailAction {\n    constructor(payload) {\n        super(COMPONENT_ENTITY, payload.uid, payload.error);\n        this.payload = payload;\n        this.type = LOAD_CMS_COMPONENT_FAIL;\n    }\n}\nclass LoadCmsComponentSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(COMPONENT_ENTITY, payload.uid || payload.component.uid || '');\n        this.payload = payload;\n        this.type = LOAD_CMS_COMPONENT_SUCCESS;\n    }\n}\nclass CmsGetComponentFromPage extends EntitySuccessAction {\n    constructor(payload) {\n        super(COMPONENT_ENTITY, [].concat(payload).map(cmp => cmp.component.uid));\n        this.payload = payload;\n        this.type = CMS_GET_COMPONENT_FROM_PAGE;\n    }\n}\n\nconst LOAD_CMS_NAVIGATION_ITEMS = '[Cms] Load NavigationEntry items';\nconst LOAD_CMS_NAVIGATION_ITEMS_FAIL = '[Cms] Load NavigationEntry items Fail';\nconst LOAD_CMS_NAVIGATION_ITEMS_SUCCESS = '[Cms] Load NavigationEntry items Success';\nclass LoadCmsNavigationItems extends EntityLoadAction {\n    constructor(payload) {\n        super(NAVIGATION_DETAIL_ENTITY, payload.nodeId);\n        this.payload = payload;\n        this.type = LOAD_CMS_NAVIGATION_ITEMS;\n    }\n}\nclass LoadCmsNavigationItemsFail extends EntityFailAction {\n    constructor(nodeId, payload) {\n        super(NAVIGATION_DETAIL_ENTITY, nodeId, payload);\n        this.payload = payload;\n        this.type = LOAD_CMS_NAVIGATION_ITEMS_FAIL;\n    }\n}\nclass LoadCmsNavigationItemsSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(NAVIGATION_DETAIL_ENTITY, payload.nodeId);\n        this.payload = payload;\n        this.type = LOAD_CMS_NAVIGATION_ITEMS_SUCCESS;\n    }\n}\n\nconst LOAD_CMS_PAGE_DATA = '[Cms] Load Page Data';\nconst LOAD_CMS_PAGE_DATA_FAIL = '[Cms] Load Page Data Fail';\nconst LOAD_CMS_PAGE_DATA_SUCCESS = '[Cms] Load Page Data Success';\nconst CMS_SET_PAGE_SUCCESS_INDEX = '[Cms] Set Page Success Index';\nconst CMS_SET_PAGE_FAIL_INDEX = '[Cms] Set Page Fail Index';\nclass LoadCmsPageData extends EntityLoadAction {\n    constructor(payload) {\n        super(payload.type, payload.id);\n        this.payload = payload;\n        this.type = LOAD_CMS_PAGE_DATA;\n    }\n}\nclass LoadCmsPageDataFail extends EntityFailAction {\n    constructor(pageContext, error) {\n        super(pageContext.type, pageContext.id, error);\n        this.type = LOAD_CMS_PAGE_DATA_FAIL;\n    }\n}\nclass LoadCmsPageDataSuccess extends EntitySuccessAction {\n    constructor(pageContext, payload) {\n        super(pageContext.type, pageContext.id, payload);\n        this.type = LOAD_CMS_PAGE_DATA_SUCCESS;\n    }\n}\nclass CmsSetPageSuccessIndex extends EntitySuccessAction {\n    constructor(pageContext, payload) {\n        super(pageContext.type, pageContext.id, payload);\n        this.type = CMS_SET_PAGE_SUCCESS_INDEX;\n    }\n}\nclass CmsSetPageFailIndex extends EntityFailAction {\n    constructor(pageContext, payload) {\n        super(pageContext.type, pageContext.id);\n        this.payload = payload;\n        this.type = CMS_SET_PAGE_FAIL_INDEX;\n    }\n}\n\n\n\nvar cmsGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_CMS_COMPONENT: LOAD_CMS_COMPONENT,\n    LOAD_CMS_COMPONENT_FAIL: LOAD_CMS_COMPONENT_FAIL,\n    LOAD_CMS_COMPONENT_SUCCESS: LOAD_CMS_COMPONENT_SUCCESS,\n    CMS_GET_COMPONENT_FROM_PAGE: CMS_GET_COMPONENT_FROM_PAGE,\n    LoadCmsComponent: LoadCmsComponent,\n    LoadCmsComponentFail: LoadCmsComponentFail,\n    LoadCmsComponentSuccess: LoadCmsComponentSuccess,\n    CmsGetComponentFromPage: CmsGetComponentFromPage,\n    LOAD_CMS_NAVIGATION_ITEMS: LOAD_CMS_NAVIGATION_ITEMS,\n    LOAD_CMS_NAVIGATION_ITEMS_FAIL: LOAD_CMS_NAVIGATION_ITEMS_FAIL,\n    LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: LOAD_CMS_NAVIGATION_ITEMS_SUCCESS,\n    LoadCmsNavigationItems: LoadCmsNavigationItems,\n    LoadCmsNavigationItemsFail: LoadCmsNavigationItemsFail,\n    LoadCmsNavigationItemsSuccess: LoadCmsNavigationItemsSuccess,\n    LOAD_CMS_PAGE_DATA: LOAD_CMS_PAGE_DATA,\n    LOAD_CMS_PAGE_DATA_FAIL: LOAD_CMS_PAGE_DATA_FAIL,\n    LOAD_CMS_PAGE_DATA_SUCCESS: LOAD_CMS_PAGE_DATA_SUCCESS,\n    CMS_SET_PAGE_SUCCESS_INDEX: CMS_SET_PAGE_SUCCESS_INDEX,\n    CMS_SET_PAGE_FAIL_INDEX: CMS_SET_PAGE_FAIL_INDEX,\n    LoadCmsPageData: LoadCmsPageData,\n    LoadCmsPageDataFail: LoadCmsPageDataFail,\n    LoadCmsPageDataSuccess: LoadCmsPageDataSuccess,\n    CmsSetPageSuccessIndex: CmsSetPageSuccessIndex,\n    CmsSetPageFailIndex: CmsSetPageFailIndex\n});\n\nconst getCmsState = createFeatureSelector(CMS_FEATURE);\n\nconst ɵ0$x = state => state.components;\nconst getComponentsState = createSelector(getCmsState, ɵ0$x);\nconst componentsContextSelectorFactory = (uid) => {\n    return createSelector(getComponentsState, componentsState => entitySelector(componentsState, uid));\n};\nconst componentsLoaderStateSelectorFactory = (uid, context) => {\n    return createSelector(componentsContextSelectorFactory(uid), componentsContext => (componentsContext &&\n        componentsContext.pageContext &&\n        componentsContext.pageContext[context]) ||\n        initialLoaderState);\n};\nconst componentsContextExistsSelectorFactory = (uid, context) => {\n    return createSelector(componentsLoaderStateSelectorFactory(uid, context), loaderState => loaderValueSelector(loaderState) || false);\n};\nconst componentsDataSelectorFactory = (uid) => {\n    return createSelector(componentsContextSelectorFactory(uid), state => (state ? state.component : undefined));\n};\nconst componentsSelectorFactory = (uid, context) => {\n    return createSelector(componentsDataSelectorFactory(uid), componentsContextExistsSelectorFactory(uid, context), (componentState, exists) => {\n        if (componentState && exists) {\n            return componentState;\n        }\n        else {\n            return undefined;\n        }\n    });\n};\n\nconst ɵ0$y = (state) => state.navigation;\nconst getNavigationEntryItemState = createSelector(getCmsState, ɵ0$y);\nconst getSelectedNavigationEntryItemState = (nodeId) => {\n    return createSelector(getNavigationEntryItemState, nodes => entityStateSelector(nodes, nodeId));\n};\nconst getNavigationEntryItems = (nodeId) => {\n    return createSelector(getSelectedNavigationEntryItemState(nodeId), itemState => loaderValueSelector(itemState));\n};\n\nconst getPageEntitiesSelector = (state) => state.pageData.entities;\nconst ɵ0$z = getPageEntitiesSelector;\nconst getIndexByType = (index, type) => {\n    switch (type) {\n        case PageType.CONTENT_PAGE: {\n            return index.content;\n        }\n        case PageType.PRODUCT_PAGE: {\n            return index.product;\n        }\n        case PageType.CATEGORY_PAGE: {\n            return index.category;\n        }\n        case PageType.CATALOG_PAGE: {\n            return index.catalog;\n        }\n    }\n    return { entities: {} };\n};\nconst ɵ1$p = getIndexByType;\nconst getPageComponentTypesSelector = (page) => {\n    const componentTypes = new Set();\n    if (page && page.slots) {\n        for (const slot of Object.keys(page.slots)) {\n            for (const component of page.slots[slot].components || []) {\n                componentTypes.add(component.flexType);\n            }\n        }\n    }\n    return Array.from(componentTypes);\n};\nconst ɵ2$i = getPageComponentTypesSelector;\nconst ɵ3$a = (state) => state.page;\nconst getPageState = createSelector(getCmsState, ɵ3$a);\nconst ɵ4$3 = (page) => page.index;\nconst getPageStateIndex = createSelector(getPageState, ɵ4$3);\nconst getPageStateIndexEntityLoaderState = (pageContext) => createSelector(getPageStateIndex, (index) => getIndexByType(index, pageContext.type));\nconst getPageStateIndexLoaderState = (pageContext) => createSelector(getPageStateIndexEntityLoaderState(pageContext), indexState => entityStateSelector(indexState, pageContext.id));\nconst getPageStateIndexValue = (pageContext) => createSelector(getPageStateIndexLoaderState(pageContext), entity => loaderValueSelector(entity));\nconst getPageEntities = createSelector(getPageState, getPageEntitiesSelector);\nconst getPageData = (pageContext) => createSelector(getPageEntities, getPageStateIndexValue(pageContext), (entities, indexValue) => entities[indexValue]);\nconst getPageComponentTypes = (pageContext) => createSelector(getPageData(pageContext), pageData => getPageComponentTypesSelector(pageData));\nconst getCurrentSlotSelectorFactory = (pageContext, position) => {\n    return createSelector(getPageData(pageContext), entity => {\n        if (entity) {\n            return entity.slots[position] || { components: [] };\n        }\n    });\n};\n\n\n\nvar cmsGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getComponentsState: getComponentsState,\n    componentsContextSelectorFactory: componentsContextSelectorFactory,\n    componentsLoaderStateSelectorFactory: componentsLoaderStateSelectorFactory,\n    componentsContextExistsSelectorFactory: componentsContextExistsSelectorFactory,\n    componentsDataSelectorFactory: componentsDataSelectorFactory,\n    componentsSelectorFactory: componentsSelectorFactory,\n    ɵ0: ɵ0$x,\n    getCmsState: getCmsState,\n    getNavigationEntryItemState: getNavigationEntryItemState,\n    getSelectedNavigationEntryItemState: getSelectedNavigationEntryItemState,\n    getNavigationEntryItems: getNavigationEntryItems,\n    getPageState: getPageState,\n    getPageStateIndex: getPageStateIndex,\n    getPageStateIndexEntityLoaderState: getPageStateIndexEntityLoaderState,\n    getPageStateIndexLoaderState: getPageStateIndexLoaderState,\n    getPageStateIndexValue: getPageStateIndexValue,\n    getPageEntities: getPageEntities,\n    getPageData: getPageData,\n    getPageComponentTypes: getPageComponentTypes,\n    getCurrentSlotSelectorFactory: getCurrentSlotSelectorFactory,\n    ɵ1: ɵ1$p,\n    ɵ2: ɵ2$i,\n    ɵ3: ɵ3$a,\n    ɵ4: ɵ4$3\n});\n\nconst CURRENT_CONTEXT_KEY = 'current';\n/**\n *\n * Serializes the provided page context.\n * The pattern used for serialization is: `pageContext.type-pageContext.id`.\n *\n * @param pageContext to serialize\n * @param ignoreContentPageId if set to true, and the PageType is of type ContentPage, then the serialized page context will not contain the ID.\n * Otherwise, the page context if fully serialized.\n */\nfunction serializePageContext(pageContext, ignoreContentPageId) {\n    if (!pageContext) {\n        return CURRENT_CONTEXT_KEY;\n    }\n    if (ignoreContentPageId && pageContext.type === PageType.CONTENT_PAGE) {\n        return `${pageContext.type}`;\n    }\n    return `${pageContext.type}-${pageContext.id}`;\n}\n\nlet CmsService = class CmsService {\n    constructor(store, routingService) {\n        this.store = store;\n        this.routingService = routingService;\n        this._launchInSmartEdit = false;\n        this.components = {};\n    }\n    /**\n     * Set _launchInSmartEdit value\n     */\n    set launchInSmartEdit(value) {\n        this._launchInSmartEdit = value;\n    }\n    /**\n     * Whether the app launched in smart edit\n     */\n    isLaunchInSmartEdit() {\n        return this._launchInSmartEdit;\n    }\n    /**\n     * Get current CMS page data\n     */\n    getCurrentPage() {\n        return this.routingService\n            .getPageContext()\n            .pipe(switchMap(pageContext => this.store.select(getPageData(pageContext))));\n    }\n    /**\n     * Get CMS component data by uid\n     *\n     * This method can be safely and optimally used to load multiple components data at the same time.\n     * Calling getComponentData multiple times for different components will always result in optimized\n     * back-end request: all components requested at the same time (in one event loop) will be loaded in one network call.\n     *\n     * In case the component data is not present, the method will load it.\n     * Otherwise, if the page context is not provided, the current page context from the router state will be used instead.\n     *\n     * @param uid CMS component uid\n     * @param pageContext if provided, it will be used to lookup the component data.\n     */\n    getComponentData(uid, pageContext) {\n        const context = serializePageContext(pageContext, true);\n        if (!this.components[uid]) {\n            // create the component data structure, if it doesn't already exist\n            this.components[uid] = {};\n        }\n        const component = this.components[uid];\n        if (!component[context]) {\n            // create the component data and assign it to the component's context\n            component[context] = this.createComponentData(uid, pageContext);\n        }\n        return component[context];\n    }\n    createComponentData(uid, pageContext) {\n        if (!pageContext) {\n            return this.routingService.getPageContext().pipe(filter(currentContext => !!currentContext), switchMap(currentContext => this.getComponentData(uid, currentContext)));\n        }\n        const context = serializePageContext(pageContext, true);\n        const loading$ = combineLatest([\n            this.routingService.getNextPageContext(),\n            this.store.pipe(select(componentsLoaderStateSelectorFactory(uid, context))),\n        ]).pipe(observeOn(queueScheduler), tap(([nextContext, loadingState]) => {\n            const attemptedLoad = loadingState.loading || loadingState.success || loadingState.error;\n            // if the requested context is the same as the one that's currently being navigated to\n            // (as it might already been triggered and might be available shortly from page data)\n            // TODO(issue:3649), TODO(issue:3668) - this optimization could be removed\n            const couldBeLoadedWithPageData = nextContext\n                ? serializePageContext(nextContext, true) === context\n                : false;\n            if (!attemptedLoad && !couldBeLoadedWithPageData) {\n                this.store.dispatch(new LoadCmsComponent({ uid, pageContext }));\n            }\n        }));\n        const component$ = this.store.pipe(select(componentsSelectorFactory(uid, context)), \n        // TODO(issue:6431) - this `filter` should be removed.\n        // The reason for removal: with `filter` in place, when moving to a page that has restrictions, the component data will still emit the previous value.\n        // Removing it causes some components to fail, because they are not checking\n        // if the data is actually there. I noticed these that this component is failing, but there are possibly more:\n        // - `tab-paragraph-container.component.ts` when visiting any PDP page\n        filter(component => !!component));\n        return using(() => loading$.subscribe(), () => component$).pipe(shareReplay({ bufferSize: 1, refCount: true }));\n    }\n    /**\n     * Given the position, get the content slot data\n     * @param position : content slot position\n     */\n    getContentSlot(position) {\n        return this.routingService.getPageContext().pipe(switchMap(pageContext => this.store.pipe(select(getCurrentSlotSelectorFactory(pageContext, position)), filter(Boolean))));\n    }\n    /**\n     * Given navigation node uid, get items (with id and type) inside the navigation entries\n     * @param navigationNodeUid : uid of the navigation node\n     */\n    getNavigationEntryItems(navigationNodeUid) {\n        return this.store.pipe(select(getNavigationEntryItems(navigationNodeUid)));\n    }\n    /**\n     * Load navigation items data\n     * @param rootUid : the uid of the root navigation node\n     * @param itemList : list of items (with id and type)\n     */\n    loadNavigationItems(rootUid, itemList) {\n        this.store.dispatch(new LoadCmsNavigationItems({\n            nodeId: rootUid,\n            items: itemList,\n        }));\n    }\n    /**\n     * Refresh the content of the latest cms page\n     */\n    refreshLatestPage() {\n        this.routingService\n            .getPageContext()\n            .pipe(take(1))\n            .subscribe(pageContext => this.store.dispatch(new LoadCmsPageData(pageContext)));\n    }\n    /**\n     * Refresh the cms page content by page Id\n     * @param pageId\n     */\n    refreshPageById(pageId) {\n        const pageContext = { id: pageId };\n        this.store.dispatch(new LoadCmsPageData(pageContext));\n    }\n    /**\n     * Refresh cms component's content\n     * @param uid component uid\n     * @param pageContext an optional parameter that enables the caller to specify for which context the component should be refreshed.\n     * If not specified, 'current' page context is used.\n     */\n    refreshComponent(uid, pageContext) {\n        this.store.dispatch(new LoadCmsComponent({ uid, pageContext }));\n    }\n    /**\n     * Given pageContext, return the CMS page data\n     * @param pageContext\n     */\n    getPageState(pageContext) {\n        return this.store.pipe(select(getPageData(pageContext)));\n    }\n    /**\n     * Given pageContext, return the CMS page data\n     * @param pageContext\n     */\n    getPageComponentTypes(pageContext) {\n        return this.store.pipe(select(getPageComponentTypes(pageContext)));\n    }\n    /**\n     * Given pageContext, return whether the CMS page data exists or not\n     * @param pageContext\n     */\n    hasPage(pageContext, forceReload = false) {\n        return this.store.pipe(select(getPageStateIndexLoaderState(pageContext)), tap((entity) => {\n            const attemptedLoad = entity.loading || entity.success || entity.error;\n            const shouldReload = forceReload && !entity.loading;\n            if (!attemptedLoad || shouldReload) {\n                this.store.dispatch(new LoadCmsPageData(pageContext));\n                forceReload = false;\n            }\n        }), filter(entity => {\n            if (!entity.hasOwnProperty('value')) {\n                // if we have incomplete state from SSR failed load transfer state,\n                // we should wait for reload and actual value\n                return false;\n            }\n            return entity.success || (entity.error && !entity.loading);\n        }), pluck('success'), catchError(() => of(false)));\n    }\n    /**\n     * Given pageContext, return the CMS page data\n     **/\n    getPage(pageContext, forceReload = false) {\n        return this.hasPage(pageContext, forceReload).pipe(switchMap(hasPage => hasPage ? this.getPageState(pageContext) : of(null)));\n    }\n    getPageIndex(pageContext) {\n        return this.store.pipe(select(getPageStateIndexValue(pageContext)));\n    }\n    setPageFailIndex(pageContext, value) {\n        this.store.dispatch(new CmsSetPageFailIndex(pageContext, value));\n    }\n};\nCmsService.ctorParameters = () => [\n    { type: Store },\n    { type: RoutingService }\n];\nCmsService.ɵprov = ɵɵdefineInjectable({ factory: function CmsService_Factory() { return new CmsService(ɵɵinject(Store), ɵɵinject(RoutingService)); }, token: CmsService, providedIn: \"root\" });\nCmsService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CmsService);\n\nvar PageRobotsMeta;\n(function (PageRobotsMeta) {\n    PageRobotsMeta[\"INDEX\"] = \"INDEX\";\n    PageRobotsMeta[\"NOINDEX\"] = \"NOINDEX\";\n    PageRobotsMeta[\"FOLLOW\"] = \"FOLLOW\";\n    PageRobotsMeta[\"NOFOLLOW\"] = \"NOFOLLOW\";\n})(PageRobotsMeta || (PageRobotsMeta = {}));\n\n/**\n * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`\n * and the `CartPageTemplate`. If the cart page matches this template, the more generic\n * `ContentPageMetaResolver` is overriden by this resolver.\n *\n * The page title and robots are resolved in this implementation only.\n */\nlet CartPageMetaResolver = class CartPageMetaResolver extends PageMetaResolver {\n    constructor(cms) {\n        super();\n        this.cms = cms;\n        this.cms$ = this.cms\n            .getCurrentPage()\n            .pipe(filter(page => !!page));\n        this.pageType = PageType.CONTENT_PAGE;\n        this.pageTemplate = 'CartPageTemplate';\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return this.cms$.pipe(switchMap(page => combineLatest([this.resolveTitle(page), this.resolveRobots()])), map(([title, robots]) => ({ title, robots })));\n    }\n    resolveTitle(page) {\n        return page ? of(page.title) : this.cms$.pipe(map(p => p.title));\n    }\n    resolveRobots() {\n        return of([PageRobotsMeta.NOFOLLOW, PageRobotsMeta.NOINDEX]);\n    }\n};\nCartPageMetaResolver.ctorParameters = () => [\n    { type: CmsService }\n];\nCartPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function CartPageMetaResolver_Factory() { return new CartPageMetaResolver(ɵɵinject(CmsService)); }, token: CartPageMetaResolver, providedIn: \"root\" });\nCartPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CartPageMetaResolver);\n\nlet CartEntryConnector = class CartEntryConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    add(userId, cartId, productCode, quantity) {\n        return this.adapter.add(userId, cartId, productCode, quantity);\n    }\n    update(userId, cartId, entryNumber, qty, pickupStore) {\n        return this.adapter.update(userId, cartId, entryNumber, qty, pickupStore);\n    }\n    remove(userId, cartId, entryNumber) {\n        return this.adapter.remove(userId, cartId, entryNumber);\n    }\n};\nCartEntryConnector.ctorParameters = () => [\n    { type: CartEntryAdapter }\n];\nCartEntryConnector.ɵprov = ɵɵdefineInjectable({ factory: function CartEntryConnector_Factory() { return new CartEntryConnector(ɵɵinject(CartEntryAdapter)); }, token: CartEntryConnector, providedIn: \"root\" });\nCartEntryConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CartEntryConnector);\n\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx effects will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nlet CartEntryEffects = class CartEntryEffects {\n    constructor(actions$, cartEntryConnector) {\n        this.actions$ = actions$;\n        this.cartEntryConnector = cartEntryConnector;\n        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n        this.addEntry$ = this.actions$.pipe(ofType(CART_ADD_ENTRY), map((action) => action.payload), concatMap(payload => {\n            return this.cartEntryConnector\n                .add(payload.userId, payload.cartId, payload.productCode, payload.quantity)\n                .pipe(map((entry) => new CartAddEntrySuccess(Object.assign(Object.assign({}, entry), { userId: payload.userId, cartId: payload.cartId }))), catchError(error => from([\n                new CartAddEntryFail(makeErrorSerializable(error)),\n                new CartProcessesDecrement(payload.cartId),\n                new LoadCart({\n                    cartId: payload.cartId,\n                    userId: payload.userId,\n                }),\n            ])));\n        }), withdrawOn(this.contextChange$));\n        this.removeEntry$ = this.actions$.pipe(ofType(CART_REMOVE_ENTRY), map((action) => action.payload), concatMap(payload => this.cartEntryConnector\n            .remove(payload.userId, payload.cartId, payload.entry)\n            .pipe(map(() => {\n            return new CartRemoveEntrySuccess({\n                userId: payload.userId,\n                cartId: payload.cartId,\n            });\n        }), catchError(error => from([\n            new CartRemoveEntryFail(makeErrorSerializable(error)),\n            new CartProcessesDecrement(payload.cartId),\n            new LoadCart({\n                cartId: payload.cartId,\n                userId: payload.userId,\n            }),\n        ])))), withdrawOn(this.contextChange$));\n        this.updateEntry$ = this.actions$.pipe(ofType(CART_UPDATE_ENTRY), map((action) => action.payload), concatMap(payload => this.cartEntryConnector\n            .update(payload.userId, payload.cartId, payload.entry, payload.qty)\n            .pipe(map(() => {\n            return new CartUpdateEntrySuccess({\n                userId: payload.userId,\n                cartId: payload.cartId,\n            });\n        }), catchError(error => from([\n            new CartUpdateEntryFail(makeErrorSerializable(error)),\n            new CartProcessesDecrement(payload.cartId),\n            new LoadCart({\n                cartId: payload.cartId,\n                userId: payload.userId,\n            }),\n        ])))), withdrawOn(this.contextChange$));\n    }\n};\nCartEntryEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CartEntryConnector }\n];\n__decorate([\n    Effect()\n], CartEntryEffects.prototype, \"addEntry$\", void 0);\n__decorate([\n    Effect()\n], CartEntryEffects.prototype, \"removeEntry$\", void 0);\n__decorate([\n    Effect()\n], CartEntryEffects.prototype, \"updateEntry$\", void 0);\nCartEntryEffects = __decorate([\n    Injectable()\n], CartEntryEffects);\n\nlet CartVoucherConnector = class CartVoucherConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    add(userId, cartId, voucherId) {\n        return this.adapter.add(userId, cartId, voucherId);\n    }\n    remove(userId, cartId, voucherId) {\n        return this.adapter.remove(userId, cartId, voucherId);\n    }\n};\nCartVoucherConnector.ctorParameters = () => [\n    { type: CartVoucherAdapter }\n];\nCartVoucherConnector.ɵprov = ɵɵdefineInjectable({ factory: function CartVoucherConnector_Factory() { return new CartVoucherConnector(ɵɵinject(CartVoucherAdapter)); }, token: CartVoucherConnector, providedIn: \"root\" });\nCartVoucherConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CartVoucherConnector);\n\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx effects will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nlet CartVoucherEffects = class CartVoucherEffects {\n    constructor(actions$, cartVoucherConnector, messageService) {\n        this.actions$ = actions$;\n        this.cartVoucherConnector = cartVoucherConnector;\n        this.messageService = messageService;\n        this.addCartVoucher$ = this.actions$.pipe(ofType(CART_ADD_VOUCHER), map((action) => action.payload), mergeMap(payload => {\n            return this.cartVoucherConnector\n                .add(payload.userId, payload.cartId, payload.voucherId)\n                .pipe(map(() => {\n                this.showGlobalMessage('voucher.applyVoucherSuccess', payload.voucherId, GlobalMessageType.MSG_TYPE_CONFIRMATION);\n                return new CartAddVoucherSuccess({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                });\n            }), catchError(error => from([\n                new CartAddVoucherFail(makeErrorSerializable(error)),\n                new CartProcessesDecrement(payload.cartId),\n                new LoadCart({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                }),\n            ])));\n        }));\n        this.removeCartVoucher$ = this.actions$.pipe(ofType(CART_REMOVE_VOUCHER), map((action) => action.payload), mergeMap(payload => {\n            return this.cartVoucherConnector\n                .remove(payload.userId, payload.cartId, payload.voucherId)\n                .pipe(map(() => {\n                this.showGlobalMessage('voucher.removeVoucherSuccess', payload.voucherId, GlobalMessageType.MSG_TYPE_INFO);\n                return new CartRemoveVoucherSuccess({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                });\n            }), catchError(error => from([\n                new CartRemoveVoucherFail(makeErrorSerializable(error)),\n                new CartProcessesDecrement(payload.cartId),\n                new LoadCart({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                }),\n            ])));\n        }));\n    }\n    showGlobalMessage(text, param, messageType) {\n        this.messageService.add({ key: text, params: { voucherCode: param } }, messageType);\n    }\n};\nCartVoucherEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CartVoucherConnector },\n    { type: GlobalMessageService }\n];\n__decorate([\n    Effect()\n], CartVoucherEffects.prototype, \"addCartVoucher$\", void 0);\n__decorate([\n    Effect()\n], CartVoucherEffects.prototype, \"removeCartVoucher$\", void 0);\nCartVoucherEffects = __decorate([\n    Injectable()\n], CartVoucherEffects);\n\nconst VERIFY_ADDRESS = '[Checkout] Verify Address';\nconst VERIFY_ADDRESS_FAIL = '[Checkout] Verify Address Fail';\nconst VERIFY_ADDRESS_SUCCESS = '[Checkout] Verify Address Success';\nconst CLEAR_ADDRESS_VERIFICATION_RESULTS = '[Checkout] Clear Address Verification Results';\nclass VerifyAddress {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = VERIFY_ADDRESS;\n    }\n}\nclass VerifyAddressFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = VERIFY_ADDRESS_FAIL;\n    }\n}\nclass VerifyAddressSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = VERIFY_ADDRESS_SUCCESS;\n    }\n}\nclass ClearAddressVerificationResults {\n    constructor() {\n        this.type = CLEAR_ADDRESS_VERIFICATION_RESULTS;\n    }\n}\n\nconst LOAD_CARD_TYPES = '[Checkout] Load Card Types';\nconst LOAD_CARD_TYPES_FAIL = '[Checkout] Load Card Fail';\nconst LOAD_CARD_TYPES_SUCCESS = '[Checkout] Load Card Success';\nclass LoadCardTypes {\n    constructor() {\n        this.type = LOAD_CARD_TYPES;\n    }\n}\nclass LoadCardTypesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CARD_TYPES_FAIL;\n    }\n}\nclass LoadCardTypesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_CARD_TYPES_SUCCESS;\n    }\n}\n\nconst CHECKOUT_FEATURE = 'checkout';\nconst CHECKOUT_DETAILS = '[Checkout] Checkout Details';\nconst SET_DELIVERY_ADDRESS_PROCESS_ID = 'setDeliveryAddress';\nconst SET_DELIVERY_MODE_PROCESS_ID = 'setDeliveryMode';\nconst SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID = 'setSupportedDeliveryMode';\nconst SET_PAYMENT_DETAILS_PROCESS_ID = 'setPaymentDetails';\n\nconst CLEAR_CHECKOUT_DELIVERY_ADDRESS = '[Checkout] Clear Checkout Delivery Address';\nconst CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Clear Checkout Delivery Address Success';\nconst CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL = '[Checkout] Clear Checkout Delivery Address Fail';\nconst CLEAR_CHECKOUT_DELIVERY_MODE = '[Checkout] Clear Checkout Delivery Mode';\nconst CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS = '[Checkout] Clear Checkout Delivery Mode Success';\nconst CLEAR_CHECKOUT_DELIVERY_MODE_FAIL = '[Checkout] Clear Checkout Delivery Mode Fail';\nconst ADD_DELIVERY_ADDRESS = '[Checkout] Add Delivery Address';\nconst ADD_DELIVERY_ADDRESS_FAIL = '[Checkout] Add Delivery Address Fail';\nconst ADD_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Add Delivery Address Success';\nconst SET_DELIVERY_ADDRESS = '[Checkout] Set Delivery Address';\nconst SET_DELIVERY_ADDRESS_FAIL = '[Checkout] Set Delivery Address Fail';\nconst SET_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Set Delivery Address Success';\nconst RESET_SET_DELIVERY_ADDRESS_PROCESS = '[Checkout] Reset Set Delivery Address Process';\nconst LOAD_SUPPORTED_DELIVERY_MODES = '[Checkout] Load Supported Delivery Modes';\nconst LOAD_SUPPORTED_DELIVERY_MODES_FAIL = '[Checkout] Load Supported Delivery Modes Fail';\nconst LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS = '[Checkout] Load Supported Delivery Modes Success';\nconst CLEAR_SUPPORTED_DELIVERY_MODES = '[Checkout] Clear Supported Delivery Modes';\nconst SET_DELIVERY_MODE = '[Checkout] Set Delivery Mode';\nconst SET_DELIVERY_MODE_FAIL = '[Checkout] Set Delivery Mode Fail';\nconst SET_DELIVERY_MODE_SUCCESS = '[Checkout] Set Delivery Mode Success';\nconst RESET_SET_DELIVERY_MODE_PROCESS = '[Checkout] Reset Set Delivery Mode Process';\nconst SET_SUPPORTED_DELIVERY_MODES = '[Checkout] Set Supported Delivery Modes';\nconst SET_SUPPORTED_DELIVERY_MODES_FAIL = '[Checkout] Set Supported Delivery Modes Fail';\nconst SET_SUPPORTED_DELIVERY_MODES_SUCCESS = '[Checkout] Set Supported Delivery Modes Success';\nconst RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS = '[Checkout] Reset Set Supported Delivery Modes Process';\nconst CREATE_PAYMENT_DETAILS = '[Checkout] Create Payment Details';\nconst CREATE_PAYMENT_DETAILS_FAIL = '[Checkout] Create Payment Details Fail';\nconst CREATE_PAYMENT_DETAILS_SUCCESS = '[Checkout] Create Payment Details Success';\nconst SET_PAYMENT_DETAILS = '[Checkout] Set Payment Details';\nconst SET_PAYMENT_DETAILS_FAIL = '[Checkout] Set Payment Details Fail';\nconst SET_PAYMENT_DETAILS_SUCCESS = '[Checkout] Set Payment Details Success';\nconst RESET_SET_PAYMENT_DETAILS_PROCESS = '[Checkout] Reset Set Payment Details Process';\nconst PLACE_ORDER = '[Checkout] Place Order';\nconst PLACE_ORDER_FAIL = '[Checkout] Place Order Fail';\nconst PLACE_ORDER_SUCCESS = '[Checkout] Place Order Success';\nconst CLEAR_CHECKOUT_STEP = '[Checkout] Clear One Checkout Step';\nconst CLEAR_CHECKOUT_DATA = '[Checkout] Clear Checkout Data';\nconst LOAD_CHECKOUT_DETAILS = '[Checkout] Load Checkout Details';\nconst LOAD_CHECKOUT_DETAILS_FAIL = '[Checkout] Load Checkout Details Fail';\nconst LOAD_CHECKOUT_DETAILS_SUCCESS = '[Checkout] Load Checkout Details Success';\nconst CHECKOUT_CLEAR_MISCS_DATA = '[Checkout] Clear Miscs Data';\nconst PAYMENT_PROCESS_SUCCESS = '[Checkout] Payment Process Success';\nclass AddDeliveryAddress {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ADD_DELIVERY_ADDRESS;\n    }\n}\nclass AddDeliveryAddressFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ADD_DELIVERY_ADDRESS_FAIL;\n    }\n}\nclass AddDeliveryAddressSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = ADD_DELIVERY_ADDRESS_SUCCESS;\n    }\n}\nclass SetDeliveryAddress extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);\n        this.payload = payload;\n        this.type = SET_DELIVERY_ADDRESS;\n    }\n}\nclass SetDeliveryAddressFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = SET_DELIVERY_ADDRESS_FAIL;\n    }\n}\nclass SetDeliveryAddressSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);\n        this.payload = payload;\n        this.type = SET_DELIVERY_ADDRESS_SUCCESS;\n    }\n}\nclass ResetSetDeliveryAddressProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);\n        this.type = RESET_SET_DELIVERY_ADDRESS_PROCESS;\n    }\n}\nclass LoadSupportedDeliveryModes extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);\n        this.payload = payload;\n        this.type = LOAD_SUPPORTED_DELIVERY_MODES;\n    }\n}\nclass LoadSupportedDeliveryModesFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);\n        this.payload = payload;\n        this.type = LOAD_SUPPORTED_DELIVERY_MODES_FAIL;\n    }\n}\nclass LoadSupportedDeliveryModesSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);\n        this.payload = payload;\n        this.type = LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS;\n    }\n}\nclass ResetLoadSupportedDeliveryModesProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);\n        this.type = RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS;\n    }\n}\nclass SetDeliveryMode extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);\n        this.payload = payload;\n        this.type = SET_DELIVERY_MODE;\n    }\n}\nclass SetDeliveryModeFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = SET_DELIVERY_MODE_FAIL;\n    }\n}\nclass SetDeliveryModeSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);\n        this.payload = payload;\n        this.type = SET_DELIVERY_MODE_SUCCESS;\n    }\n}\nclass ResetSetDeliveryModeProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);\n        this.type = RESET_SET_DELIVERY_MODE_PROCESS;\n    }\n}\nclass CreatePaymentDetails extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);\n        this.payload = payload;\n        this.type = CREATE_PAYMENT_DETAILS;\n    }\n}\nclass CreatePaymentDetailsFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);\n        this.payload = payload;\n        this.type = CREATE_PAYMENT_DETAILS_FAIL;\n    }\n}\nclass CreatePaymentDetailsSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CREATE_PAYMENT_DETAILS_SUCCESS;\n    }\n}\nclass PaymentProcessSuccess extends EntitySuccessAction {\n    constructor() {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);\n        this.type = PAYMENT_PROCESS_SUCCESS;\n    }\n}\nclass SetPaymentDetails extends EntityLoadAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);\n        this.payload = payload;\n        this.type = SET_PAYMENT_DETAILS;\n    }\n}\nclass SetPaymentDetailsFail extends EntityFailAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID, payload);\n        this.payload = payload;\n        this.type = SET_PAYMENT_DETAILS_FAIL;\n    }\n}\nclass SetPaymentDetailsSuccess extends EntitySuccessAction {\n    constructor(payload) {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);\n        this.payload = payload;\n        this.type = SET_PAYMENT_DETAILS_SUCCESS;\n    }\n}\nclass ResetSetPaymentDetailsProcess extends EntityResetAction {\n    constructor() {\n        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);\n        this.type = RESET_SET_PAYMENT_DETAILS_PROCESS;\n    }\n}\nclass PlaceOrder {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = PLACE_ORDER;\n    }\n}\nclass PlaceOrderFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = PLACE_ORDER_FAIL;\n    }\n}\nclass PlaceOrderSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = PLACE_ORDER_SUCCESS;\n    }\n}\nclass ClearSupportedDeliveryModes {\n    constructor() {\n        this.type = CLEAR_SUPPORTED_DELIVERY_MODES;\n    }\n}\nclass ClearCheckoutStep {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_CHECKOUT_STEP;\n    }\n}\nclass ClearCheckoutData {\n    constructor() {\n        this.type = CLEAR_CHECKOUT_DATA;\n    }\n}\nclass LoadCheckoutDetails extends LoaderLoadAction {\n    constructor(payload) {\n        super(CHECKOUT_DETAILS);\n        this.payload = payload;\n        this.type = LOAD_CHECKOUT_DETAILS;\n    }\n}\nclass LoadCheckoutDetailsFail extends LoaderFailAction {\n    constructor(payload) {\n        super(CHECKOUT_DETAILS, payload);\n        this.payload = payload;\n        this.type = LOAD_CHECKOUT_DETAILS_FAIL;\n    }\n}\nclass LoadCheckoutDetailsSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(CHECKOUT_DETAILS);\n        this.payload = payload;\n        this.type = LOAD_CHECKOUT_DETAILS_SUCCESS;\n    }\n}\nclass CheckoutClearMiscsData {\n    constructor() {\n        this.type = CHECKOUT_CLEAR_MISCS_DATA;\n    }\n}\nclass ClearCheckoutDeliveryAddress {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS;\n    }\n}\nclass ClearCheckoutDeliveryAddressSuccess {\n    constructor() {\n        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS;\n    }\n}\nclass ClearCheckoutDeliveryAddressFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL;\n    }\n}\nclass ClearCheckoutDeliveryMode {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_CHECKOUT_DELIVERY_MODE;\n    }\n}\nclass ClearCheckoutDeliveryModeSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS;\n    }\n}\nclass ClearCheckoutDeliveryModeFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = CLEAR_CHECKOUT_DELIVERY_MODE_FAIL;\n    }\n}\n\n\n\nvar checkoutGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    VERIFY_ADDRESS: VERIFY_ADDRESS,\n    VERIFY_ADDRESS_FAIL: VERIFY_ADDRESS_FAIL,\n    VERIFY_ADDRESS_SUCCESS: VERIFY_ADDRESS_SUCCESS,\n    CLEAR_ADDRESS_VERIFICATION_RESULTS: CLEAR_ADDRESS_VERIFICATION_RESULTS,\n    VerifyAddress: VerifyAddress,\n    VerifyAddressFail: VerifyAddressFail,\n    VerifyAddressSuccess: VerifyAddressSuccess,\n    ClearAddressVerificationResults: ClearAddressVerificationResults,\n    LOAD_CARD_TYPES: LOAD_CARD_TYPES,\n    LOAD_CARD_TYPES_FAIL: LOAD_CARD_TYPES_FAIL,\n    LOAD_CARD_TYPES_SUCCESS: LOAD_CARD_TYPES_SUCCESS,\n    LoadCardTypes: LoadCardTypes,\n    LoadCardTypesFail: LoadCardTypesFail,\n    LoadCardTypesSuccess: LoadCardTypesSuccess,\n    CLEAR_CHECKOUT_DELIVERY_ADDRESS: CLEAR_CHECKOUT_DELIVERY_ADDRESS,\n    CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS: CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS,\n    CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL: CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL,\n    CLEAR_CHECKOUT_DELIVERY_MODE: CLEAR_CHECKOUT_DELIVERY_MODE,\n    CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS: CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS,\n    CLEAR_CHECKOUT_DELIVERY_MODE_FAIL: CLEAR_CHECKOUT_DELIVERY_MODE_FAIL,\n    ADD_DELIVERY_ADDRESS: ADD_DELIVERY_ADDRESS,\n    ADD_DELIVERY_ADDRESS_FAIL: ADD_DELIVERY_ADDRESS_FAIL,\n    ADD_DELIVERY_ADDRESS_SUCCESS: ADD_DELIVERY_ADDRESS_SUCCESS,\n    SET_DELIVERY_ADDRESS: SET_DELIVERY_ADDRESS,\n    SET_DELIVERY_ADDRESS_FAIL: SET_DELIVERY_ADDRESS_FAIL,\n    SET_DELIVERY_ADDRESS_SUCCESS: SET_DELIVERY_ADDRESS_SUCCESS,\n    RESET_SET_DELIVERY_ADDRESS_PROCESS: RESET_SET_DELIVERY_ADDRESS_PROCESS,\n    LOAD_SUPPORTED_DELIVERY_MODES: LOAD_SUPPORTED_DELIVERY_MODES,\n    LOAD_SUPPORTED_DELIVERY_MODES_FAIL: LOAD_SUPPORTED_DELIVERY_MODES_FAIL,\n    LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS: LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS,\n    CLEAR_SUPPORTED_DELIVERY_MODES: CLEAR_SUPPORTED_DELIVERY_MODES,\n    SET_DELIVERY_MODE: SET_DELIVERY_MODE,\n    SET_DELIVERY_MODE_FAIL: SET_DELIVERY_MODE_FAIL,\n    SET_DELIVERY_MODE_SUCCESS: SET_DELIVERY_MODE_SUCCESS,\n    RESET_SET_DELIVERY_MODE_PROCESS: RESET_SET_DELIVERY_MODE_PROCESS,\n    SET_SUPPORTED_DELIVERY_MODES: SET_SUPPORTED_DELIVERY_MODES,\n    SET_SUPPORTED_DELIVERY_MODES_FAIL: SET_SUPPORTED_DELIVERY_MODES_FAIL,\n    SET_SUPPORTED_DELIVERY_MODES_SUCCESS: SET_SUPPORTED_DELIVERY_MODES_SUCCESS,\n    RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS: RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS,\n    CREATE_PAYMENT_DETAILS: CREATE_PAYMENT_DETAILS,\n    CREATE_PAYMENT_DETAILS_FAIL: CREATE_PAYMENT_DETAILS_FAIL,\n    CREATE_PAYMENT_DETAILS_SUCCESS: CREATE_PAYMENT_DETAILS_SUCCESS,\n    SET_PAYMENT_DETAILS: SET_PAYMENT_DETAILS,\n    SET_PAYMENT_DETAILS_FAIL: SET_PAYMENT_DETAILS_FAIL,\n    SET_PAYMENT_DETAILS_SUCCESS: SET_PAYMENT_DETAILS_SUCCESS,\n    RESET_SET_PAYMENT_DETAILS_PROCESS: RESET_SET_PAYMENT_DETAILS_PROCESS,\n    PLACE_ORDER: PLACE_ORDER,\n    PLACE_ORDER_FAIL: PLACE_ORDER_FAIL,\n    PLACE_ORDER_SUCCESS: PLACE_ORDER_SUCCESS,\n    CLEAR_CHECKOUT_STEP: CLEAR_CHECKOUT_STEP,\n    CLEAR_CHECKOUT_DATA: CLEAR_CHECKOUT_DATA,\n    LOAD_CHECKOUT_DETAILS: LOAD_CHECKOUT_DETAILS,\n    LOAD_CHECKOUT_DETAILS_FAIL: LOAD_CHECKOUT_DETAILS_FAIL,\n    LOAD_CHECKOUT_DETAILS_SUCCESS: LOAD_CHECKOUT_DETAILS_SUCCESS,\n    CHECKOUT_CLEAR_MISCS_DATA: CHECKOUT_CLEAR_MISCS_DATA,\n    PAYMENT_PROCESS_SUCCESS: PAYMENT_PROCESS_SUCCESS,\n    AddDeliveryAddress: AddDeliveryAddress,\n    AddDeliveryAddressFail: AddDeliveryAddressFail,\n    AddDeliveryAddressSuccess: AddDeliveryAddressSuccess,\n    SetDeliveryAddress: SetDeliveryAddress,\n    SetDeliveryAddressFail: SetDeliveryAddressFail,\n    SetDeliveryAddressSuccess: SetDeliveryAddressSuccess,\n    ResetSetDeliveryAddressProcess: ResetSetDeliveryAddressProcess,\n    LoadSupportedDeliveryModes: LoadSupportedDeliveryModes,\n    LoadSupportedDeliveryModesFail: LoadSupportedDeliveryModesFail,\n    LoadSupportedDeliveryModesSuccess: LoadSupportedDeliveryModesSuccess,\n    ResetLoadSupportedDeliveryModesProcess: ResetLoadSupportedDeliveryModesProcess,\n    SetDeliveryMode: SetDeliveryMode,\n    SetDeliveryModeFail: SetDeliveryModeFail,\n    SetDeliveryModeSuccess: SetDeliveryModeSuccess,\n    ResetSetDeliveryModeProcess: ResetSetDeliveryModeProcess,\n    CreatePaymentDetails: CreatePaymentDetails,\n    CreatePaymentDetailsFail: CreatePaymentDetailsFail,\n    CreatePaymentDetailsSuccess: CreatePaymentDetailsSuccess,\n    PaymentProcessSuccess: PaymentProcessSuccess,\n    SetPaymentDetails: SetPaymentDetails,\n    SetPaymentDetailsFail: SetPaymentDetailsFail,\n    SetPaymentDetailsSuccess: SetPaymentDetailsSuccess,\n    ResetSetPaymentDetailsProcess: ResetSetPaymentDetailsProcess,\n    PlaceOrder: PlaceOrder,\n    PlaceOrderFail: PlaceOrderFail,\n    PlaceOrderSuccess: PlaceOrderSuccess,\n    ClearSupportedDeliveryModes: ClearSupportedDeliveryModes,\n    ClearCheckoutStep: ClearCheckoutStep,\n    ClearCheckoutData: ClearCheckoutData,\n    LoadCheckoutDetails: LoadCheckoutDetails,\n    LoadCheckoutDetailsFail: LoadCheckoutDetailsFail,\n    LoadCheckoutDetailsSuccess: LoadCheckoutDetailsSuccess,\n    CheckoutClearMiscsData: CheckoutClearMiscsData,\n    ClearCheckoutDeliveryAddress: ClearCheckoutDeliveryAddress,\n    ClearCheckoutDeliveryAddressSuccess: ClearCheckoutDeliveryAddressSuccess,\n    ClearCheckoutDeliveryAddressFail: ClearCheckoutDeliveryAddressFail,\n    ClearCheckoutDeliveryMode: ClearCheckoutDeliveryMode,\n    ClearCheckoutDeliveryModeSuccess: ClearCheckoutDeliveryModeSuccess,\n    ClearCheckoutDeliveryModeFail: ClearCheckoutDeliveryModeFail\n});\n\nlet CartConnector = class CartConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    loadAll(userId) {\n        return this.adapter.loadAll(userId);\n    }\n    load(userId, cartId) {\n        return this.adapter.load(userId, cartId);\n    }\n    create(userId, oldCartId, toMergeCartGuid) {\n        return this.adapter.create(userId, oldCartId, toMergeCartGuid);\n    }\n    delete(userId, cartId) {\n        return this.adapter.delete(userId, cartId);\n    }\n    addEmail(userId, cartId, email) {\n        return this.adapter.addEmail(userId, cartId, email);\n    }\n};\nCartConnector.ctorParameters = () => [\n    { type: CartAdapter }\n];\nCartConnector.ɵprov = ɵɵdefineInjectable({ factory: function CartConnector_Factory() { return new CartConnector(ɵɵinject(CartAdapter)); }, token: CartConnector, providedIn: \"root\" });\nCartConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CartConnector);\n\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx effects will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nlet CartEffects = class CartEffects {\n    constructor(actions$, cartConnector, cartData, store) {\n        this.actions$ = actions$;\n        this.cartConnector = cartConnector;\n        this.cartData = cartData;\n        this.store = store;\n        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n        this.loadCart$ = this.actions$.pipe(ofType(LOAD_CART), map((action) => action.payload), groupBy(payload => payload.cartId), mergeMap(group$ => group$.pipe(switchMap(payload => {\n            return of(payload).pipe(withLatestFrom(\n            // TODO: deprecated -> remove check for store in 2.0 when store will be required\n            !this.store\n                ? of(false)\n                : this.store.pipe(select(getCartHasPendingProcessesSelectorFactory(payload.cartId)))));\n        }), filter(([_, hasPendingProcesses]) => !hasPendingProcesses), map(([payload]) => payload), switchMap(payload => {\n            const loadCartParams = {\n                userId: (payload && payload.userId) || this.cartData.userId,\n                cartId: (payload && payload.cartId) || this.cartData.cartId,\n            };\n            if (this.isMissingData(loadCartParams)) {\n                return from([\n                    new LoadCartFail({}),\n                    new LoadMultiCartFail({\n                        cartId: loadCartParams.cartId,\n                    }),\n                ]);\n            }\n            return this.cartConnector\n                .load(loadCartParams.userId, loadCartParams.cartId)\n                .pipe(\n            // TODO: remove with the `cart` store feature\n            withLatestFrom(\n            // TODO: deprecated -> remove check for store in 2.0 when store will be required\n            !this.store\n                ? of(payload.cartId)\n                : this.store.pipe(select(getActiveCartId))), mergeMap(([cart, activeCartId]) => {\n                let actions = [];\n                if (cart) {\n                    // `cart` store branch should only be updated for active cart\n                    // avoid dispatching LoadCartSuccess action on different cart loads\n                    if (loadCartParams.cartId === activeCartId ||\n                        loadCartParams.cartId === OCC_CART_ID_CURRENT) {\n                        actions.push(new LoadCartSuccess(cart));\n                    }\n                    actions.push(new LoadMultiCartSuccess({\n                        cart,\n                        userId: loadCartParams.userId,\n                        extraData: payload.extraData,\n                    }));\n                    if (loadCartParams.cartId === OCC_CART_ID_CURRENT) {\n                        // Removing cart from entity object under `current` key as it is no longer needed.\n                        // Current cart is loaded under it's code entity.\n                        actions.push(new RemoveCart(OCC_CART_ID_CURRENT));\n                    }\n                }\n                else {\n                    actions = [\n                        new LoadCartFail({}),\n                        new LoadMultiCartFail({\n                            cartId: loadCartParams.cartId,\n                        }),\n                    ];\n                }\n                return actions;\n            }), catchError(error => {\n                const couponExpiredErrors = error.error.errors.filter(err => err.reason === 'invalid');\n                if (couponExpiredErrors.length > 0) {\n                    // clear coupons actions just wanted to reload cart again\n                    // no need to do it in refresh or keep that action\n                    // however removing this action will be a breaking change\n                    // remove that action in 2.0 release\n                    // @deprecated since 1.4\n                    return from([\n                        new LoadCart(Object.assign({}, payload)),\n                        new ClearExpiredCoupons({}),\n                    ]);\n                }\n                if (error && error.error && error.error.errors) {\n                    const cartNotFoundErrors = error.error.errors.filter(err => err.reason === 'notFound' || 'UnknownResourceError');\n                    if (cartNotFoundErrors.length > 0 &&\n                        payload.extraData &&\n                        payload.extraData.active) {\n                        // Clear cart is responsible for removing cart in `cart` store feature.\n                        // Remove cart does the same thing, but in `multi-cart` store feature.\n                        return from([\n                            new ClearCart(),\n                            new RemoveCart(loadCartParams.cartId),\n                        ]);\n                    }\n                }\n                return from([\n                    new LoadCartFail(makeErrorSerializable(error)),\n                    new LoadMultiCartFail({\n                        cartId: loadCartParams.cartId,\n                        error: makeErrorSerializable(error),\n                    }),\n                ]);\n            }));\n        }))), withdrawOn(this.contextChange$));\n        this.createCart$ = this.actions$.pipe(ofType(CREATE_CART), map((action) => action.payload), mergeMap(payload => {\n            return this.cartConnector\n                .create(payload.userId, payload.oldCartId, payload.toMergeCartGuid)\n                .pipe(switchMap((cart) => {\n                const conditionalActions = [];\n                if (payload.oldCartId) {\n                    conditionalActions.push(new MergeCartSuccess({\n                        userId: payload.userId,\n                        cartId: cart.code,\n                    }));\n                    conditionalActions.push(new MergeMultiCartSuccess({\n                        userId: payload.userId,\n                        cartId: cart.code,\n                        oldCartId: payload.oldCartId,\n                    }));\n                }\n                // `cart` store branch should only be updated for active cart\n                // avoid dispatching CreateCartSuccess action on different cart loads\n                if (payload.extraData && payload.extraData.active) {\n                    conditionalActions.push(new CreateCartSuccess(cart));\n                }\n                return [\n                    new CreateMultiCartSuccess({\n                        cart,\n                        userId: payload.userId,\n                        extraData: payload.extraData,\n                    }),\n                    new SetTempCart({\n                        cart,\n                        tempCartId: payload.tempCartId,\n                    }),\n                    ...conditionalActions,\n                ];\n            }), catchError(error => from([\n                new CreateCartFail(makeErrorSerializable(error)),\n                new CreateMultiCartFail({\n                    tempCartId: payload.tempCartId,\n                    error: makeErrorSerializable(error),\n                }),\n            ])));\n        }), withdrawOn(this.contextChange$));\n        this.mergeCart$ = this.actions$.pipe(ofType(MERGE_CART), map((action) => action.payload), mergeMap(payload => {\n            return this.cartConnector.load(payload.userId, OCC_CART_ID_CURRENT).pipe(mergeMap(currentCart => {\n                return [\n                    new CreateCart({\n                        userId: payload.userId,\n                        oldCartId: payload.cartId,\n                        toMergeCartGuid: currentCart ? currentCart.guid : undefined,\n                        extraData: payload.extraData,\n                        tempCartId: payload.tempCartId,\n                    }),\n                ];\n            }));\n        }), withdrawOn(this.contextChange$));\n        this.refresh$ = this.actions$.pipe(ofType(CART_ADD_ENTRY_SUCCESS, CART_UPDATE_ENTRY_SUCCESS, CART_REMOVE_ENTRY_SUCCESS, ADD_EMAIL_TO_CART_SUCCESS, CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS, CART_ADD_VOUCHER_SUCCESS, CART_REMOVE_VOUCHER_SUCCESS), map((action) => action.payload), concatMap(payload => from([\n            new CartProcessesDecrement(payload.cartId),\n            new LoadCart({\n                userId: payload.userId,\n                cartId: payload.cartId,\n            }),\n        ])));\n        this.refreshWithoutProcesses$ = this.actions$.pipe(ofType(MERGE_CART_SUCCESS), map((action) => action.payload), map(payload => new LoadCart({\n            userId: payload.userId,\n            cartId: payload.cartId,\n        })));\n        this.resetCartDetailsOnSiteContextChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), mergeMap(() => {\n            return [\n                new ResetCartDetails(),\n                new ResetMultiCartDetails(),\n            ];\n        }));\n        this.addEmail$ = this.actions$.pipe(ofType(ADD_EMAIL_TO_CART), map((action) => action.payload), mergeMap(payload => this.cartConnector\n            .addEmail(payload.userId, payload.cartId, payload.email)\n            .pipe(mergeMap(() => {\n            return [\n                new AddEmailToCartSuccess({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                }),\n                new AddEmailToMultiCartSuccess({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                }),\n            ];\n        }), catchError(error => from([\n            new AddEmailToCartFail(makeErrorSerializable(error)),\n            new AddEmailToMultiCartFail({\n                error: makeErrorSerializable(error),\n                userId: payload.userId,\n                cartId: payload.cartId,\n            }),\n            new CartProcessesDecrement(payload.cartId),\n            new LoadCart({\n                userId: payload.userId,\n                cartId: payload.cartId,\n            }),\n        ])))), withdrawOn(this.contextChange$));\n        this.deleteCart$ = this.actions$.pipe(ofType(DELETE_CART), map((action) => action.payload), exhaustMap(payload => this.cartConnector.delete(payload.userId, payload.cartId).pipe(map(() => {\n            return new ClearCart();\n        }), catchError(error => of(new DeleteCartFail(makeErrorSerializable(error)))))));\n    }\n    isMissingData(payload) {\n        return payload.userId === undefined || payload.cartId === undefined;\n    }\n};\nCartEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CartConnector },\n    { type: CartDataService },\n    { type: Store }\n];\n__decorate([\n    Effect()\n], CartEffects.prototype, \"loadCart$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"createCart$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"mergeCart$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"refresh$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"refreshWithoutProcesses$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"resetCartDetailsOnSiteContextChange$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"addEmail$\", void 0);\n__decorate([\n    Effect()\n], CartEffects.prototype, \"deleteCart$\", void 0);\nCartEffects = __decorate([\n    Injectable()\n], CartEffects);\n\nlet SaveCartConnector = class SaveCartConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    saveCart(userId, cartId, saveCartName, saveCartDescription) {\n        return this.adapter.saveCart(userId, cartId, saveCartName, saveCartDescription);\n    }\n};\nSaveCartConnector.ctorParameters = () => [\n    { type: SaveCartAdapter }\n];\nSaveCartConnector.ɵprov = ɵɵdefineInjectable({ factory: function SaveCartConnector_Factory() { return new SaveCartConnector(ɵɵinject(SaveCartAdapter)); }, token: SaveCartConnector, providedIn: \"root\" });\nSaveCartConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SaveCartConnector);\n\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx effects will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nlet WishListEffects = class WishListEffects {\n    constructor(actions$, cartConnector, saveCartConnector, authService, store) {\n        this.actions$ = actions$;\n        this.cartConnector = cartConnector;\n        this.saveCartConnector = saveCartConnector;\n        this.authService = authService;\n        this.store = store;\n        this.createWishList$ = this.actions$.pipe(ofType(CREATE_WISH_LIST), map((action) => action.payload), switchMap(payload => {\n            return this.cartConnector.create(payload.userId).pipe(switchMap(cart => {\n                return this.saveCartConnector\n                    .saveCart(payload.userId, cart.code, payload.name, payload.description)\n                    .pipe(switchMap(saveCartResult => [\n                    new CreateWishListSuccess({\n                        cart: saveCartResult.savedCartData,\n                        userId: payload.userId,\n                    }),\n                ]), catchError(error => from([\n                    new CreateWishListFail({\n                        cartId: cart.code,\n                        error: makeErrorSerializable(error),\n                    }),\n                ])));\n            }));\n        }));\n        this.loadWishList$ = this.actions$.pipe(ofType(LOAD_WISH_LIST), map((action) => action.payload), concatMap(payload => {\n            const { userId, customerId } = payload;\n            return this.cartConnector.loadAll(userId).pipe(switchMap(carts => {\n                if (carts) {\n                    const wishList = carts.find(cart => cart.name === `wishlist${customerId}`);\n                    if (Boolean(wishList)) {\n                        return [\n                            new LoadWishListSuccess({\n                                cart: wishList,\n                                userId,\n                            }),\n                        ];\n                    }\n                    else {\n                        return [\n                            new CreateWishList({\n                                userId,\n                                name: `wishlist${customerId}`,\n                            }),\n                        ];\n                    }\n                }\n            }), catchError(error => from([new LoadCartFail(makeErrorSerializable(error))])));\n        }));\n        this.resetWishList$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), withLatestFrom(this.authService.getOccUserId(), this.store.pipe(select(getWishListId))), switchMap(([, userId, wishListId]) => {\n            if (Boolean(wishListId)) {\n                return this.cartConnector.load(userId, wishListId).pipe(switchMap(wishList => [\n                    new LoadWishListSuccess({ cart: wishList, userId }),\n                ]), catchError(error => from([new LoadCartFail(makeErrorSerializable(error))])));\n            }\n            return EMPTY;\n        }));\n    }\n};\nWishListEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CartConnector },\n    { type: SaveCartConnector },\n    { type: AuthService },\n    { type: Store }\n];\n__decorate([\n    Effect()\n], WishListEffects.prototype, \"createWishList$\", void 0);\n__decorate([\n    Effect()\n], WishListEffects.prototype, \"loadWishList$\", void 0);\n__decorate([\n    Effect()\n], WishListEffects.prototype, \"resetWishList$\", void 0);\nWishListEffects = __decorate([\n    Injectable()\n], WishListEffects);\n\nconst initialState$9 = {\n    content: {},\n    entries: {},\n    refresh: false,\n    cartMergeComplete: false,\n};\nfunction reducer$9(state = initialState$9, action) {\n    switch (action.type) {\n        case MERGE_CART: {\n            return Object.assign(Object.assign({}, state), { cartMergeComplete: false });\n        }\n        case MERGE_CART_SUCCESS: {\n            return Object.assign(Object.assign({}, state), { cartMergeComplete: true, refresh: true });\n        }\n        case LOAD_CART_SUCCESS:\n        case CREATE_CART_SUCCESS: {\n            const content = Object.assign({}, action.payload);\n            let entries = {};\n            if (content.entries) {\n                entries = content.entries.reduce((entryMap, entry) => {\n                    return Object.assign(Object.assign({}, entryMap), { \n                        /*\n                        If we refresh the page from cart details page, 2 load cart\n                        Actions gets dispatched. One is non-detail, and the second is detailed.\n                        In the case where the detailed once get resolved first, we merge the existing\n                        data with the new data from the response (to not delete existing detailed data).\n                        */\n                        [entry.product.code]: state.entries && state.entries[entry.product.code]\n                            ? Object.assign(Object.assign({}, state.entries[entry.product.code]), entry) : entry });\n                }, Object.assign({}, entries));\n                delete content['entries'];\n            }\n            return Object.assign(Object.assign({}, state), { content,\n                entries, refresh: false });\n        }\n        case CART_ADD_VOUCHER_SUCCESS:\n        case CART_REMOVE_VOUCHER_SUCCESS:\n        case CART_REMOVE_ENTRY_SUCCESS:\n        case CART_UPDATE_ENTRY_SUCCESS:\n        case CART_ADD_ENTRY_SUCCESS:\n        case ADD_EMAIL_TO_CART_SUCCESS: {\n            return Object.assign(Object.assign({}, state), { refresh: true });\n        }\n        case RESET_CART_DETAILS: {\n            return {\n                content: {\n                    guid: state.content.guid,\n                    code: state.content.code,\n                    user: state.content.user,\n                },\n                entries: {},\n                refresh: false,\n                cartMergeComplete: false,\n            };\n        }\n        case CLEAR_CART: {\n            return initialState$9;\n        }\n    }\n    return state;\n}\n\nconst activeCartInitialState = '';\nconst wishListInitialState = '';\nfunction activeCartReducer(state = activeCartInitialState, action) {\n    switch (action.type) {\n        case LOAD_MULTI_CART_SUCCESS:\n        case CREATE_MULTI_CART_SUCCESS:\n        // point to `temp-${uuid}` cart when we are creating/merging cart\n        case CREATE_MULTI_CART:\n            if (action.payload &&\n                action.payload.extraData &&\n                action.payload.extraData.active) {\n                return action.meta.entityId;\n            }\n            else {\n                return state;\n            }\n        case REMOVE_CART:\n            if (action.payload === state) {\n                return activeCartInitialState;\n            }\n            else {\n                return state;\n            }\n    }\n    return state;\n}\nconst cartEntitiesInitialState = undefined;\nfunction cartEntitiesReducer(state = cartEntitiesInitialState, action) {\n    switch (action.type) {\n        case LOAD_MULTI_CART_SUCCESS:\n        case CREATE_MULTI_CART_SUCCESS:\n        case CREATE_WISH_LIST_SUCCESS:\n        case LOAD_WISH_LIST_SUCCESS:\n        case SET_TEMP_CART:\n            return action.payload.cart;\n    }\n    return state;\n}\nfunction wishListReducer(state = wishListInitialState, action) {\n    switch (action.type) {\n        case CREATE_WISH_LIST_SUCCESS:\n        case LOAD_WISH_LIST_SUCCESS:\n            return action.meta.entityId;\n    }\n    return state;\n}\n\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nfunction getReducers$5() {\n    return {\n        active: loaderReducer(CART_DATA, reducer$9),\n    };\n}\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst reducerToken$5 = new InjectionToken('CartReducers');\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst reducerProvider$5 = {\n    provide: reducerToken$5,\n    useFactory: getReducers$5,\n};\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nfunction clearCartState(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT ||\n            action.type === PLACE_ORDER_SUCCESS) {\n            state = undefined;\n        }\n        return reducer(state, action);\n    };\n}\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst metaReducers$3 = [clearCartState];\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nfunction clearMultiCartState(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT) {\n            state = undefined;\n        }\n        return reducer(state, action);\n    };\n}\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst multiCartMetaReducers = [clearMultiCartState];\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst multiCartReducerToken = new InjectionToken('MultiCartReducers');\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nfunction getMultiCartReducers() {\n    return {\n        carts: entityProcessesLoaderReducer(MULTI_CART_FEATURE, cartEntitiesReducer),\n        active: activeCartReducer,\n        wishList: wishListReducer,\n    };\n}\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx reducers will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst multiCartReducerProvider = {\n    provide: multiCartReducerToken,\n    useFactory: getMultiCartReducers,\n};\n\nconst effects$4 = [\n    CartEffects,\n    CartEntryEffects,\n    CartVoucherEffects,\n    WishListEffects,\n];\nfunction cartStoreConfigFactory() {\n    const config = {\n        state: {\n            storageSync: {\n                keys: {\n                    [`${CART_FEATURE}.active.value.content.guid`]: StorageSyncType.LOCAL_STORAGE,\n                    [`${CART_FEATURE}.active.value.content.code`]: StorageSyncType.LOCAL_STORAGE,\n                    [`${CART_FEATURE}.active.value.content.user`]: StorageSyncType.LOCAL_STORAGE,\n                },\n            },\n        },\n    };\n    return config;\n}\nlet CartStoreModule = class CartStoreModule {\n};\nCartStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StateModule,\n            StoreModule.forFeature(CART_FEATURE, reducerToken$5, { metaReducers: metaReducers$3 }),\n            EffectsModule.forFeature(effects$4),\n            ConfigModule.withConfigFactory(cartStoreConfigFactory),\n        ],\n        providers: [reducerProvider$5],\n    })\n], CartStoreModule);\n\nlet MultiCartEffects = class MultiCartEffects {\n    constructor(actions$) {\n        this.actions$ = actions$;\n        this.loadCart2$ = this.actions$.pipe(ofType(LOAD_CART), map((action) => new LoadMultiCart(action.payload)));\n        this.createCart2$ = this.actions$.pipe(ofType(CREATE_CART), map((action) => new CreateMultiCart(action.payload)));\n        this.setTempCart$ = this.actions$.pipe(ofType(SET_TEMP_CART), map((action) => {\n            return new RemoveTempCart(action.payload);\n        }));\n        this.mergeCart2$ = this.actions$.pipe(ofType(MERGE_CART), map((action) => new MergeMultiCart(action.payload)));\n        this.addEmail2$ = this.actions$.pipe(ofType(ADD_EMAIL_TO_CART), map((action) => new AddEmailToMultiCart(action.payload)));\n        this.removeCart$ = this.actions$.pipe(ofType(DELETE_CART), map((action) => action.payload), map(payload => new RemoveCart(payload.cartId)));\n        // TODO: Change actions to extend Increment action instead of doing extra dispatch in this effect\n        // Change for 2.0 release\n        this.processesIncrement$ = this.actions$.pipe(ofType(CART_ADD_ENTRY, CART_UPDATE_ENTRY, CART_REMOVE_ENTRY, ADD_EMAIL_TO_CART, CLEAR_CHECKOUT_DELIVERY_MODE, CART_ADD_VOUCHER, CART_REMOVE_VOUCHER), map((action) => action.payload), map(payload => new CartProcessesIncrement(payload.cartId)));\n    }\n};\nMultiCartEffects.ctorParameters = () => [\n    { type: Actions }\n];\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"loadCart2$\", void 0);\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"createCart2$\", void 0);\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"setTempCart$\", void 0);\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"mergeCart2$\", void 0);\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"addEmail2$\", void 0);\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"removeCart$\", void 0);\n__decorate([\n    Effect()\n], MultiCartEffects.prototype, \"processesIncrement$\", void 0);\nMultiCartEffects = __decorate([\n    Injectable()\n], MultiCartEffects);\n\nfunction multiCartStoreConfigFactory() {\n    const config = {\n        state: {\n            storageSync: {\n                keys: {\n                    [`${MULTI_CART_FEATURE}.active`]: StorageSyncType.LOCAL_STORAGE,\n                },\n            },\n        },\n    };\n    return config;\n}\nlet MultiCartStoreModule = class MultiCartStoreModule {\n};\nMultiCartStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            StateModule,\n            StoreModule.forFeature(MULTI_CART_FEATURE, multiCartReducerToken, {\n                metaReducers: multiCartMetaReducers,\n            }),\n            EffectsModule.forFeature([MultiCartEffects]),\n            ConfigModule.withConfigFactory(multiCartStoreConfigFactory),\n        ],\n        providers: [multiCartReducerProvider],\n    })\n], MultiCartStoreModule);\n\nvar CartModule_1;\nlet CartModule = CartModule_1 = class CartModule {\n    static forRoot() {\n        return {\n            ngModule: CartModule_1,\n            providers: [\n                CartDataService,\n                CartVoucherService,\n                CartService,\n                MultiCartService,\n                WishListService,\n                ActiveCartService,\n                SelectiveCartService,\n                {\n                    provide: PageMetaResolver,\n                    useExisting: CartPageMetaResolver,\n                    multi: true,\n                },\n            ],\n        };\n    }\n};\nCartModule = CartModule_1 = __decorate([\n    NgModule({\n        imports: [CartStoreModule, MultiCartStoreModule],\n    })\n], CartModule);\n\n/**\n * @deprecated since version 1.5\n *\n * spartacus ngrx effects will no longer be a part of public API\n *\n * TODO(issue:#4507)\n */\nconst effects$5 = [\n    CartEffects,\n    CartEntryEffects,\n    CartVoucherEffects,\n    WishListEffects,\n];\n\nconst initialState$a = {\n    results: {},\n};\nfunction reducer$a(state = initialState$a, action) {\n    switch (action.type) {\n        case VERIFY_ADDRESS_SUCCESS: {\n            const results = action.payload;\n            return Object.assign(Object.assign({}, state), { results });\n        }\n        case VERIFY_ADDRESS_FAIL: {\n            return Object.assign(Object.assign({}, state), { results: 'FAIL' });\n        }\n        case CLEAR_ADDRESS_VERIFICATION_RESULTS: {\n            return Object.assign(Object.assign({}, state), { results: {} });\n        }\n    }\n    return state;\n}\nconst getAddressVerificationResults = (state) => state.results;\n\nconst getDeliveryAddressSelector = (state) => state.address;\nconst ɵ0$A = getDeliveryAddressSelector;\nconst getDeliveryModeSelector = (state) => state.deliveryMode;\nconst ɵ1$q = getDeliveryModeSelector;\nconst getPaymentDetailsSelector = (state) => state.paymentDetails;\nconst ɵ2$j = getPaymentDetailsSelector;\nconst getOrderDetailsSelector = (state) => state.orderDetails;\nconst ɵ3$b = getOrderDetailsSelector;\nconst getCheckoutState = createFeatureSelector(CHECKOUT_FEATURE);\nconst ɵ4$4 = (checkoutState) => checkoutState.steps;\nconst getCheckoutStepsState = createSelector(getCheckoutState, ɵ4$4);\nconst ɵ5$3 = state => loaderValueSelector(state);\nconst getCheckoutSteps = createSelector(getCheckoutStepsState, ɵ5$3);\nconst getDeliveryAddress = createSelector(getCheckoutSteps, getDeliveryAddressSelector);\nconst getDeliveryMode = createSelector(getCheckoutSteps, getDeliveryModeSelector);\nconst ɵ6$1 = deliveryMode => {\n    return (deliveryMode &&\n        Object.keys(deliveryMode.supported).map(code => deliveryMode.supported[code]));\n};\nconst getSupportedDeliveryModes = createSelector(getDeliveryMode, ɵ6$1);\nconst ɵ7$1 = deliveryMode => {\n    return deliveryMode && deliveryMode.selected;\n};\nconst getSelectedDeliveryModeCode = createSelector(getDeliveryMode, ɵ7$1);\nconst ɵ8$1 = deliveryMode => {\n    if (deliveryMode.selected !== '') {\n        if (Object.keys(deliveryMode.supported).length === 0) {\n            return null;\n        }\n        return deliveryMode.supported[deliveryMode.selected];\n    }\n};\nconst getSelectedDeliveryMode = createSelector(getDeliveryMode, ɵ8$1);\nconst getPaymentDetails = createSelector(getCheckoutSteps, getPaymentDetailsSelector);\nconst getCheckoutOrderDetails = createSelector(getCheckoutSteps, getOrderDetailsSelector);\nconst ɵ9$1 = state => loaderSuccessSelector(state) &&\n    !loaderLoadingSelector(state);\nconst getCheckoutDetailsLoaded = createSelector(getCheckoutStepsState, ɵ9$1);\n\nconst ɵ0$B = (state) => state.addressVerification;\nconst getAddressVerificationResultsState = createSelector(getCheckoutState, ɵ0$B);\nconst getAddressVerificationResults$1 = createSelector(getAddressVerificationResultsState, getAddressVerificationResults);\n\nconst initialState$b = {\n    entities: {},\n};\nfunction reducer$b(state = initialState$b, action) {\n    switch (action.type) {\n        case LOAD_CARD_TYPES_SUCCESS: {\n            const cardTypes = action.payload;\n            const entities = cardTypes.reduce((cardTypesEntities, name) => {\n                return Object.assign(Object.assign({}, cardTypesEntities), { [name.code]: name });\n            }, Object.assign({}, state.entities));\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n        case CHECKOUT_CLEAR_MISCS_DATA: {\n            return initialState$b;\n        }\n    }\n    return state;\n}\nconst getCardTypesEntites = (state) => state.entities;\n\nconst ɵ0$C = (state) => state.cardTypes;\nconst getCardTypesState = createSelector(getCheckoutState, ɵ0$C);\nconst getCardTypesEntites$1 = createSelector(getCardTypesState, getCardTypesEntites);\nconst ɵ1$r = entites => {\n    return Object.keys(entites).map(code => entites[code]);\n};\nconst getAllCardTypes = createSelector(getCardTypesEntites$1, ɵ1$r);\n\n\n\nvar checkoutGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getAddressVerificationResultsState: getAddressVerificationResultsState,\n    getAddressVerificationResults: getAddressVerificationResults$1,\n    ɵ0: ɵ0$B,\n    getCardTypesState: getCardTypesState,\n    getCardTypesEntites: getCardTypesEntites$1,\n    getAllCardTypes: getAllCardTypes,\n    ɵ1: ɵ1$r,\n    getCheckoutState: getCheckoutState,\n    getCheckoutStepsState: getCheckoutStepsState,\n    getCheckoutSteps: getCheckoutSteps,\n    getDeliveryAddress: getDeliveryAddress,\n    getDeliveryMode: getDeliveryMode,\n    getSupportedDeliveryModes: getSupportedDeliveryModes,\n    getSelectedDeliveryModeCode: getSelectedDeliveryModeCode,\n    getSelectedDeliveryMode: getSelectedDeliveryMode,\n    getPaymentDetails: getPaymentDetails,\n    getCheckoutOrderDetails: getCheckoutOrderDetails,\n    getCheckoutDetailsLoaded: getCheckoutDetailsLoaded,\n    ɵ2: ɵ2$j,\n    ɵ3: ɵ3$b,\n    ɵ4: ɵ4$4,\n    ɵ5: ɵ5$3,\n    ɵ6: ɵ6$1,\n    ɵ7: ɵ7$1,\n    ɵ8: ɵ8$1,\n    ɵ9: ɵ9$1\n});\n\nlet CheckoutService = class CheckoutService {\n    constructor(checkoutStore, cartData) {\n        this.checkoutStore = checkoutStore;\n        this.cartData = cartData;\n    }\n    /**\n     * Places an order\n     */\n    placeOrder() {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new PlaceOrder({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n            }));\n        }\n    }\n    /**\n     * Clear checkout data\n     */\n    clearCheckoutData() {\n        this.checkoutStore.dispatch(new ClearCheckoutData());\n    }\n    /**\n     * Clear checkout step\n     * @param stepNumber : the step number to be cleared\n     */\n    clearCheckoutStep(stepNumber) {\n        this.checkoutStore.dispatch(new ClearCheckoutStep(stepNumber));\n    }\n    /**\n     * Load checkout details data\n     * @param cartId : string Cart ID of loaded cart\n     */\n    loadCheckoutDetails(cartId) {\n        this.checkoutStore.dispatch(new LoadCheckoutDetails({\n            userId: this.cartData.userId,\n            cartId,\n        }));\n    }\n    /**\n     * Get status of checkout details loaded\n     */\n    getCheckoutDetailsLoaded() {\n        return this.checkoutStore.pipe(select(getCheckoutDetailsLoaded));\n    }\n    /**\n     * Get order details\n     */\n    getOrderDetails() {\n        return this.checkoutStore.pipe(select(getCheckoutOrderDetails));\n    }\n    actionAllowed() {\n        return (this.cartData.userId !== OCC_USER_ID_ANONYMOUS ||\n            this.cartData.isGuestCart);\n    }\n};\nCheckoutService.ctorParameters = () => [\n    { type: Store },\n    { type: CartDataService }\n];\nCheckoutService = __decorate([\n    Injectable()\n], CheckoutService);\n\nclass TranslationService {\n}\n\n/**\n * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`\n * and the `MultiStepCheckoutSummaryPageTemplate`. If the checkout page matches this template,\n * the more generic `ContentPageMetaResolver` is overriden by this resolver.\n *\n * The page title and robots are resolved in this implementation only.\n */\nlet CheckoutPageMetaResolver = class CheckoutPageMetaResolver extends PageMetaResolver {\n    constructor(cartService, translation) {\n        super();\n        this.cartService = cartService;\n        this.translation = translation;\n        this.cart$ = this.cartService.getActive();\n        this.pageType = PageType.CONTENT_PAGE;\n        this.pageTemplate = 'MultiStepCheckoutSummaryPageTemplate';\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return this.cart$.pipe(switchMap(cart => combineLatest([this.resolveTitle(cart), this.resolveRobots()])), map(([title, robots]) => ({ title, robots })));\n    }\n    resolveTitle(cart) {\n        const cart$ = cart ? of(cart) : this.cart$;\n        return cart$.pipe(switchMap(c => this.translation.translate('pageMetaResolver.checkout.title', {\n            count: c.totalItems,\n        })));\n    }\n    resolveRobots() {\n        return of([PageRobotsMeta.NOFOLLOW, PageRobotsMeta.NOINDEX]);\n    }\n};\nCheckoutPageMetaResolver.ctorParameters = () => [\n    { type: CartService },\n    { type: TranslationService }\n];\nCheckoutPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function CheckoutPageMetaResolver_Factory() { return new CheckoutPageMetaResolver(ɵɵinject(CartService), ɵɵinject(TranslationService)); }, token: CheckoutPageMetaResolver, providedIn: \"root\" });\nCheckoutPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CheckoutPageMetaResolver);\n\nconst initialState$c = {\n    address: {},\n    deliveryMode: {\n        supported: {},\n        selected: '',\n    },\n    paymentDetails: {},\n    orderDetails: {},\n};\nfunction reducer$c(state = initialState$c, action) {\n    switch (action.type) {\n        case ADD_DELIVERY_ADDRESS_SUCCESS:\n        case SET_DELIVERY_ADDRESS_SUCCESS: {\n            const address = action.payload;\n            return Object.assign(Object.assign({}, state), { address });\n        }\n        case LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS: {\n            const supportedModes = action.payload;\n            if (!supportedModes) {\n                return state;\n            }\n            const supported = supportedModes.reduce((modes, mode) => {\n                return Object.assign(Object.assign({}, modes), { [mode.code]: mode });\n            }, Object.assign({}, state.deliveryMode.supported));\n            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { supported }) });\n        }\n        case SET_DELIVERY_MODE_SUCCESS: {\n            const selected = action.payload;\n            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { selected }) });\n        }\n        case CREATE_PAYMENT_DETAILS_SUCCESS:\n        case SET_PAYMENT_DETAILS_SUCCESS: {\n            return Object.assign(Object.assign({}, state), { paymentDetails: action.payload });\n        }\n        case CREATE_PAYMENT_DETAILS_FAIL: {\n            const paymentDetails = action.payload;\n            if (paymentDetails['hasError']) {\n                return Object.assign(Object.assign({}, state), { paymentDetails });\n            }\n            return state;\n        }\n        case PLACE_ORDER_SUCCESS: {\n            const orderDetails = action.payload;\n            return Object.assign(Object.assign({}, state), { orderDetails });\n        }\n        case CLEAR_CHECKOUT_DATA: {\n            return initialState$c;\n        }\n        case CLEAR_CHECKOUT_STEP: {\n            const stepNumber = action.payload;\n            switch (stepNumber) {\n                case 1: {\n                    return Object.assign(Object.assign({}, state), { address: {} });\n                }\n                case 2: {\n                    return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { supported: {}, selected: '' }) });\n                }\n                case 3: {\n                    return Object.assign(Object.assign({}, state), { paymentDetails: {} });\n                }\n            }\n            return state;\n        }\n        case CLEAR_SUPPORTED_DELIVERY_MODES:\n        case CHECKOUT_CLEAR_MISCS_DATA: {\n            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { supported: {} }) });\n        }\n        case LOAD_CHECKOUT_DETAILS_SUCCESS: {\n            return Object.assign(Object.assign({}, state), { address: action.payload.deliveryAddress, deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { selected: action.payload.deliveryMode && action.payload.deliveryMode.code }), paymentDetails: action.payload.paymentInfo });\n        }\n        case CLEAR_CHECKOUT_DELIVERY_ADDRESS: {\n            return Object.assign(Object.assign({}, state), { address: {} });\n        }\n        case CLEAR_CHECKOUT_DELIVERY_MODE: {\n            return Object.assign(Object.assign({}, state), { deliveryMode: Object.assign(Object.assign({}, state.deliveryMode), { selected: '' }) });\n        }\n    }\n    return state;\n}\n\nfunction getReducers$6() {\n    return {\n        steps: loaderReducer(CHECKOUT_DETAILS, reducer$c),\n        cardTypes: reducer$b,\n        addressVerification: reducer$a,\n    };\n}\nconst reducerToken$6 = new InjectionToken('CheckoutReducers');\nconst reducerProvider$6 = {\n    provide: reducerToken$6,\n    useFactory: getReducers$6,\n};\n\nlet UserAddressConnector = class UserAddressConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    getAll(userId) {\n        return this.adapter.loadAll(userId);\n    }\n    add(userId, address) {\n        return this.adapter.add(userId, address);\n    }\n    update(userId, addressId, address) {\n        return this.adapter.update(userId, addressId, address);\n    }\n    verify(userId, address) {\n        return this.adapter.verify(userId, address);\n    }\n    delete(userId, addressId) {\n        return this.adapter.delete(userId, addressId);\n    }\n};\nUserAddressConnector.ctorParameters = () => [\n    { type: UserAddressAdapter }\n];\nUserAddressConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserAddressConnector_Factory() { return new UserAddressConnector(ɵɵinject(UserAddressAdapter)); }, token: UserAddressConnector, providedIn: \"root\" });\nUserAddressConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserAddressConnector);\n\nlet AddressVerificationEffect = class AddressVerificationEffect {\n    constructor(actions$, userAddressConnector) {\n        this.actions$ = actions$;\n        this.userAddressConnector = userAddressConnector;\n        this.verifyAddress$ = this.actions$.pipe(ofType(VERIFY_ADDRESS), map(action => action.payload), mergeMap(payload => this.userAddressConnector.verify(payload.userId, payload.address).pipe(map(data => new VerifyAddressSuccess(data)), catchError(error => of(new VerifyAddressFail(makeErrorSerializable(error)))))));\n    }\n};\nAddressVerificationEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: UserAddressConnector }\n];\n__decorate([\n    Effect()\n], AddressVerificationEffect.prototype, \"verifyAddress$\", void 0);\nAddressVerificationEffect = __decorate([\n    Injectable()\n], AddressVerificationEffect);\n\nlet CheckoutPaymentConnector = class CheckoutPaymentConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    create(userId, cartId, paymentDetails) {\n        return this.adapter.create(userId, cartId, paymentDetails);\n    }\n    set(userId, cartId, paymentDetailsId) {\n        return this.adapter.set(userId, cartId, paymentDetailsId);\n    }\n    getCardTypes() {\n        return this.adapter.loadCardTypes();\n    }\n};\nCheckoutPaymentConnector.ctorParameters = () => [\n    { type: CheckoutPaymentAdapter }\n];\nCheckoutPaymentConnector.ɵprov = ɵɵdefineInjectable({ factory: function CheckoutPaymentConnector_Factory() { return new CheckoutPaymentConnector(ɵɵinject(CheckoutPaymentAdapter)); }, token: CheckoutPaymentConnector, providedIn: \"root\" });\nCheckoutPaymentConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CheckoutPaymentConnector);\n\nlet CardTypesEffects = class CardTypesEffects {\n    constructor(actions$, checkoutPaymentConnector) {\n        this.actions$ = actions$;\n        this.checkoutPaymentConnector = checkoutPaymentConnector;\n        this.loadCardTypes$ = this.actions$.pipe(ofType(LOAD_CARD_TYPES), switchMap(() => {\n            return this.checkoutPaymentConnector.getCardTypes().pipe(map(cardTypes => new LoadCardTypesSuccess(cardTypes)), catchError(error => of(new LoadCardTypesFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nCardTypesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CheckoutPaymentConnector }\n];\n__decorate([\n    Effect()\n], CardTypesEffects.prototype, \"loadCardTypes$\", void 0);\nCardTypesEffects = __decorate([\n    Injectable()\n], CardTypesEffects);\n\nlet CheckoutConnector = class CheckoutConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    placeOrder(userId, cartId) {\n        return this.adapter.placeOrder(userId, cartId);\n    }\n    loadCheckoutDetails(userId, cartId) {\n        return this.adapter.loadCheckoutDetails(userId, cartId);\n    }\n    clearCheckoutDeliveryAddress(userId, cartId) {\n        return this.adapter.clearCheckoutDeliveryAddress(userId, cartId);\n    }\n    clearCheckoutDeliveryMode(userId, cartId) {\n        return this.adapter.clearCheckoutDeliveryMode(userId, cartId);\n    }\n};\nCheckoutConnector.ctorParameters = () => [\n    { type: CheckoutAdapter }\n];\nCheckoutConnector.ɵprov = ɵɵdefineInjectable({ factory: function CheckoutConnector_Factory() { return new CheckoutConnector(ɵɵinject(CheckoutAdapter)); }, token: CheckoutConnector, providedIn: \"root\" });\nCheckoutConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CheckoutConnector);\n\nlet CheckoutDeliveryConnector = class CheckoutDeliveryConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    createAddress(userId, cartId, address) {\n        return this.adapter.createAddress(userId, cartId, address);\n    }\n    setAddress(userId, cartId, addressId) {\n        return this.adapter.setAddress(userId, cartId, addressId);\n    }\n    setMode(userId, cartId, deliveryModeId) {\n        return this.adapter.setMode(userId, cartId, deliveryModeId);\n    }\n    getMode(userId, cartId) {\n        return this.adapter.getMode(userId, cartId);\n    }\n    getSupportedModes(userId, cartId) {\n        return this.adapter.getSupportedModes(userId, cartId);\n    }\n};\nCheckoutDeliveryConnector.ctorParameters = () => [\n    { type: CheckoutDeliveryAdapter }\n];\nCheckoutDeliveryConnector.ɵprov = ɵɵdefineInjectable({ factory: function CheckoutDeliveryConnector_Factory() { return new CheckoutDeliveryConnector(ɵɵinject(CheckoutDeliveryAdapter)); }, token: CheckoutDeliveryConnector, providedIn: \"root\" });\nCheckoutDeliveryConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CheckoutDeliveryConnector);\n\nlet CheckoutEffects = class CheckoutEffects {\n    constructor(actions$, checkoutDeliveryConnector, checkoutPaymentConnector, checkoutConnector) {\n        this.actions$ = actions$;\n        this.checkoutDeliveryConnector = checkoutDeliveryConnector;\n        this.checkoutPaymentConnector = checkoutPaymentConnector;\n        this.checkoutConnector = checkoutConnector;\n        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n        this.addDeliveryAddress$ = this.actions$.pipe(ofType(ADD_DELIVERY_ADDRESS), map((action) => action.payload), mergeMap(payload => this.checkoutDeliveryConnector\n            .createAddress(payload.userId, payload.cartId, payload.address)\n            .pipe(mergeMap(address => {\n            address['titleCode'] = payload.address.titleCode;\n            if (payload.address.region && payload.address.region.isocodeShort) {\n                Object.assign(address.region, {\n                    isocodeShort: payload.address.region.isocodeShort,\n                });\n            }\n            if (payload.userId === OCC_USER_ID_ANONYMOUS) {\n                return [\n                    new SetDeliveryAddress({\n                        userId: payload.userId,\n                        cartId: payload.cartId,\n                        address: address,\n                    }),\n                ];\n            }\n            else {\n                return [\n                    new LoadUserAddresses(payload.userId),\n                    new SetDeliveryAddress({\n                        userId: payload.userId,\n                        cartId: payload.cartId,\n                        address: address,\n                    }),\n                ];\n            }\n        }), catchError(error => of(new AddDeliveryAddressFail(makeErrorSerializable(error)))))), withdrawOn(this.contextChange$));\n        this.setDeliveryAddress$ = this.actions$.pipe(ofType(SET_DELIVERY_ADDRESS), map((action) => action.payload), mergeMap(payload => {\n            return this.checkoutDeliveryConnector\n                .setAddress(payload.userId, payload.cartId, payload.address.id)\n                .pipe(mergeMap(() => [\n                new SetDeliveryAddressSuccess(payload.address),\n                new ClearCheckoutDeliveryMode({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                }),\n                new ClearSupportedDeliveryModes(),\n                new ResetLoadSupportedDeliveryModesProcess(),\n                new LoadSupportedDeliveryModes({\n                    userId: payload.userId,\n                    cartId: payload.cartId,\n                }),\n            ]), catchError(error => of(new SetDeliveryAddressFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.loadSupportedDeliveryModes$ = this.actions$.pipe(ofType(LOAD_SUPPORTED_DELIVERY_MODES), map((action) => action.payload), mergeMap(payload => {\n            return this.checkoutDeliveryConnector\n                .getSupportedModes(payload.userId, payload.cartId)\n                .pipe(map(data => {\n                return new LoadSupportedDeliveryModesSuccess(data);\n            }), catchError(error => of(new LoadSupportedDeliveryModesFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.clearCheckoutMiscsDataOnLanguageChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), mergeMap(() => [\n            new CheckoutClearMiscsData(),\n            new ResetLoadSupportedDeliveryModesProcess(),\n        ]));\n        this.clearDeliveryModesOnCurrencyChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE), map(() => new ClearSupportedDeliveryModes()));\n        this.clearCheckoutDataOnLogout$ = this.actions$.pipe(ofType(LOGOUT), map(() => new ClearCheckoutData()));\n        this.clearCheckoutDataOnLogin$ = this.actions$.pipe(ofType(LOGIN), map(() => new ClearCheckoutData()));\n        this.setDeliveryMode$ = this.actions$.pipe(ofType(SET_DELIVERY_MODE), map((action) => action.payload), mergeMap(payload => {\n            return this.checkoutDeliveryConnector\n                .setMode(payload.userId, payload.cartId, payload.selectedModeId)\n                .pipe(mergeMap(() => {\n                return [\n                    new SetDeliveryModeSuccess(payload.selectedModeId),\n                    new LoadCart({\n                        userId: payload.userId,\n                        cartId: payload.cartId,\n                    }),\n                ];\n            }), catchError(error => of(new SetDeliveryModeFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.createPaymentDetails$ = this.actions$.pipe(ofType(CREATE_PAYMENT_DETAILS), map((action) => action.payload), mergeMap(payload => {\n            // get information for creating a subscription directly with payment provider\n            return this.checkoutPaymentConnector\n                .create(payload.userId, payload.cartId, payload.paymentDetails)\n                .pipe(mergeMap(details => {\n                if (payload.userId === OCC_USER_ID_ANONYMOUS) {\n                    return [new CreatePaymentDetailsSuccess(details)];\n                }\n                else {\n                    return [\n                        new LoadUserPaymentMethods(payload.userId),\n                        new CreatePaymentDetailsSuccess(details),\n                    ];\n                }\n            }), catchError(error => of(new CreatePaymentDetailsFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.setPaymentDetails$ = this.actions$.pipe(ofType(SET_PAYMENT_DETAILS), map((action) => action.payload), mergeMap(payload => {\n            return this.checkoutPaymentConnector\n                .set(payload.userId, payload.cartId, payload.paymentDetails.id)\n                .pipe(map(() => new SetPaymentDetailsSuccess(payload.paymentDetails)), catchError(error => of(new SetPaymentDetailsFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.placeOrder$ = this.actions$.pipe(ofType(PLACE_ORDER), map((action) => action.payload), mergeMap(payload => {\n            return this.checkoutConnector\n                .placeOrder(payload.userId, payload.cartId)\n                .pipe(switchMap(data => [\n                new RemoveCart(payload.cartId),\n                new PlaceOrderSuccess(data),\n            ]), catchError(error => of(new PlaceOrderFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.loadCheckoutDetails$ = this.actions$.pipe(ofType(LOAD_CHECKOUT_DETAILS), map((action) => action.payload), mergeMap(payload => {\n            return this.checkoutConnector\n                .loadCheckoutDetails(payload.userId, payload.cartId)\n                .pipe(map((data) => new LoadCheckoutDetailsSuccess(data)), catchError(error => of(new LoadCheckoutDetailsFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.reloadDetailsOnMergeCart$ = this.actions$.pipe(ofType(MERGE_CART_SUCCESS), map((action) => action.payload), map(payload => {\n            return new LoadCheckoutDetails({\n                userId: payload.userId,\n                cartId: payload.cartId ? payload.cartId : OCC_CART_ID_CURRENT,\n            });\n        }));\n        this.clearCheckoutDeliveryAddress$ = this.actions$.pipe(ofType(CLEAR_CHECKOUT_DELIVERY_ADDRESS), map((action) => action.payload), filter(payload => Boolean(payload.cartId)), switchMap(payload => {\n            return this.checkoutConnector\n                .clearCheckoutDeliveryAddress(payload.userId, payload.cartId)\n                .pipe(map(() => new ClearCheckoutDeliveryAddressSuccess()), catchError(error => of(new ClearCheckoutDeliveryAddressFail(makeErrorSerializable(error)))));\n        }), withdrawOn(this.contextChange$));\n        this.clearCheckoutDeliveryMode$ = this.actions$.pipe(ofType(CLEAR_CHECKOUT_DELIVERY_MODE), map((action) => action.payload), filter(payload => Boolean(payload.cartId)), concatMap(payload => {\n            return this.checkoutConnector\n                .clearCheckoutDeliveryMode(payload.userId, payload.cartId)\n                .pipe(map(() => new ClearCheckoutDeliveryModeSuccess({\n                userId: payload.userId,\n                cartId: payload.cartId,\n            })), catchError(error => from([\n                new ClearCheckoutDeliveryModeFail(makeErrorSerializable(error)),\n                new CartProcessesDecrement(payload.cartId),\n                new LoadCart({\n                    cartId: payload.cartId,\n                    userId: payload.userId,\n                }),\n            ])));\n        }), withdrawOn(this.contextChange$));\n    }\n};\nCheckoutEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CheckoutDeliveryConnector },\n    { type: CheckoutPaymentConnector },\n    { type: CheckoutConnector }\n];\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"addDeliveryAddress$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"setDeliveryAddress$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"loadSupportedDeliveryModes$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"clearCheckoutMiscsDataOnLanguageChange$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"clearDeliveryModesOnCurrencyChange$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"clearCheckoutDataOnLogout$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"clearCheckoutDataOnLogin$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"setDeliveryMode$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"createPaymentDetails$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"setPaymentDetails$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"placeOrder$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"loadCheckoutDetails$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"reloadDetailsOnMergeCart$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"clearCheckoutDeliveryAddress$\", void 0);\n__decorate([\n    Effect()\n], CheckoutEffects.prototype, \"clearCheckoutDeliveryMode$\", void 0);\nCheckoutEffects = __decorate([\n    Injectable()\n], CheckoutEffects);\n\nconst effects$6 = [\n    CheckoutEffects,\n    AddressVerificationEffect,\n    CardTypesEffects,\n];\n\nlet CheckoutStoreModule = class CheckoutStoreModule {\n};\nCheckoutStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StoreModule.forFeature(CHECKOUT_FEATURE, reducerToken$6),\n            EffectsModule.forFeature(effects$6),\n        ],\n        providers: [reducerProvider$6],\n    })\n], CheckoutStoreModule);\n\nvar CheckoutModule_1;\nlet CheckoutModule = CheckoutModule_1 = class CheckoutModule {\n    static forRoot() {\n        return {\n            ngModule: CheckoutModule_1,\n            providers: [\n                CheckoutService,\n                {\n                    provide: PageMetaResolver,\n                    useExisting: CheckoutPageMetaResolver,\n                    multi: true,\n                },\n            ],\n        };\n    }\n};\nCheckoutModule = CheckoutModule_1 = __decorate([\n    NgModule({\n        imports: [CheckoutStoreModule],\n    })\n], CheckoutModule);\n\nlet CheckoutDeliveryService = class CheckoutDeliveryService {\n    constructor(checkoutStore, cartData) {\n        this.checkoutStore = checkoutStore;\n        this.cartData = cartData;\n    }\n    /**\n     * Get supported delivery modes\n     */\n    getSupportedDeliveryModes() {\n        return this.checkoutStore.pipe(select(getSupportedDeliveryModes), withLatestFrom(this.checkoutStore.pipe(select(getProcessStateFactory(SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID)))), tap(([, loadingState]) => {\n            if (!(loadingState.loading || loadingState.success || loadingState.error)) {\n                this.loadSupportedDeliveryModes();\n            }\n        }), pluck(0), shareReplay({ bufferSize: 1, refCount: true }));\n    }\n    /**\n     * Get selected delivery mode\n     */\n    getSelectedDeliveryMode() {\n        return this.checkoutStore.pipe(select(getSelectedDeliveryMode));\n    }\n    /**\n     * Get selected delivery mode code\n     */\n    getSelectedDeliveryModeCode() {\n        return this.checkoutStore.pipe(select(getSelectedDeliveryModeCode));\n    }\n    /**\n     * Get delivery address\n     */\n    getDeliveryAddress() {\n        return this.checkoutStore.pipe(select(getDeliveryAddress));\n    }\n    /**\n     * Get status about successfully set Delivery Address\n     */\n    getSetDeliveryAddressProcess() {\n        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_DELIVERY_ADDRESS_PROCESS_ID)));\n    }\n    /**\n     * Clear info about process of setting Delivery Address\n     */\n    resetSetDeliveryAddressProcess() {\n        this.checkoutStore.dispatch(new ResetSetDeliveryAddressProcess());\n    }\n    /**\n     * Get status about of set Delivery Mode process\n     */\n    getSetDeliveryModeProcess() {\n        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_DELIVERY_MODE_PROCESS_ID)));\n    }\n    /**\n     * Clear info about process of setting Delivery Mode\n     */\n    resetSetDeliveryModeProcess() {\n        this.checkoutStore.dispatch(new ResetSetDeliveryModeProcess());\n    }\n    /**\n     * Clear info about process of setting Supported Delivery Modes\n     */\n    resetLoadSupportedDeliveryModesProcess() {\n        this.checkoutStore.dispatch(new ResetLoadSupportedDeliveryModesProcess());\n    }\n    /**\n     * Get status about of set supported Delivery Modes process\n     */\n    getLoadSupportedDeliveryModeProcess() {\n        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID)));\n    }\n    /**\n     * Clear supported delivery modes loaded in last checkout process\n     */\n    clearCheckoutDeliveryModes() {\n        this.checkoutStore.dispatch(new ClearSupportedDeliveryModes());\n    }\n    /**\n     * Get address verification results\n     */\n    getAddressVerificationResults() {\n        return this.checkoutStore.pipe(select(getAddressVerificationResults$1), filter(results => Object.keys(results).length !== 0));\n    }\n    /**\n     * Create and set a delivery address using the address param\n     * @param address : the Address to be created and set\n     */\n    createAndSetAddress(address) {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new AddDeliveryAddress({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n                address: address,\n            }));\n        }\n    }\n    /**\n     * Load supported delivery modes\n     */\n    loadSupportedDeliveryModes() {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new LoadSupportedDeliveryModes({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n            }));\n        }\n    }\n    /**\n     * Set delivery mode\n     * @param mode : The delivery mode to be set\n     */\n    setDeliveryMode(mode) {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new SetDeliveryMode({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n                selectedModeId: mode,\n            }));\n        }\n    }\n    /**\n     * Verifies the address\n     * @param address : the address to be verified\n     */\n    verifyAddress(address) {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new VerifyAddress({\n                userId: this.cartData.userId,\n                address,\n            }));\n        }\n    }\n    /**\n     * Set delivery address\n     * @param address : The address to be set\n     */\n    setDeliveryAddress(address) {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new SetDeliveryAddress({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cart.code,\n                address: address,\n            }));\n        }\n    }\n    /**\n     * Clear address verification results\n     */\n    clearAddressVerificationResults() {\n        this.checkoutStore.dispatch(new ClearAddressVerificationResults());\n    }\n    /**\n     * Clear address already setup in last checkout process\n     */\n    clearCheckoutDeliveryAddress() {\n        this.checkoutStore.dispatch(new ClearCheckoutDeliveryAddress({\n            userId: this.cartData.userId,\n            cartId: this.cartData.cartId,\n        }));\n    }\n    /**\n     * Clear selected delivery mode setup in last checkout process\n     */\n    clearCheckoutDeliveryMode() {\n        this.checkoutStore.dispatch(new ClearCheckoutDeliveryMode({\n            userId: this.cartData.userId,\n            cartId: this.cartData.cartId,\n        }));\n    }\n    /**\n     * Clear address and delivery mode already setup in last checkout process\n     */\n    clearCheckoutDeliveryDetails() {\n        this.clearCheckoutDeliveryAddress();\n        this.clearCheckoutDeliveryMode();\n        this.clearCheckoutDeliveryModes();\n    }\n    actionAllowed() {\n        return (this.cartData.userId !== OCC_USER_ID_ANONYMOUS ||\n            this.cartData.isGuestCart);\n    }\n};\nCheckoutDeliveryService.ctorParameters = () => [\n    { type: Store },\n    { type: CartDataService }\n];\nCheckoutDeliveryService.ɵprov = ɵɵdefineInjectable({ factory: function CheckoutDeliveryService_Factory() { return new CheckoutDeliveryService(ɵɵinject(Store), ɵɵinject(CartDataService)); }, token: CheckoutDeliveryService, providedIn: \"root\" });\nCheckoutDeliveryService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CheckoutDeliveryService);\n\nlet CheckoutPaymentService = class CheckoutPaymentService {\n    constructor(checkoutStore, cartData) {\n        this.checkoutStore = checkoutStore;\n        this.cartData = cartData;\n    }\n    /**\n     * Get card types\n     */\n    getCardTypes() {\n        return this.checkoutStore.pipe(select(getAllCardTypes));\n    }\n    /**\n     * Get payment details\n     */\n    getPaymentDetails() {\n        return this.checkoutStore.pipe(select(getPaymentDetails));\n    }\n    /**\n     * Get status about set Payment Details process\n     */\n    getSetPaymentDetailsResultProcess() {\n        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_PAYMENT_DETAILS_PROCESS_ID)));\n    }\n    /**\n     * Clear info about process of setting Payment Details\n     */\n    resetSetPaymentDetailsProcess() {\n        this.checkoutStore.dispatch(new ResetSetPaymentDetailsProcess());\n    }\n    /**\n     * Load the supported card types\n     */\n    loadSupportedCardTypes() {\n        this.checkoutStore.dispatch(new LoadCardTypes());\n    }\n    /**\n     * Create payment details using the given paymentDetails param\n     * @param paymentDetails: the PaymentDetails to be created\n     */\n    createPaymentDetails(paymentDetails) {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new CreatePaymentDetails({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cartId,\n                paymentDetails,\n            }));\n        }\n    }\n    /**\n     * Set payment details\n     * @param paymentDetails : the PaymentDetails to be set\n     */\n    setPaymentDetails(paymentDetails) {\n        if (this.actionAllowed()) {\n            this.checkoutStore.dispatch(new SetPaymentDetails({\n                userId: this.cartData.userId,\n                cartId: this.cartData.cart.code,\n                paymentDetails: paymentDetails,\n            }));\n        }\n    }\n    /**\n     * Sets payment loading to true without having the flicker issue (GH-3102)\n     */\n    paymentProcessSuccess() {\n        this.checkoutStore.dispatch(new PaymentProcessSuccess());\n    }\n    actionAllowed() {\n        return (this.cartData.userId !== OCC_USER_ID_ANONYMOUS ||\n            this.cartData.isGuestCart);\n    }\n};\nCheckoutPaymentService.ctorParameters = () => [\n    { type: Store },\n    { type: CartDataService }\n];\nCheckoutPaymentService.ɵprov = ɵɵdefineInjectable({ factory: function CheckoutPaymentService_Factory() { return new CheckoutPaymentService(ɵɵinject(Store), ɵɵinject(CartDataService)); }, token: CheckoutPaymentService, providedIn: \"root\" });\nCheckoutPaymentService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CheckoutPaymentService);\n\n/**\n * The `CmsStructureConfig` is used to build pages in Spartacus by configuration\n * instead of using a backend CMS system. The configuration can be used to build\n * complete pages or parts of a page. The `CmsStructureConfig` is optimized to\n * only require the necessary properties. Adapter logic is applied to serialize\n * the `CmsStructureConfig` into the required UI model.\n */\nclass CmsStructureConfig extends CmsConfig {\n}\n\nconst defaultCmsModuleConfig = {\n    backend: {\n        occ: {\n            endpoints: {\n                component: 'cms/components/${id}',\n                components: 'cms/components',\n                pages: 'cms/pages',\n                page: 'cms/pages/${id}',\n            },\n            legacy: false,\n        },\n    },\n    cmsComponents: {},\n};\n\n/**\n * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`.\n * More specific resolvers for content pages can be implemented by making them more\n * specific, for example by using the page template (see `CartPageMetaResolver`).\n *\n * The page title, and breadcrumbs are resolved in this implementation only.\n */\nlet ContentPageMetaResolver = class ContentPageMetaResolver extends PageMetaResolver {\n    constructor(cms, translation) {\n        super();\n        this.cms = cms;\n        this.translation = translation;\n        this.cms$ = this.cms\n            .getCurrentPage()\n            .pipe(filter(p => !!p));\n        this.pageType = PageType.CONTENT_PAGE;\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return this.cms$.pipe(switchMap((page) => combineLatest([\n            this.resolveTitle(page),\n            this.resolveBreadcrumbLabel().pipe(switchMap(label => this.resolveBreadcrumbs(page, label))),\n        ])), map(([title, breadcrumbs]) => ({ title, breadcrumbs })));\n    }\n    resolveTitle(page) {\n        return page ? of(page.title) : this.cms$.pipe(map(p => p.title));\n    }\n    /**\n     * @deprecated since version 1.3\n     * This method will removed with with 2.0\n     */\n    resolveBreadcrumbLabel() {\n        return this.translation.translate('common.home');\n    }\n    resolveBreadcrumbs(_page, breadcrumbLabel) {\n        if (breadcrumbLabel) {\n            return of([{ label: breadcrumbLabel, link: '/' }]);\n        }\n        else {\n            return this.translation\n                .translate('common.home')\n                .pipe(map(label => [{ label: label, link: '/' }]));\n        }\n    }\n};\nContentPageMetaResolver.ctorParameters = () => [\n    { type: CmsService },\n    { type: TranslationService }\n];\nContentPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function ContentPageMetaResolver_Factory() { return new ContentPageMetaResolver(ɵɵinject(CmsService), ɵɵinject(TranslationService)); }, token: ContentPageMetaResolver, providedIn: \"root\" });\nContentPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ContentPageMetaResolver);\n\nlet CmsPageTitleModule = class CmsPageTitleModule {\n};\nCmsPageTitleModule = __decorate([\n    NgModule({\n        providers: [\n            {\n                provide: PageMetaResolver,\n                useExisting: ContentPageMetaResolver,\n                multi: true,\n            },\n        ],\n    })\n], CmsPageTitleModule);\n\nfunction bufferDebounceTime(time = 0, scheduler) {\n    return (source) => {\n        let bufferedValues = [];\n        return source.pipe(tap(value => bufferedValues.push(value)), debounceTime(time, scheduler), map(() => bufferedValues), tap(() => (bufferedValues = [])));\n    };\n}\n\n/**\n * Service that provides access to CMS structure from a static\n * configuration or configuration file. This class uses static\n * configuration is designed in async fashion so that configurations\n * can be loaded from a file or stream.\n *\n * The intent of the `CmsStructureConfigService` however is to provide\n * fast loading pages and default cms structure for commodity commerce.\n */\nlet CmsStructureConfigService = class CmsStructureConfigService {\n    constructor(cmsDataConfig) {\n        this.cmsDataConfig = cmsDataConfig;\n    }\n    /**\n     * Merge the cms structure to the pageStructure. The page structure\n     * can either hold complete page structures or global structures that\n     * might apply to all pages (such has header coponents).\n     */\n    mergePageStructure(pageId, pageStructure) {\n        return this.mergePage(pageId, pageStructure).pipe(switchMap(page => this.mergeSlots(page)));\n    }\n    /**\n     *\n     * Returns boolean observable to indicate whether the page should not be\n     * loaded from the backend. This is useful for pages which are comoditized\n     * and follow best practice.\n     *\n     * By default, configurable pages are driven by static configuration,\n     * in order to allow for fast loading pages (preventing network delays).\n     */\n    shouldIgnoreBackend(pageId) {\n        return this.getPageFromConfig(pageId).pipe(map(page => !!page && !!page.ignoreBackend));\n    }\n    /**\n     * returns an Observable component data from the static configuration.\n     */\n    getComponentFromConfig(componentId) {\n        return of(this.getComponentById(componentId));\n    }\n    /**\n     * returns an Observable components data from the static configuration.\n     */\n    getComponentsFromConfig(ids) {\n        return of(ids.map(id => this.getComponentById(id)));\n    }\n    /**\n     * returns an observable with the `PageConfig`.\n     */\n    getPageFromConfig(pageId) {\n        return of(this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.pages\n            ? this.cmsDataConfig.cmsStructure.pages.find(p => p.pageId === pageId)\n            : null);\n    }\n    /**\n     * Merge page data from the configuration into the given structure, if any.\n     * If the given page structure is empty, a page is created and the page slots are\n     * are merged into the page.\n     */\n    mergePage(pageId, pageStructure) {\n        return this.getPageFromConfig(pageId).pipe(switchMap(page => {\n            if (page) {\n                // serialize page data\n                if (!pageStructure.page) {\n                    pageStructure.page = Object.assign({}, page);\n                    pageStructure.page.slots = {};\n                }\n                if (!pageStructure.page.slots) {\n                    pageStructure.page.slots = {};\n                }\n                return this.mergeSlots(pageStructure, page.slots);\n            }\n            else {\n                return of(pageStructure);\n            }\n        }));\n    }\n    /**\n     * Adds any pre-configured slots for pages that do not use them.\n     * If pages have a slot for the given position, the configiuration\n     * is ingored. Even if the slot does not have inner structure (such as\n     * components), so that the cms structure is able to override the (static)\n     * configuration.\n     */\n    mergeSlots(pageStructure, slots) {\n        // if no slots have been given, we use the global configured slots\n        if (!slots &&\n            this.cmsDataConfig.cmsStructure &&\n            this.cmsDataConfig.cmsStructure.slots) {\n            slots = this.cmsDataConfig.cmsStructure.slots;\n        }\n        if (!slots) {\n            return of(pageStructure);\n        }\n        for (const position of Object.keys(slots)) {\n            if (!Object.keys(pageStructure.page.slots).includes(position)) {\n                // the global slot isn't yet part of the page structure\n                pageStructure.page.slots[position] = {};\n                for (const component of this.getComponentsByPosition(slots, position)) {\n                    if (!pageStructure.page.slots[position].components) {\n                        pageStructure.page.slots[position].components = [];\n                    }\n                    pageStructure.page.slots[position].components.push({\n                        uid: component.uid,\n                        flexType: component.flexType,\n                        typeCode: component.typeCode,\n                    });\n                    if (!pageStructure.components) {\n                        pageStructure.components = [];\n                    }\n                    pageStructure.components.push(component);\n                }\n            }\n        }\n        return of(pageStructure);\n    }\n    getComponentsByPosition(slots, position) {\n        const components = [];\n        if (slots[position] && slots[position].componentIds) {\n            for (const componentId of slots[position].componentIds) {\n                if (this.cmsDataConfig.cmsStructure &&\n                    this.cmsDataConfig.cmsStructure.components) {\n                    const component = this.cmsDataConfig.cmsStructure.components[componentId];\n                    if (component) {\n                        components.push(Object.assign({ uid: componentId }, component));\n                    }\n                }\n            }\n        }\n        return components;\n    }\n    getComponentById(componentId) {\n        return this.cmsDataConfig.cmsStructure &&\n            this.cmsDataConfig.cmsStructure.components\n            ? this.cmsDataConfig.cmsStructure.components[componentId]\n            : undefined;\n    }\n};\nCmsStructureConfigService.ctorParameters = () => [\n    { type: CmsStructureConfig }\n];\nCmsStructureConfigService.ɵprov = ɵɵdefineInjectable({ factory: function CmsStructureConfigService_Factory() { return new CmsStructureConfigService(ɵɵinject(CmsStructureConfig)); }, token: CmsStructureConfigService, providedIn: \"root\" });\nCmsStructureConfigService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CmsStructureConfigService);\n\nlet CmsComponentConnector = class CmsComponentConnector {\n    constructor(cmsStructureConfigService, adapter, config) {\n        this.cmsStructureConfigService = cmsStructureConfigService;\n        this.adapter = adapter;\n        this.config = config;\n    }\n    get(id, pageContext) {\n        return this.cmsStructureConfigService\n            .getComponentFromConfig(id)\n            .pipe(switchMap(configuredComponent => configuredComponent\n            ? of(configuredComponent)\n            : this.adapter.load(id, pageContext)));\n    }\n    getList(ids, pageContext) {\n        return this.cmsStructureConfigService.getComponentsFromConfig(ids).pipe(switchMap(configuredComponents => {\n            // check if we have some components that are not loaded from configuration\n            const missingIds = configuredComponents.reduce((acc, component, index) => {\n                if (component === undefined) {\n                    acc.push(ids[index]);\n                }\n                return acc;\n            }, []);\n            if (missingIds.length > 0) {\n                return (this.config.backend.occ.legacy\n                    ? this.adapter.findComponentsByIdsLegacy(missingIds, pageContext)\n                    : this.adapter.findComponentsByIds(missingIds, pageContext)).pipe(map(loadedComponents => [\n                    ...configuredComponents.filter(Boolean),\n                    ...loadedComponents,\n                ]));\n            }\n            else {\n                return of(configuredComponents);\n            }\n        }));\n    }\n};\nCmsComponentConnector.ctorParameters = () => [\n    { type: CmsStructureConfigService },\n    { type: CmsComponentAdapter },\n    { type: OccConfig }\n];\nCmsComponentConnector.ɵprov = ɵɵdefineInjectable({ factory: function CmsComponentConnector_Factory() { return new CmsComponentConnector(ɵɵinject(CmsStructureConfigService), ɵɵinject(CmsComponentAdapter), ɵɵinject(OccConfig)); }, token: CmsComponentConnector, providedIn: \"root\" });\nCmsComponentConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CmsComponentConnector);\n\nlet ComponentsEffects = class ComponentsEffects {\n    constructor(actions$, cmsComponentLoader, featureConfigService) {\n        this.actions$ = actions$;\n        this.cmsComponentLoader = cmsComponentLoader;\n        this.featureConfigService = featureConfigService;\n        this.contextChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN));\n        this.loadComponent$ = createEffect(() => ({ scheduler, debounce = 0 } = {}) => this.actions$.pipe(ofType(LOAD_CMS_COMPONENT), groupBy(actions => serializePageContext(actions.payload.pageContext)), mergeMap(actionGroup => actionGroup.pipe(bufferDebounceTime(debounce, scheduler), mergeMap(actions => this.loadComponentsEffect(actions.map(action => action.payload.uid), actions[0].payload.pageContext)))), withdrawOn(this.contextChange$)));\n    }\n    loadComponentsEffect(componentUids, pageContext) {\n        // TODO: remove, deprecated behavior since 1.4\n        if (!this.featureConfigService.isLevel('1.4')) {\n            return merge(...componentUids.map(uid => this.cmsComponentLoader.get(uid, pageContext).pipe(map(component => new LoadCmsComponentSuccess({\n                component,\n                uid: component.uid,\n                pageContext,\n            })), catchError(error => of(new LoadCmsComponentFail({\n                uid,\n                error: makeErrorSerializable(error),\n                pageContext,\n            }))))));\n        }\n        // END OF (TODO: remove, deprecated behavior since 1.4)\n        return this.cmsComponentLoader.getList(componentUids, pageContext).pipe(switchMap(components => from(components.map(component => new LoadCmsComponentSuccess({\n            component,\n            uid: component.uid,\n            pageContext,\n        })))), catchError(error => from(componentUids.map(uid => new LoadCmsComponentFail({\n            uid,\n            error: makeErrorSerializable(error),\n            pageContext,\n        })))));\n    }\n};\nComponentsEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CmsComponentConnector },\n    { type: FeatureConfigService }\n];\nComponentsEffects = __decorate([\n    Injectable()\n], ComponentsEffects);\n\nlet UrlMatcherFactoryService = class UrlMatcherFactoryService {\n    constructor(globService) {\n        this.globService = globService;\n    }\n    /**\n     * Returns a matcher that is always fails\n     */\n    getFalsyUrlMatcher() {\n        return function falsyUrlMatcher() {\n            return null;\n        };\n    }\n    /**\n     * Returns a matcher for given list of paths\n     */\n    getMultiplePathsUrlMatcher(paths) {\n        const self = this;\n        const matcher = function multiplePathsUrlMatcher(segments, segmentGroup, route) {\n            for (let i = 0; i < paths.length; i++) {\n                const result = self.getPathUrlMatcher(paths[i])(segments, segmentGroup, route);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        matcher.paths = paths; // property added for easier debugging of routes\n        return matcher;\n    }\n    /**\n     * Similar to Angular's defaultUrlMatcher. Differences:\n     * - the `path` comes from function's argument, not from `route.path`\n     * - the empty path `''` is handled here, but in Angular is handled one level higher in the match() function\n     */\n    getPathUrlMatcher(path = '') {\n        return (segments, segmentGroup, route) => {\n            /**\n             * @license\n             * The MIT License\n             * Copyright (c) 2010-2019 Google LLC. http://angular.io/license\n             *\n             * See:\n             * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/router/src/shared.ts#L121\n             */\n            // use function's argument, not the `route.path`\n            if (path === '') {\n                if (route.pathMatch === 'full' &&\n                    (segmentGroup.hasChildren() || segments.length > 0)) {\n                    return null;\n                }\n                return { consumed: [], posParams: {} };\n            }\n            const parts = path.split('/'); // use function's argument, not the `route.path`\n            if (parts.length > segments.length) {\n                // The actual URL is shorter than the config, no match\n                return null;\n            }\n            if (route.pathMatch === 'full' &&\n                (segmentGroup.hasChildren() || parts.length < segments.length)) {\n                // The config is longer than the actual URL but we are looking for a full match, return null\n                return null;\n            }\n            const posParams = {};\n            // Check each config part against the actual URL\n            for (let index = 0; index < parts.length; index++) {\n                const part = parts[index];\n                const segment = segments[index];\n                const isParameter = part.startsWith(':');\n                if (isParameter) {\n                    posParams[part.substring(1)] = segment;\n                }\n                else if (part !== segment.path) {\n                    // The actual URL part does not match the config, no match\n                    return null;\n                }\n            }\n            return { consumed: segments.slice(0, parts.length), posParams };\n        };\n    }\n    /**\n     * Returns URL matcher that accepts almost everything (like `**` route), but not paths accepted by the given matcher\n     */\n    getOppositeUrlMatcher(originalMatcher) {\n        const matcher = function oppositeUrlMatcher(segments, group, route) {\n            return originalMatcher(segments, group, route)\n                ? null\n                : { consumed: segments, posParams: {} };\n        };\n        matcher.originalMatcher = originalMatcher; // property added for easier debugging of routes\n        return matcher;\n    }\n    /**\n     * Returns URL matcher for the given list of glob-like patterns. Each pattern must start with `/` or `!/`.\n     */\n    getGlobUrlMatcher(globPatterns) {\n        const globValidator = this.globService.getValidator(globPatterns);\n        const matcher = function globUrlMatcher(segments) {\n            const fullPath = `/${segments.map(s => s.path).join('/')}`;\n            return globValidator(fullPath)\n                ? { consumed: segments, posParams: {} }\n                : null;\n        };\n        matcher.globPatterns = globPatterns; // property added for easier debugging of routes\n        return matcher;\n    }\n};\nUrlMatcherFactoryService.ctorParameters = () => [\n    { type: GlobService }\n];\nUrlMatcherFactoryService.ɵprov = ɵɵdefineInjectable({ factory: function UrlMatcherFactoryService_Factory() { return new UrlMatcherFactoryService(ɵɵinject(GlobService)); }, token: UrlMatcherFactoryService, providedIn: \"root\" });\nUrlMatcherFactoryService = __decorate([\n    Injectable({ providedIn: 'root' })\n], UrlMatcherFactoryService);\n\nlet ConfigurableRoutesService = class ConfigurableRoutesService {\n    constructor(injector, routingConfigService, urlMatcherFactory) {\n        this.injector = injector;\n        this.routingConfigService = routingConfigService;\n        this.urlMatcherFactory = urlMatcherFactory;\n        this.initCalled = false; // guard not to call init() more than once\n    }\n    /**\n     * Configures all existing Routes in the Router\n     */\n    init() {\n        if (!this.initCalled) {\n            this.initCalled = true;\n            this.configureRouter();\n        }\n    }\n    configureRouter() {\n        // Router could not be injected in constructor due to cyclic dependency with APP_INITIALIZER:\n        const router = this.injector.get(Router);\n        const configuredRoutes = this.configureRoutes(router.config);\n        router.resetConfig(configuredRoutes);\n    }\n    configureRoutes(routes) {\n        const result = [];\n        routes.forEach(route => {\n            const configuredRoute = this.configureRoute(route);\n            if (route.children && route.children.length) {\n                configuredRoute.children = this.configureRoutes(route.children);\n            }\n            result.push(configuredRoute);\n        });\n        return result;\n    }\n    configureRoute(route) {\n        const routeName = this.getRouteName(route);\n        if (routeName) {\n            const routeConfig = this.routingConfigService.getRouteConfig(routeName);\n            const paths = this.getConfiguredPaths(routeConfig, routeName, route);\n            const isDisabled = routeConfig && routeConfig.disabled;\n            if (isDisabled || !paths.length) {\n                delete route.path;\n                return Object.assign(Object.assign({}, route), { matcher: this.urlMatcherFactory.getFalsyUrlMatcher() });\n            }\n            else if (paths.length === 1) {\n                delete route.matcher;\n                return Object.assign(Object.assign({}, route), { path: paths[0] });\n            }\n            else {\n                delete route.path;\n                return Object.assign(Object.assign({}, route), { matcher: this.urlMatcherFactory.getMultiplePathsUrlMatcher(paths) });\n            }\n        }\n        return route; // if route doesn't have a name, just pass the original route\n    }\n    getRouteName(route) {\n        return route.data && route.data.cxRoute;\n    }\n    getConfiguredPaths(routeConfig, routeName, route) {\n        if (routeConfig === undefined) {\n            this.warn(`Could not configure the named route '${routeName}'`, route, `due to undefined key '${routeName}' in the routes config`);\n            return [];\n        }\n        if (routeConfig && routeConfig.paths === undefined) {\n            this.warn(`Could not configure the named route '${routeName}'`, route, `due to undefined 'paths' for the named route '${routeName}' in the routes config`);\n            return [];\n        }\n        // routeConfig or routeConfig.paths can be null - which means switching off the route\n        return (routeConfig && routeConfig.paths) || [];\n    }\n    warn(...args) {\n        if (isDevMode()) {\n            console.warn(...args);\n        }\n    }\n};\nConfigurableRoutesService.ctorParameters = () => [\n    { type: Injector },\n    { type: RoutingConfigService },\n    { type: UrlMatcherFactoryService }\n];\nConfigurableRoutesService.ɵprov = ɵɵdefineInjectable({ factory: function ConfigurableRoutesService_Factory() { return new ConfigurableRoutesService(ɵɵinject(INJECTOR), ɵɵinject(RoutingConfigService), ɵɵinject(UrlMatcherFactoryService)); }, token: ConfigurableRoutesService, providedIn: \"root\" });\nConfigurableRoutesService = __decorate([\n    Injectable({ providedIn: 'root' })\n], ConfigurableRoutesService);\n\nlet UrlPipe = class UrlPipe {\n    constructor(urlService) {\n        this.urlService = urlService;\n    }\n    transform(commands) {\n        return this.urlService.transform(commands);\n    }\n};\nUrlPipe.ctorParameters = () => [\n    { type: SemanticPathService }\n];\nUrlPipe = __decorate([\n    Pipe({\n        name: 'cxUrl',\n    })\n], UrlPipe);\n\nlet ProductURLPipe = class ProductURLPipe {\n    constructor(semanticPath) {\n        this.semanticPath = semanticPath;\n    }\n    transform(product) {\n        return this.semanticPath.transform({ cxRoute: 'product', params: product });\n    }\n};\nProductURLPipe.ctorParameters = () => [\n    { type: SemanticPathService }\n];\nProductURLPipe = __decorate([\n    Pipe({\n        name: 'cxProductUrl',\n    })\n], ProductURLPipe);\n\nlet UrlModule = class UrlModule {\n};\nUrlModule = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [UrlPipe, ProductURLPipe],\n        exports: [UrlPipe, ProductURLPipe],\n    })\n], UrlModule);\n\nclass ExternalRoutesConfig {\n}\n\nlet ExternalRoutesGuard = class ExternalRoutesGuard {\n    constructor(winRef, platformId) {\n        this.winRef = winRef;\n        this.platformId = platformId;\n    }\n    /**\n     * Redirects to different storefront system for anticipated URL\n     */\n    canActivate(route, state) {\n        if (isPlatformBrowser(this.platformId)) {\n            this.redirect(route, state);\n        }\n        return false;\n    }\n    /**\n     * Redirects to anticipated URL using full page reload, not Angular routing\n     */\n    redirect(_, state) {\n        const window = this.winRef.nativeWindow;\n        if (window && window.location) {\n            window.location.href = state.url;\n        }\n    }\n};\nExternalRoutesGuard.ctorParameters = () => [\n    { type: WindowRef },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\nExternalRoutesGuard.ɵprov = ɵɵdefineInjectable({ factory: function ExternalRoutesGuard_Factory() { return new ExternalRoutesGuard(ɵɵinject(WindowRef), ɵɵinject(PLATFORM_ID)); }, token: ExternalRoutesGuard, providedIn: \"root\" });\nExternalRoutesGuard = __decorate([\n    Injectable({ providedIn: 'root' }),\n    __param(1, Inject(PLATFORM_ID))\n], ExternalRoutesGuard);\n\nfunction addExternalRoutesFactory(service) {\n    const result = () => {\n        service.addRoutes();\n    };\n    return result;\n}\n\n/**\n * Service that helps redirecting to different storefront systems for configured URLs\n */\nlet ExternalRoutesService = class ExternalRoutesService {\n    constructor(config, matcherFactory, injector) {\n        this.config = config;\n        this.matcherFactory = matcherFactory;\n        this.injector = injector;\n    }\n    get internalUrlPatterns() {\n        return ((this.config && this.config.routing && this.config.routing.internal) || []);\n    }\n    /**\n     * Prepends routes (to the Router.config) that are responsible for redirecting to a different storefront system\n     */\n    addRoutes() {\n        const router = this.injector.get(Router);\n        const newRoutes = this.getRoutes();\n        if (newRoutes.length) {\n            router.resetConfig([...newRoutes, ...router.config]);\n        }\n    }\n    /**\n     * Returns routes that are responsible for redirection to different storefront systems\n     */\n    getRoutes() {\n        if (!this.internalUrlPatterns.length) {\n            return [];\n        }\n        const routes = [];\n        routes.push({\n            pathMatch: 'full',\n            matcher: this.getUrlMatcher(),\n            canActivate: [ExternalRoutesGuard],\n            component: {},\n        });\n        return routes;\n    }\n    /**\n     * Returns the URL matcher for the external route\n     */\n    getUrlMatcher() {\n        const matcher = this.matcherFactory.getGlobUrlMatcher(this.internalUrlPatterns);\n        return this.matcherFactory.getOppositeUrlMatcher(matcher); // the external route should be activated only when it's NOT an internal route\n    }\n};\nExternalRoutesService.ctorParameters = () => [\n    { type: ExternalRoutesConfig },\n    { type: UrlMatcherFactoryService },\n    { type: Injector }\n];\nExternalRoutesService = __decorate([\n    Injectable()\n], ExternalRoutesService);\n\nvar ExternalRoutesModule_1;\n/**\n * Prepends the external route that redirects to a different storefront system for configured URLs\n */\nlet ExternalRoutesModule = ExternalRoutesModule_1 = class ExternalRoutesModule {\n    static forRoot() {\n        return {\n            ngModule: ExternalRoutesModule_1,\n            providers: [\n                ExternalRoutesService,\n                { provide: ExternalRoutesConfig, useExisting: Config },\n                {\n                    provide: APP_INITIALIZER,\n                    multi: true,\n                    useFactory: addExternalRoutesFactory,\n                    deps: [ExternalRoutesService],\n                },\n            ],\n        };\n    }\n};\nExternalRoutesModule = ExternalRoutesModule_1 = __decorate([\n    NgModule()\n], ExternalRoutesModule);\n\nclass PageContext {\n    constructor(id, type) {\n        this.id = id;\n        this.type = type;\n    }\n}\n\nlet ProtectedRoutesService = class ProtectedRoutesService {\n    constructor(config) {\n        this.config = config;\n        this.nonProtectedPaths = []; // arrays of paths' segments list\n        if (this.shouldProtect) {\n            // pre-process config for performance:\n            this.nonProtectedPaths = this.getNonProtectedPaths().map(path => this.getSegments(path));\n        }\n    }\n    get routingConfig() {\n        return this.config && this.config.routing;\n    }\n    /**\n     * Returns 'protected' property (boolean) from routing config\n     *\n     * @returns boolean\n     */\n    get shouldProtect() {\n        return this.routingConfig.protected;\n    }\n    /**\n     * Tells if the url is protected\n     */\n    isUrlProtected(urlSegments) {\n        return (this.shouldProtect &&\n            !this.matchAnyPath(urlSegments, this.nonProtectedPaths));\n    }\n    /**\n     * Tells whether the url matches at least one of the paths\n     */\n    matchAnyPath(urlSegments, pathsSegments) {\n        return pathsSegments.some(pathSegments => this.matchPath(urlSegments, pathSegments));\n    }\n    /**\n     * Tells whether the url matches the path\n     */\n    matchPath(urlSegments, pathSegments) {\n        if (urlSegments.length !== pathSegments.length) {\n            return false;\n        }\n        for (let i = 0; i < pathSegments.length; i++) {\n            const pathSeg = pathSegments[i];\n            const urlSeg = urlSegments[i];\n            // compare only static segments:\n            if (!pathSeg.startsWith(':') && pathSeg !== urlSeg) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a list of paths that are not protected\n     */\n    getNonProtectedPaths() {\n        return Object.values(this.routingConfig.routes).reduce((acc, routeConfig) => routeConfig.protected === false && // must be explicitly false, ignore undefined\n            routeConfig.paths &&\n            routeConfig.paths.length\n            ? acc.concat(routeConfig.paths)\n            : acc, []);\n    }\n    /**\n     * Splits the url by slashes\n     */\n    getSegments(url) {\n        return (url || '').split('/');\n    }\n};\nProtectedRoutesService.ctorParameters = () => [\n    { type: RoutingConfig }\n];\nProtectedRoutesService.ɵprov = ɵɵdefineInjectable({ factory: function ProtectedRoutesService_Factory() { return new ProtectedRoutesService(ɵɵinject(RoutingConfig)); }, token: ProtectedRoutesService, providedIn: \"root\" });\nProtectedRoutesService = __decorate([\n    Injectable({ providedIn: 'root' })\n], ProtectedRoutesService);\n\nlet ProtectedRoutesGuard = class ProtectedRoutesGuard {\n    constructor(service, authGuard) {\n        this.service = service;\n        this.authGuard = authGuard;\n    }\n    /**\n     * When the anticipated url is protected, it switches to the AuthGuard. Otherwise emits true.\n     */\n    canActivate(route) {\n        let urlSegments = route.url.map(seg => seg.path);\n        // For the root path `/` ActivatedRoute contains an empty array of segments:\n        urlSegments = urlSegments.length ? urlSegments : [''];\n        if (this.service.isUrlProtected(urlSegments)) {\n            return this.authGuard.canActivate();\n        }\n        return of(true);\n    }\n};\nProtectedRoutesGuard.ctorParameters = () => [\n    { type: ProtectedRoutesService },\n    { type: AuthGuard }\n];\nProtectedRoutesGuard.ɵprov = ɵɵdefineInjectable({ factory: function ProtectedRoutesGuard_Factory() { return new ProtectedRoutesGuard(ɵɵinject(ProtectedRoutesService), ɵɵinject(AuthGuard)); }, token: ProtectedRoutesGuard, providedIn: \"root\" });\nProtectedRoutesGuard = __decorate([\n    Injectable({ providedIn: 'root' })\n], ProtectedRoutesGuard);\n\nlet RouterEffects = class RouterEffects {\n    constructor(actions$, router, location) {\n        this.actions$ = actions$;\n        this.router = router;\n        this.location = location;\n        this.navigate$ = this.actions$.pipe(ofType(ROUTER_GO), map((action) => action.payload), tap(({ path, query: queryParams, extras }) => {\n            this.router.navigate(path, Object.assign({ queryParams }, extras));\n        }));\n        this.navigateBuUrl$ = this.actions$.pipe(ofType(ROUTER_GO_BY_URL), map((action) => action.payload), tap(url => {\n            this.router.navigateByUrl(url);\n        }));\n        this.clearCmsRoutes$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), tap(_ => {\n            const filteredConfig = this.router.config.filter((route) => !(route.data && route.data.cxCmsRouteContext));\n            if (filteredConfig.length !== this.router.config.length) {\n                this.router.resetConfig(filteredConfig);\n            }\n        }));\n        this.navigateBack$ = this.actions$.pipe(ofType(ROUTER_BACK), tap(() => this.location.back()));\n        this.navigateForward$ = this.actions$.pipe(ofType(ROUTER_FORWARD), tap(() => this.location.forward()));\n    }\n};\nRouterEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: Router },\n    { type: Location }\n];\n__decorate([\n    Effect({ dispatch: false })\n], RouterEffects.prototype, \"navigate$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], RouterEffects.prototype, \"navigateBuUrl$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], RouterEffects.prototype, \"clearCmsRoutes$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], RouterEffects.prototype, \"navigateBack$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], RouterEffects.prototype, \"navigateForward$\", void 0);\nRouterEffects = __decorate([\n    Injectable()\n], RouterEffects);\n\nconst effects$7 = [RouterEffects];\n\nconst initialState$d = {\n    navigationId: 0,\n    state: {\n        url: '',\n        queryParams: {},\n        params: {},\n        context: {\n            id: '',\n        },\n        cmsRequired: false,\n    },\n    nextState: undefined,\n};\nfunction getReducers$7() {\n    return {\n        router: reducer$d,\n    };\n}\nfunction reducer$d(state = initialState$d, action) {\n    switch (action.type) {\n        case ROUTER_NAVIGATION: {\n            return Object.assign(Object.assign({}, state), { nextState: action.payload.routerState, navigationId: action.payload.event.id });\n        }\n        case ROUTER_ERROR:\n        case ROUTER_CANCEL: {\n            return Object.assign(Object.assign({}, state), { nextState: undefined });\n        }\n        case ROUTER_NAVIGATED: {\n            return {\n                state: action.payload.routerState,\n                navigationId: action.payload.event.id,\n                nextState: undefined,\n            };\n        }\n        default: {\n            return state;\n        }\n    }\n}\nconst reducerToken$7 = new InjectionToken('RouterReducers');\nconst reducerProvider$7 = {\n    provide: reducerToken$7,\n    useFactory: getReducers$7,\n};\n/* The serializer is there to parse the RouterStateSnapshot,\nand to reduce the amount of properties to be passed to the reducer.\n */\nclass CustomSerializer {\n    serialize(routerState) {\n        const { url } = routerState;\n        const { queryParams } = routerState.root;\n        let state = routerState.root;\n        let cmsRequired = false;\n        let context;\n        while (state.firstChild) {\n            state = state.firstChild;\n            // we use context information embedded in Cms driven routes from any parent route\n            if (state.data && state.data.cxCmsRouteContext) {\n                context = state.data.cxCmsRouteContext;\n            }\n            // we assume, that any route that has CmsPageGuard or it's child\n            // is cmsRequired\n            if (!cmsRequired &&\n                (context ||\n                    (state.routeConfig &&\n                        state.routeConfig.canActivate &&\n                        state.routeConfig.canActivate.find(x => x && x.guardName === 'CmsPageGuard')))) {\n                cmsRequired = true;\n            }\n        }\n        const { params } = state;\n        // we give smartedit preview page a PageContext\n        if (state.url.length > 0 && state.url[0].path === 'cx-preview') {\n            context = {\n                id: 'smartedit-preview',\n                type: PageType.CONTENT_PAGE,\n            };\n        }\n        else {\n            if (params['productCode']) {\n                context = { id: params['productCode'], type: PageType.PRODUCT_PAGE };\n            }\n            else if (params['categoryCode']) {\n                context = { id: params['categoryCode'], type: PageType.CATEGORY_PAGE };\n            }\n            else if (params['brandCode']) {\n                context = { id: params['brandCode'], type: PageType.CATEGORY_PAGE };\n            }\n            else if (state.data.pageLabel !== undefined) {\n                context = { id: state.data.pageLabel, type: PageType.CONTENT_PAGE };\n            }\n            else if (!context) {\n                if (state.url.length > 0) {\n                    const pageLabel = '/' + state.url.map(urlSegment => urlSegment.path).join('/');\n                    context = {\n                        id: pageLabel,\n                        type: PageType.CONTENT_PAGE,\n                    };\n                }\n                else {\n                    context = {\n                        id: 'homepage',\n                        type: PageType.CONTENT_PAGE,\n                    };\n                }\n            }\n        }\n        return { url, queryParams, params, context, cmsRequired };\n    }\n}\n\nvar RoutingModule_1;\nfunction initConfigurableRoutes(service) {\n    const result = () => service.init(); // workaround for AOT compilation (see https://stackoverflow.com/a/51977115)\n    return result;\n}\nlet RoutingModule = RoutingModule_1 = class RoutingModule {\n    static forRoot() {\n        return {\n            ngModule: RoutingModule_1,\n            providers: [\n                reducerProvider$7,\n                {\n                    provide: RouterStateSerializer,\n                    useClass: CustomSerializer,\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    useFactory: initConfigurableRoutes,\n                    deps: [ConfigurableRoutesService],\n                    multi: true,\n                },\n                { provide: RoutingConfig, useExisting: Config },\n            ],\n        };\n    }\n};\nRoutingModule = RoutingModule_1 = __decorate([\n    NgModule({\n        imports: [\n            StoreModule.forFeature(ROUTING_FEATURE, reducerToken$7),\n            EffectsModule.forFeature(effects$7),\n            StoreRouterConnectingModule.forRoot({\n                routerState: 1 /* Minimal */,\n                stateKey: ROUTING_FEATURE,\n            }),\n        ],\n    })\n], RoutingModule);\n\nlet NavigationEntryItemEffects = class NavigationEntryItemEffects {\n    constructor(actions$, cmsComponentConnector, routingService) {\n        this.actions$ = actions$;\n        this.cmsComponentConnector = cmsComponentConnector;\n        this.routingService = routingService;\n        this.loadNavigationItems$ = this.actions$.pipe(ofType(LOAD_CMS_NAVIGATION_ITEMS), map((action) => action.payload), map(payload => {\n            return {\n                ids: this.getIdListByItemType(payload.items),\n                nodeId: payload.nodeId,\n            };\n        }), mergeMap(data => {\n            if (data.ids.componentIds.length > 0) {\n                return this.routingService.getRouterState().pipe(filter(routerState => routerState !== undefined), map(routerState => routerState.state.context), take(1), mergeMap(pageContext => \n                // download all items in one request\n                this.cmsComponentConnector\n                    .getList(data.ids.componentIds, pageContext)\n                    .pipe(map(components => new LoadCmsNavigationItemsSuccess({\n                    nodeId: data.nodeId,\n                    components: components,\n                })), catchError(error => of(new LoadCmsNavigationItemsFail(data.nodeId, makeErrorSerializable(error)))))));\n            }\n            else if (data.ids.pageIds.length > 0) {\n                // TODO: future work\n                // dispatch action to load cms page one by one\n            }\n            else if (data.ids.mediaIds.length > 0) {\n                // TODO: future work\n                // send request to get list of media\n            }\n            else {\n                return of(new LoadCmsNavigationItemsFail(data.nodeId, 'navigation nodes are empty'));\n            }\n        }));\n    }\n    // We only consider 3 item types: cms page, cms component, and media.\n    getIdListByItemType(itemList) {\n        const pageIds = [];\n        const componentIds = [];\n        const mediaIds = [];\n        itemList.forEach(item => {\n            if (item.superType === 'AbstractCMSComponent') {\n                componentIds.push(item.id);\n            }\n            else if (item.superType === 'AbstractPage') {\n                pageIds.push(item.id);\n            }\n            else if (item.superType === 'AbstractMedia') {\n                mediaIds.push(item.id);\n            }\n        });\n        return { pageIds: pageIds, componentIds: componentIds, mediaIds: mediaIds };\n    }\n};\nNavigationEntryItemEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CmsComponentConnector },\n    { type: RoutingService }\n];\n__decorate([\n    Effect()\n], NavigationEntryItemEffects.prototype, \"loadNavigationItems$\", void 0);\nNavigationEntryItemEffects = __decorate([\n    Injectable()\n], NavigationEntryItemEffects);\n\nlet CmsPageConnector = class CmsPageConnector {\n    constructor(cmsPageAdapter, cmsStructureConfigService) {\n        this.cmsPageAdapter = cmsPageAdapter;\n        this.cmsStructureConfigService = cmsStructureConfigService;\n    }\n    /**\n     * Returns an observable with the page structure. The page structure is\n     * typically loaded from a backend, but can also be returned from static\n     * configuration (see `CmsStructureConfigService`).\n     */\n    get(pageContext) {\n        return this.cmsStructureConfigService\n            .shouldIgnoreBackend(pageContext.id)\n            .pipe(switchMap(loadFromConfig => {\n            if (!loadFromConfig) {\n                return this.cmsPageAdapter.load(pageContext).pipe(catchError(error => {\n                    if (error instanceof HttpErrorResponse &&\n                        error.status === 400) {\n                        return of({});\n                    }\n                    else {\n                        return throwError(error);\n                    }\n                }));\n            }\n            else {\n                return of({});\n            }\n        }), switchMap(page => this.mergeDefaultPageStructure(pageContext, page)));\n    }\n    /**\n     *\n     * Merge default page structure inot the given `CmsStructureModel`.\n     * This is benefitial for a fast setup of the UI without necessary\n     * finegrained CMS setup.\n     */\n    mergeDefaultPageStructure(pageContext, pageStructure) {\n        return this.cmsStructureConfigService.mergePageStructure(pageContext.id, pageStructure);\n    }\n};\nCmsPageConnector.ctorParameters = () => [\n    { type: CmsPageAdapter },\n    { type: CmsStructureConfigService }\n];\nCmsPageConnector.ɵprov = ɵɵdefineInjectable({ factory: function CmsPageConnector_Factory() { return new CmsPageConnector(ɵɵinject(CmsPageAdapter), ɵɵinject(CmsStructureConfigService)); }, token: CmsPageConnector, providedIn: \"root\" });\nCmsPageConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CmsPageConnector);\n\nlet PageEffects = class PageEffects {\n    constructor(actions$, cmsPageConnector, routingService) {\n        this.actions$ = actions$;\n        this.cmsPageConnector = cmsPageConnector;\n        this.routingService = routingService;\n        this.refreshPage$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), switchMap(_ => this.routingService.getRouterState().pipe(filter(routerState => routerState &&\n            routerState.state &&\n            routerState.state.cmsRequired &&\n            !routerState.nextState), take(1), map(routerState => routerState.state.context), mergeMap(context => of(new LoadCmsPageData(context))))));\n        this.loadPageData$ = this.actions$.pipe(ofType(LOAD_CMS_PAGE_DATA), map((action) => action.payload), groupBy(pageContext => serializePageContext(pageContext)), mergeMap(group => group.pipe(switchMap(pageContext => this.cmsPageConnector.get(pageContext).pipe(mergeMap((cmsStructure) => {\n            const actions = [\n                new CmsGetComponentFromPage(cmsStructure.components.map(component => ({\n                    component,\n                    pageContext,\n                }))),\n                new LoadCmsPageDataSuccess(pageContext, cmsStructure.page),\n            ];\n            const pageLabel = cmsStructure.page.label;\n            // For content pages the page label returned from backend can be different than page ID initially assumed from route.\n            // In such a case let's save the success response not only for initially assumed page ID, but also for correct page label.\n            if (pageLabel && pageLabel !== pageContext.id) {\n                actions.unshift(new CmsSetPageSuccessIndex({ id: pageLabel, type: pageContext.type }, cmsStructure.page));\n            }\n            return actions;\n        }), catchError(error => of(new LoadCmsPageDataFail(pageContext, makeErrorSerializable(error)))))))));\n    }\n};\nPageEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CmsPageConnector },\n    { type: RoutingService }\n];\n__decorate([\n    Effect()\n], PageEffects.prototype, \"refreshPage$\", void 0);\n__decorate([\n    Effect()\n], PageEffects.prototype, \"loadPageData$\", void 0);\nPageEffects = __decorate([\n    Injectable()\n], PageEffects);\n\nconst effects$8 = [\n    PageEffects,\n    ComponentsEffects,\n    NavigationEntryItemEffects,\n];\n\nconst initialState$e = {\n    component: undefined,\n    pageContext: {},\n};\nfunction componentExistsReducer(state = false, action) {\n    switch (action.type) {\n        case LOAD_CMS_COMPONENT_FAIL:\n            return false;\n        case CMS_GET_COMPONENT_FROM_PAGE:\n        case LOAD_CMS_COMPONENT_SUCCESS:\n            return true;\n    }\n    return state;\n}\nfunction reducer$e(state = initialState$e, action) {\n    switch (action.type) {\n        case LOAD_CMS_COMPONENT: {\n            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n            const context = serializePageContext(action.payload.pageContext, true);\n            return Object.assign(Object.assign({}, state), { pageContext: Object.assign(Object.assign({}, state.pageContext), { [context]: pageContextReducer(state.pageContext[context], action) }) });\n        }\n        case LOAD_CMS_COMPONENT_FAIL: {\n            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n            const context = serializePageContext(action.payload.pageContext, true);\n            return Object.assign(Object.assign({}, state), { pageContext: Object.assign(Object.assign({}, state.pageContext), { [context]: pageContextReducer(state.pageContext[context], action) }) });\n        }\n        case LOAD_CMS_COMPONENT_SUCCESS: {\n            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n            const context = serializePageContext(action.payload.pageContext, true);\n            return Object.assign(Object.assign({}, state), { component: action.payload.component, pageContext: Object.assign(Object.assign({}, state.pageContext), { [context]: pageContextReducer(state.pageContext[context], action) }) });\n        }\n        case CMS_GET_COMPONENT_FROM_PAGE: {\n            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n            if (!Array.isArray(action.payload)) {\n                const context = serializePageContext(action.payload.pageContext, true);\n                return Object.assign(Object.assign({}, state), { component: action.payload.component, pageContext: Object.assign(Object.assign({}, state.pageContext), { [context]: pageContextReducer(state.pageContext[context], action) }) });\n            }\n        }\n    }\n    return state;\n}\n\nconst initialState$f = undefined;\nfunction reducer$f(state = initialState$f, action) {\n    switch (action.type) {\n        case LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: {\n            if (action.payload.components) {\n                const components = action.payload.components;\n                const newItem = components.reduce((compItems, component) => {\n                    return Object.assign(Object.assign({}, compItems), { [`${component.uid}_AbstractCMSComponent`]: component });\n                }, Object.assign({}));\n                return Object.assign(Object.assign({}, state), newItem);\n            }\n        }\n    }\n    return state;\n}\n\nconst initialState$g = { entities: {} };\nfunction reducer$g(state = initialState$g, action) {\n    switch (action.type) {\n        case LOAD_CMS_PAGE_DATA_SUCCESS: {\n            const page = action.payload;\n            return Object.assign(Object.assign({}, state), { entities: Object.assign(Object.assign({}, state.entities), { [page.pageId]: page }) });\n        }\n    }\n    return state;\n}\n\nconst initialState$h = undefined;\nfunction reducer$h(entityType) {\n    return (state = initialState$h, action) => {\n        if (action.meta && action.meta.entityType === entityType) {\n            switch (action.type) {\n                case LOAD_CMS_PAGE_DATA_SUCCESS: {\n                    return action.payload.pageId;\n                }\n                case LOAD_CMS_PAGE_DATA_FAIL: {\n                    return initialState$h;\n                }\n                case CMS_SET_PAGE_FAIL_INDEX: {\n                    return action.payload;\n                }\n                case CMS_SET_PAGE_SUCCESS_INDEX: {\n                    return action.payload.pageId;\n                }\n            }\n        }\n        return state;\n    };\n}\n\nfunction getReducers$8() {\n    return {\n        page: combineReducers({\n            pageData: reducer$g,\n            index: combineReducers({\n                content: entityLoaderReducer(PageType.CONTENT_PAGE, reducer$h(PageType.CONTENT_PAGE)),\n                product: entityLoaderReducer(PageType.PRODUCT_PAGE, reducer$h(PageType.PRODUCT_PAGE)),\n                category: entityLoaderReducer(PageType.CATEGORY_PAGE, reducer$h(PageType.CATEGORY_PAGE)),\n                catalog: entityLoaderReducer(PageType.CATALOG_PAGE, reducer$h(PageType.CATALOG_PAGE)),\n            }),\n        }),\n        components: entityReducer(COMPONENT_ENTITY, reducer$e),\n        navigation: entityLoaderReducer(NAVIGATION_DETAIL_ENTITY, reducer$f),\n    };\n}\nconst reducerToken$8 = new InjectionToken('CmsReducers');\nconst reducerProvider$8 = {\n    provide: reducerToken$8,\n    useFactory: getReducers$8,\n};\nfunction clearCmsState(reducer) {\n    return function (state, action) {\n        if (action.type === LANGUAGE_CHANGE ||\n            action.type === LOGOUT ||\n            action.type === LOGIN) {\n            state = undefined;\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers$4 = [clearCmsState];\n\nfunction cmsStoreConfigFactory() {\n    // if we want to reuse CMS_FEATURE const in config, we have to use factory instead of plain object\n    const config = {\n        state: {\n            ssrTransfer: {\n                keys: { [CMS_FEATURE]: StateTransferType.TRANSFER_STATE },\n            },\n        },\n    };\n    return config;\n}\nlet CmsStoreModule = class CmsStoreModule {\n};\nCmsStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StateModule,\n            StoreModule.forFeature(CMS_FEATURE, reducerToken$8, { metaReducers: metaReducers$4 }),\n            EffectsModule.forFeature(effects$8),\n            ConfigModule.withConfigFactory(cmsStoreConfigFactory),\n        ],\n        providers: [reducerProvider$8],\n    })\n], CmsStoreModule);\n\nvar CmsModule_1;\nlet CmsModule = CmsModule_1 = class CmsModule {\n    static forRoot() {\n        return {\n            ngModule: CmsModule_1,\n            providers: [\n                CmsService,\n                { provide: CmsConfig, useExisting: Config },\n                { provide: CmsStructureConfig, useExisting: Config },\n                provideConfig(defaultCmsModuleConfig),\n            ],\n        };\n    }\n};\nCmsModule = CmsModule_1 = __decorate([\n    NgModule({\n        imports: [CmsStoreModule, CmsPageTitleModule],\n    })\n], CmsModule);\n\nlet PageMetaService = class PageMetaService {\n    constructor(resolvers, cms, featureConfigService) {\n        this.resolvers = resolvers;\n        this.cms = cms;\n        this.featureConfigService = featureConfigService;\n        /**\n         * The list of resolver interfaces will be evaluated for the pageResolvers.\n         *\n         * TOOD: optimize browser vs SSR resolvers; image, robots and description\n         *       aren't needed during browsing.\n         * TODO: we can make the list of resolver types configurable\n         */\n        this.resolverMethods = {\n            title: 'resolveTitle',\n            heading: 'resolveHeading',\n            description: 'resolveDescription',\n            breadcrumbs: 'resolveBreadcrumbs',\n            image: 'resolveImage',\n            robots: 'resolveRobots',\n        };\n        this.resolvers = this.resolvers || [];\n    }\n    getMeta() {\n        return this.cms.getCurrentPage().pipe(filter(Boolean), switchMap((page) => {\n            const metaResolver = this.getMetaResolver(page);\n            if (metaResolver) {\n                return this.resolve(metaResolver);\n            }\n            else {\n                // we do not have a page resolver\n                return of(null);\n            }\n        }));\n    }\n    /**\n     * If a pageResolver has implemented a resolver interface, the resolved data\n     * is merged into the `PageMeta` object.\n     * @param metaResolver\n     */\n    resolve(metaResolver) {\n        if (metaResolver.resolve &&\n            (!this.featureConfigService || !this.featureConfigService.isLevel('1.3'))) {\n            return metaResolver.resolve();\n        }\n        else {\n            // resolve individual resolvers to make the extension mechanism more flexible\n            const resolveMethods = Object.keys(this.resolverMethods)\n                .filter(key => metaResolver[this.resolverMethods[key]])\n                .map(key => metaResolver[this.resolverMethods[key]]().pipe(map(data => ({\n                [key]: data,\n            }))));\n            return combineLatest(resolveMethods).pipe(map(data => Object.assign({}, ...data)));\n        }\n    }\n    /**\n     * return the resolver with the best match\n     * resovers can by default match on PageType and page template\n     * but custom match comparisors can be implemented.\n     */\n    getMetaResolver(page) {\n        const matchingResolvers = this.resolvers.filter(resolver => resolver.getScore(page) > 0);\n        matchingResolvers.sort(function (a, b) {\n            return b.getScore(page) - a.getScore(page);\n        });\n        return matchingResolvers[0];\n    }\n};\nPageMetaService.ctorParameters = () => [\n    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [PageMetaResolver,] }] },\n    { type: CmsService },\n    { type: FeatureConfigService }\n];\nPageMetaService.ɵprov = ɵɵdefineInjectable({ factory: function PageMetaService_Factory() { return new PageMetaService(ɵɵinject(PageMetaResolver, 8), ɵɵinject(CmsService), ɵɵinject(FeatureConfigService)); }, token: PageMetaService, providedIn: \"root\" });\nPageMetaService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    }),\n    __param(0, Optional()),\n    __param(0, Inject(PageMetaResolver))\n], PageMetaService);\n\nlet DynamicAttributeService = class DynamicAttributeService {\n    /**\n     * Add dynamic attributes to DOM. These attributes are extracted from the properties of cms items received from backend.\n     * There can by many different groups of properties, one of them is smaredit. But EC allows addons to create different groups.\n     * For example, personalization may add 'script' group etc.\n     * @param properties: properties in each cms item response data\n     * @param element: slot or cms component element\n     * @param renderer\n     */\n    addDynamicAttributes(properties, element, renderer) {\n        if (properties) {\n            // check each group of properties, e.g. smartedit\n            Object.keys(properties).forEach(group => {\n                const name = 'data-' + group + '-';\n                const groupProps = properties[group];\n                // check each property in the group\n                Object.keys(groupProps).forEach(propName => {\n                    const propValue = groupProps[propName];\n                    if (propName === 'classes') {\n                        const classes = propValue.split(' ');\n                        classes.forEach(classItem => {\n                            element.classList.add(classItem);\n                        });\n                    }\n                    else {\n                        renderer.setAttribute(element, name +\n                            propName\n                                .split(/(?=[A-Z])/)\n                                .join('-')\n                                .toLowerCase(), propValue);\n                    }\n                });\n            });\n        }\n    }\n};\nDynamicAttributeService.ɵprov = ɵɵdefineInjectable({ factory: function DynamicAttributeService_Factory() { return new DynamicAttributeService(); }, token: DynamicAttributeService, providedIn: \"root\" });\nDynamicAttributeService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], DynamicAttributeService);\n\n// type CxDatePipe, not DatePipe, due to conflict with Angular's DatePipe - problem occurs for the backward compatibility compiler of Ivy\nlet CxDatePipe = class CxDatePipe extends DatePipe {\n    constructor(language) {\n        super(null);\n        this.language = language;\n    }\n    transform(value, format, timezone) {\n        return super.transform(value, format, timezone, this.getLang());\n    }\n    getLang() {\n        const lang = this.getActiveLang();\n        try {\n            getLocaleId(lang);\n            return lang;\n        }\n        catch (_a) {\n            this.reportMissingLocaleData(lang);\n            return 'en';\n        }\n    }\n    getActiveLang() {\n        let result;\n        this.language\n            .getActive()\n            .subscribe(lang => (result = lang))\n            .unsubscribe();\n        return result;\n    }\n    reportMissingLocaleData(lang) {\n        if (isDevMode()) {\n            console.warn(`cxDate pipe: No locale data registered for '${lang}' (see https://angular.io/api/common/registerLocaleData).`);\n        }\n    }\n};\nCxDatePipe.ctorParameters = () => [\n    { type: LanguageService }\n];\nCxDatePipe = __decorate([\n    Pipe({ name: 'cxDate' })\n], CxDatePipe);\n\nlet TranslatePipe = class TranslatePipe {\n    constructor(service, cd) {\n        this.service = service;\n        this.cd = cd;\n    }\n    transform(input, options = {}) {\n        if (input.raw) {\n            return input.raw;\n        }\n        const key = typeof input === 'string' ? input : input.key;\n        if (typeof input !== 'string') {\n            options = Object.assign(Object.assign({}, options), input.params);\n        }\n        this.translate(key, options);\n        return this.translatedValue;\n    }\n    translate(key, options) {\n        if (key !== this.lastKey ||\n            !shallowEqualObjects(options, this.lastOptions)) {\n            this.lastKey = key;\n            this.lastOptions = options;\n            if (this.sub) {\n                this.sub.unsubscribe();\n            }\n            this.sub = this.service\n                .translate(key, options, true)\n                .subscribe(val => this.markForCheck(val));\n        }\n    }\n    markForCheck(value) {\n        this.translatedValue = value;\n        this.cd.markForCheck();\n    }\n    ngOnDestroy() {\n        if (this.sub) {\n            this.sub.unsubscribe();\n        }\n    }\n};\nTranslatePipe.ctorParameters = () => [\n    { type: TranslationService },\n    { type: ChangeDetectorRef }\n];\nTranslatePipe = __decorate([\n    Pipe({ name: 'cxTranslate', pure: false })\n], TranslatePipe);\n\nclass I18nConfig {\n}\n\nlet TranslationChunkService = class TranslationChunkService {\n    constructor(config) {\n        this.config = config;\n        this.duplicates = {};\n        this.chunks = {};\n        this.KEY_SEPARATOR = '.';\n        const chunks = (config.i18n && config.i18n.chunks) || {};\n        Object.keys(chunks).forEach(chunk => {\n            chunks[chunk].forEach(key => {\n                if (this.chunks.hasOwnProperty(key)) {\n                    if (!this.duplicates[key]) {\n                        this.duplicates[key] = [this.chunks[key]];\n                    }\n                    this.duplicates[key].push(chunk);\n                }\n                else {\n                    this.chunks[key] = chunk;\n                }\n            });\n        });\n        if (Object.keys(this.duplicates).length > 0 && isDevMode()) {\n            this.warnDuplicates(this.duplicates);\n        }\n    }\n    getChunkNameForKey(key) {\n        const mainKey = (key || '').split(this.KEY_SEPARATOR)[0];\n        const chunk = this.chunks && this.chunks[mainKey];\n        if (!chunk) {\n            return mainKey; // fallback to main key as a chunk\n        }\n        return chunk;\n    }\n    warnDuplicates(items) {\n        const dupes = [];\n        Object.keys(items).forEach(key => {\n            dupes.push(`* '${key}' found in chunks: ${items[key].join(', ')}. Used '${this.chunks[key]}.${key}'.`);\n        });\n        console.warn(`Duplicated keys has been found in the config of i18n chunks:\\n${dupes.join('\\n')}`);\n    }\n};\nTranslationChunkService.ctorParameters = () => [\n    { type: I18nConfig }\n];\nTranslationChunkService = __decorate([\n    Injectable()\n], TranslationChunkService);\n\nfunction i18nextInit(configInit, languageService, httpClient, serverRequestOrigin) {\n    return () => configInit.getStableConfig('i18n').then(config => {\n        let i18nextConfig = {\n            ns: [],\n            fallbackLng: config.i18n.fallbackLang,\n            debug: config.i18n.debug,\n            interpolation: {\n                escapeValue: false,\n            },\n        };\n        if (config.i18n.backend) {\n            i18next.use(i18nextXhrBackend);\n            const loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);\n            const backend = {\n                loadPath,\n                ajax: i18nextGetHttpClient(httpClient),\n            };\n            i18nextConfig = Object.assign(Object.assign({}, i18nextConfig), { backend });\n        }\n        return i18next.init(i18nextConfig, () => {\n            // Don't use i18next's 'resources' config key for adding static translations,\n            // because it will disable loading chunks from backend. We add resources here, in the init's callback.\n            i18nextAddTranslations(config.i18n.resources);\n            syncI18nextWithSiteContext(languageService);\n        });\n    });\n}\nfunction i18nextAddTranslations(resources = {}) {\n    Object.keys(resources).forEach(lang => {\n        Object.keys(resources[lang]).forEach(chunkName => {\n            i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);\n        });\n    });\n}\nfunction syncI18nextWithSiteContext(language) {\n    // always update language of i18next on site context (language) change\n    language.getActive().subscribe(lang => i18next.changeLanguage(lang));\n}\n/**\n * Returns a function appropriate for i18next to make http calls for JSON files.\n * See docs for `i18next-xhr-backend`: https://github.com/i18next/i18next-xhr-backend#backend-options\n *\n * It uses Angular HttpClient under the hood, so it works in SSR.\n * @param httpClient Angular http client\n */\nfunction i18nextGetHttpClient(httpClient) {\n    return (url, _options, callback, _data) => {\n        httpClient\n            .get(url, { responseType: 'text' })\n            .subscribe(data => callback(data, { status: 200 }), error => callback(null, { status: error.status }));\n    };\n}\n/**\n * Resolves the relative path to the absolute one in SSR, using the server request's origin.\n * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:\n * - https://github.com/angular/angular/issues/19224\n * - https://github.com/angular/universal/issues/858\n */\nfunction getLoadPath(path, serverRequestOrigin) {\n    if (!path) {\n        return undefined;\n    }\n    if (serverRequestOrigin && !path.match(/^http(s)?:\\/\\//)) {\n        if (path.startsWith('/')) {\n            path = path.slice(1);\n        }\n        if (path.startsWith('./')) {\n            path = path.slice(2);\n        }\n        const result = `${serverRequestOrigin}/${path}`;\n        return result;\n    }\n    return path;\n}\n\nconst ɵ0$D = i18nextInit;\nconst i18nextProviders = [\n    {\n        provide: APP_INITIALIZER,\n        useFactory: ɵ0$D,\n        deps: [\n            ConfigInitializerService,\n            LanguageService,\n            HttpClient,\n            [new Optional(), SERVER_REQUEST_ORIGIN],\n        ],\n        multi: true,\n    },\n];\n\nconst defaultI18nConfig = {\n    i18n: {\n        fallbackLang: false,\n        debug: false,\n    },\n};\n\nlet I18nextTranslationService = class I18nextTranslationService {\n    constructor(config, translationChunk) {\n        this.config = config;\n        this.translationChunk = translationChunk;\n        this.NON_BREAKING_SPACE = String.fromCharCode(160);\n        this.NAMESPACE_SEPARATOR = ':';\n    }\n    translate(key, options = {}, whitespaceUntilLoaded = false) {\n        // If we've already loaded the chunk (or failed to load), we should immediately emit the value\n        // (or the fallback value in case the key is missing).\n        // Moreover, we SHOULD emit a value (or a fallback value) synchronously (not in a promise/setTimeout).\n        // Otherwise, we the will trigger additional deferred change detection in a view that consumes the returned observable,\n        // which together with `switchMap` operator may lead to an infinite loop.\n        const chunkName = this.translationChunk.getChunkNameForKey(key);\n        const namespacedKey = this.getNamespacedKey(key, chunkName);\n        return new Observable(subscriber => {\n            const translate = () => {\n                if (i18next.exists(namespacedKey, options)) {\n                    subscriber.next(i18next.t(namespacedKey, options));\n                }\n                else {\n                    if (whitespaceUntilLoaded) {\n                        subscriber.next(this.NON_BREAKING_SPACE);\n                    }\n                    i18next.loadNamespaces(chunkName, () => {\n                        if (!i18next.exists(namespacedKey, options)) {\n                            this.reportMissingKey(key, chunkName);\n                            subscriber.next(this.getFallbackValue(namespacedKey));\n                        }\n                        else {\n                            subscriber.next(i18next.t(namespacedKey, options));\n                        }\n                    });\n                }\n            };\n            translate();\n            i18next.on('languageChanged', translate);\n            return () => i18next.off('languageChanged', translate);\n        });\n    }\n    loadChunks(chunkNames) {\n        return i18next.loadNamespaces(chunkNames);\n    }\n    /**\n     * Returns a fallback value in case when the given key is missing\n     * @param key\n     */\n    getFallbackValue(key) {\n        return isDevMode() ? `[${key}]` : this.NON_BREAKING_SPACE;\n    }\n    reportMissingKey(key, chunkName) {\n        if (isDevMode()) {\n            console.warn(`Translation key missing '${key}' in the chunk '${chunkName}'`);\n        }\n    }\n    getNamespacedKey(key, chunk) {\n        return chunk + this.NAMESPACE_SEPARATOR + key;\n    }\n};\nI18nextTranslationService.ctorParameters = () => [\n    { type: I18nConfig },\n    { type: TranslationChunkService }\n];\nI18nextTranslationService = __decorate([\n    Injectable()\n], I18nextTranslationService);\n\nvar I18nModule_1;\nlet I18nModule = I18nModule_1 = class I18nModule {\n    static forRoot() {\n        return {\n            ngModule: I18nModule_1,\n            providers: [\n                provideConfig(defaultI18nConfig),\n                { provide: I18nConfig, useExisting: Config },\n                { provide: TranslationService, useClass: I18nextTranslationService },\n                TranslationChunkService,\n                ...i18nextProviders,\n            ],\n        };\n    }\n};\nI18nModule = I18nModule_1 = __decorate([\n    NgModule({\n        declarations: [TranslatePipe, CxDatePipe],\n        exports: [TranslatePipe, CxDatePipe],\n    })\n], I18nModule);\n\nfunction mockTranslate(key, options = {}) {\n    const optionsString = Object.keys(options)\n        .sort()\n        .map(optionName => `${optionName}:${options[optionName]}`)\n        .join(' ');\n    return optionsString ? `${key} ${optionsString}` : key;\n}\n\nlet MockTranslatePipe = class MockTranslatePipe {\n    transform(input, options = {}) {\n        if (input.raw) {\n            return input.raw;\n        }\n        const key = typeof input === 'string' ? input : input.key;\n        if (typeof input !== 'string') {\n            options = Object.assign(Object.assign({}, options), input.params);\n        }\n        return mockTranslate(key, options);\n    }\n};\nMockTranslatePipe = __decorate([\n    Pipe({ name: 'cxTranslate' })\n], MockTranslatePipe);\n\nlet MockTranslationService = class MockTranslationService {\n    translate(key, options = {}, _whitespaceUntilLoaded = false) {\n        return new Observable(subscriber => {\n            const value = mockTranslate(key, options);\n            subscriber.next(value);\n            subscriber.complete();\n        });\n    }\n    loadChunks(_chunks) {\n        return Promise.resolve();\n    }\n};\nMockTranslationService = __decorate([\n    Injectable()\n], MockTranslationService);\n\nlet MockDatePipe = class MockDatePipe extends DatePipe {\n    transform(value, format, timezone) {\n        return super.transform(value, format, timezone, 'en');\n    }\n};\nMockDatePipe = __decorate([\n    Pipe({ name: 'cxDate' })\n], MockDatePipe);\n\nlet I18nTestingModule = class I18nTestingModule {\n};\nI18nTestingModule = __decorate([\n    NgModule({\n        declarations: [MockTranslatePipe, MockDatePipe],\n        exports: [MockTranslatePipe, MockDatePipe],\n        providers: [\n            { provide: TranslationService, useClass: MockTranslationService },\n        ],\n    })\n], I18nTestingModule);\n\nclass KymaConfig extends OccConfig {\n}\n\nconst KYMA_FEATURE = 'kyma';\nconst OPEN_ID_TOKEN_DATA = '[Kyma Auth] Open ID Token Data';\n\nconst LOAD_OPEN_ID_TOKEN = '[Kyma] Load Open ID Token';\nconst LOAD_OPEN_ID_TOKEN_FAIL = '[Kyma] Load Open ID Token Fail';\nconst LOAD_OPEN_ID_TOKEN_SUCCESS = '[Kyma] Load Open ID Token Success';\nclass LoadOpenIdToken extends LoaderLoadAction {\n    constructor(payload) {\n        super(OPEN_ID_TOKEN_DATA);\n        this.payload = payload;\n        this.type = LOAD_OPEN_ID_TOKEN;\n    }\n}\nclass LoadOpenIdTokenFail extends LoaderFailAction {\n    constructor(payload) {\n        super(OPEN_ID_TOKEN_DATA, payload);\n        this.payload = payload;\n        this.type = LOAD_OPEN_ID_TOKEN_FAIL;\n    }\n}\nclass LoadOpenIdTokenSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(OPEN_ID_TOKEN_DATA);\n        this.payload = payload;\n        this.type = LOAD_OPEN_ID_TOKEN_SUCCESS;\n    }\n}\n\n\n\nvar kymaGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_OPEN_ID_TOKEN: LOAD_OPEN_ID_TOKEN,\n    LOAD_OPEN_ID_TOKEN_FAIL: LOAD_OPEN_ID_TOKEN_FAIL,\n    LOAD_OPEN_ID_TOKEN_SUCCESS: LOAD_OPEN_ID_TOKEN_SUCCESS,\n    LoadOpenIdToken: LoadOpenIdToken,\n    LoadOpenIdTokenFail: LoadOpenIdTokenFail,\n    LoadOpenIdTokenSuccess: LoadOpenIdTokenSuccess\n});\n\nconst getKymaState = createFeatureSelector(KYMA_FEATURE);\n\nconst ɵ0$E = state => state.openIdToken;\nconst getOpenIdTokenState = createSelector(getKymaState, ɵ0$E);\nconst getOpenIdTokenValue = createSelector(getOpenIdTokenState, loaderValueSelector);\nconst getOpenIdTokenLoading = createSelector(getOpenIdTokenState, loaderLoadingSelector);\nconst getOpenIdTokenSuccess = createSelector(getOpenIdTokenState, loaderSuccessSelector);\nconst getOpenIdTokenError = createSelector(getOpenIdTokenState, loaderErrorSelector);\n\n\n\nvar kymaGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getKymaState: getKymaState,\n    getOpenIdTokenState: getOpenIdTokenState,\n    getOpenIdTokenValue: getOpenIdTokenValue,\n    getOpenIdTokenLoading: getOpenIdTokenLoading,\n    getOpenIdTokenSuccess: getOpenIdTokenSuccess,\n    getOpenIdTokenError: getOpenIdTokenError,\n    ɵ0: ɵ0$E\n});\n\nlet KymaService = class KymaService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Authorizes using the Kyma OAuth client with scope `openid`.\n     *\n     * @param username a username\n     * @param password a password\n     */\n    authorizeOpenId(username, password) {\n        this.store.dispatch(new LoadOpenIdToken({ username, password }));\n    }\n    /**\n     * Returns the `OpenIdToken`, which was previously retrieved using `authorizeOpenId` method.\n     */\n    getOpenIdToken() {\n        return this.store.pipe(select(getOpenIdTokenValue));\n    }\n};\nKymaService.ctorParameters = () => [\n    { type: Store }\n];\nKymaService.ɵprov = ɵɵdefineInjectable({ factory: function KymaService_Factory() { return new KymaService(ɵɵinject(Store)); }, token: KymaService, providedIn: \"root\" });\nKymaService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], KymaService);\n\nconst defaultKymaConfig = {\n    authentication: {\n        kyma_enabled: false,\n        kyma_client_id: 'client4kyma',\n        kyma_client_secret: 'secret',\n    },\n};\n\nconst OAUTH_ENDPOINT$2 = '/authorizationserver/oauth/token';\nlet OpenIdAuthenticationTokenService = class OpenIdAuthenticationTokenService {\n    constructor(config, http) {\n        this.config = config;\n        this.http = http;\n    }\n    loadOpenIdAuthenticationToken(username, password) {\n        const url = this.getOAuthEndpoint();\n        const params = new HttpParams()\n            .set('client_id', encodeURIComponent(this.config.authentication.kyma_client_id))\n            .set('client_secret', encodeURIComponent(this.config.authentication.kyma_client_secret))\n            .set('grant_type', 'password') // authorization_code, client_credentials, password\n            .set('username', username)\n            .set('password', password)\n            .set('scope', 'openid');\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded',\n        });\n        return this.http\n            .post(url, params, { headers })\n            .pipe(catchError(error => throwError(error)));\n    }\n    getOAuthEndpoint() {\n        return (this.config.backend.occ.baseUrl || '') + OAUTH_ENDPOINT$2;\n    }\n};\nOpenIdAuthenticationTokenService.ctorParameters = () => [\n    { type: KymaConfig },\n    { type: HttpClient }\n];\nOpenIdAuthenticationTokenService = __decorate([\n    Injectable()\n], OpenIdAuthenticationTokenService);\n\nconst KymaServices = [OpenIdAuthenticationTokenService];\n\nlet OpenIdTokenEffect = class OpenIdTokenEffect {\n    constructor(actions$, openIdTokenService, config) {\n        this.actions$ = actions$;\n        this.openIdTokenService = openIdTokenService;\n        this.config = config;\n        this.triggerOpenIdTokenLoading$ = iif(() => this.config.authentication && this.config.authentication.kyma_enabled, this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), withLatestFrom(this.actions$.pipe(ofType(LOAD_USER_TOKEN))), map(([, loginAction]) => new LoadOpenIdToken({\n            username: loginAction.payload.userId,\n            password: loginAction.payload.password,\n        }))));\n        this.loadOpenIdToken$ = this.actions$.pipe(ofType(LOAD_OPEN_ID_TOKEN), map((action) => action.payload), exhaustMap(payload => this.openIdTokenService\n            .loadOpenIdAuthenticationToken(payload.username, payload.password)\n            .pipe(map(token => new LoadOpenIdTokenSuccess(token)), catchError(error => of(new LoadOpenIdTokenFail(makeErrorSerializable(error)))))));\n    }\n};\nOpenIdTokenEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: OpenIdAuthenticationTokenService },\n    { type: KymaConfig }\n];\n__decorate([\n    Effect()\n], OpenIdTokenEffect.prototype, \"triggerOpenIdTokenLoading$\", void 0);\n__decorate([\n    Effect()\n], OpenIdTokenEffect.prototype, \"loadOpenIdToken$\", void 0);\nOpenIdTokenEffect = __decorate([\n    Injectable()\n], OpenIdTokenEffect);\n\nconst effects$9 = [OpenIdTokenEffect];\n\nfunction getReducers$9() {\n    return {\n        openIdToken: loaderReducer(OPEN_ID_TOKEN_DATA),\n    };\n}\nconst reducerToken$9 = new InjectionToken('KymaReducers');\nconst reducerProvider$9 = {\n    provide: reducerToken$9,\n    useFactory: getReducers$9,\n};\nfunction clearKymaState(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT) {\n            state = Object.assign(Object.assign({}, state), { openIdToken: undefined });\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers$5 = [clearKymaState];\n\nfunction kymaStoreConfigFactory() {\n    // if we want to reuse KYMA_FEATURE const in config, we have to use factory instead of plain object\n    const config = {\n        state: {\n            storageSync: {\n                keys: {\n                    'kyma.openIdToken.value': StorageSyncType.LOCAL_STORAGE,\n                },\n            },\n        },\n    };\n    return config;\n}\nlet KymaStoreModule = class KymaStoreModule {\n};\nKymaStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StateModule,\n            StoreModule.forFeature(KYMA_FEATURE, reducerToken$9, { metaReducers: metaReducers$5 }),\n            EffectsModule.forFeature(effects$9),\n            ConfigModule.withConfigFactory(kymaStoreConfigFactory),\n        ],\n        providers: [reducerProvider$9],\n    })\n], KymaStoreModule);\n\nlet KymaModule = class KymaModule {\n};\nKymaModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            KymaStoreModule,\n            ConfigModule.withConfig(defaultKymaConfig),\n        ],\n        providers: [...KymaServices, { provide: KymaConfig, useExisting: Config }],\n    })\n], KymaModule);\n\nclass PersonalizationConfig {\n}\n\nconst defaultPersonalizationConfig = {\n    personalization: {\n        enabled: false,\n        httpHeaderName: {\n            id: 'Occ-Personalization-Id',\n            timestamp: 'Occ-Personalization-Time',\n        },\n        context: {\n            slotPosition: 'PlaceholderContentSlot',\n            componentId: 'PersonalizationScriptComponent',\n        },\n    },\n};\n\nconst PERSONALIZATION_ID_KEY = 'personalization-id';\nlet OccPersonalizationIdInterceptor = class OccPersonalizationIdInterceptor {\n    constructor(config, occEndpoints, winRef, platform) {\n        this.config = config;\n        this.occEndpoints = occEndpoints;\n        this.winRef = winRef;\n        this.platform = platform;\n        this.enabled = false;\n        if (isPlatformBrowser(this.platform)) {\n            this.enabled =\n                (this.winRef.localStorage && this.config.personalization.enabled) ||\n                    false;\n            if (this.enabled) {\n                this.requestHeader = this.config.personalization.httpHeaderName.id.toLowerCase();\n                this.personalizationId = this.winRef.localStorage.getItem(PERSONALIZATION_ID_KEY);\n            }\n            else if (this.winRef.localStorage.getItem(PERSONALIZATION_ID_KEY)) {\n                this.winRef.localStorage.removeItem(PERSONALIZATION_ID_KEY);\n            }\n        }\n    }\n    intercept(request, next) {\n        if (!this.enabled) {\n            return next.handle(request);\n        }\n        if (this.personalizationId &&\n            request.url.includes(this.occEndpoints.getBaseEndpoint())) {\n            request = request.clone({\n                setHeaders: {\n                    [this.requestHeader]: this.personalizationId,\n                },\n            });\n        }\n        return next.handle(request).pipe(tap(event => {\n            if (event instanceof HttpResponse) {\n                if (event.headers.keys().includes(this.requestHeader)) {\n                    const receivedId = event.headers.get(this.requestHeader);\n                    if (this.personalizationId !== receivedId) {\n                        this.personalizationId = receivedId;\n                        this.winRef.localStorage.setItem(PERSONALIZATION_ID_KEY, this.personalizationId);\n                    }\n                }\n            }\n        }));\n    }\n};\nOccPersonalizationIdInterceptor.ctorParameters = () => [\n    { type: PersonalizationConfig },\n    { type: OccEndpointsService },\n    { type: WindowRef },\n    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\nOccPersonalizationIdInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function OccPersonalizationIdInterceptor_Factory() { return new OccPersonalizationIdInterceptor(ɵɵinject(PersonalizationConfig), ɵɵinject(OccEndpointsService), ɵɵinject(WindowRef), ɵɵinject(PLATFORM_ID)); }, token: OccPersonalizationIdInterceptor, providedIn: \"root\" });\nOccPersonalizationIdInterceptor = __decorate([\n    Injectable({ providedIn: 'root' }),\n    __param(3, Inject(PLATFORM_ID))\n], OccPersonalizationIdInterceptor);\n\nconst PERSONALIZATION_TIME_KEY = 'personalization-time';\nlet OccPersonalizationTimeInterceptor = class OccPersonalizationTimeInterceptor {\n    constructor(config, occEndpoints, winRef, platform) {\n        this.config = config;\n        this.occEndpoints = occEndpoints;\n        this.winRef = winRef;\n        this.platform = platform;\n        this.enabled = false;\n        if (isPlatformBrowser(this.platform)) {\n            this.enabled =\n                (this.winRef.localStorage && this.config.personalization.enabled) ||\n                    false;\n            if (this.enabled) {\n                this.requestHeader = this.config.personalization.httpHeaderName.timestamp.toLowerCase();\n                this.timestamp = this.winRef.localStorage.getItem(PERSONALIZATION_TIME_KEY);\n            }\n            else if (this.winRef.localStorage.getItem(PERSONALIZATION_TIME_KEY)) {\n                this.winRef.localStorage.removeItem(PERSONALIZATION_TIME_KEY);\n            }\n        }\n    }\n    intercept(request, next) {\n        if (!this.enabled) {\n            return next.handle(request);\n        }\n        if (this.timestamp &&\n            request.url.includes(this.occEndpoints.getBaseEndpoint())) {\n            request = request.clone({\n                setHeaders: {\n                    [this.requestHeader]: this.timestamp,\n                },\n            });\n        }\n        return next.handle(request).pipe(tap(event => {\n            if (event instanceof HttpResponse) {\n                if (event.headers.keys().includes(this.requestHeader)) {\n                    const receivedTimestamp = event.headers.get(this.requestHeader);\n                    if (this.timestamp !== receivedTimestamp) {\n                        this.timestamp = receivedTimestamp;\n                        this.winRef.localStorage.setItem(PERSONALIZATION_TIME_KEY, this.timestamp);\n                    }\n                }\n            }\n        }));\n    }\n};\nOccPersonalizationTimeInterceptor.ctorParameters = () => [\n    { type: PersonalizationConfig },\n    { type: OccEndpointsService },\n    { type: WindowRef },\n    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\nOccPersonalizationTimeInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function OccPersonalizationTimeInterceptor_Factory() { return new OccPersonalizationTimeInterceptor(ɵɵinject(PersonalizationConfig), ɵɵinject(OccEndpointsService), ɵɵinject(WindowRef), ɵɵinject(PLATFORM_ID)); }, token: OccPersonalizationTimeInterceptor, providedIn: \"root\" });\nOccPersonalizationTimeInterceptor = __decorate([\n    Injectable({ providedIn: 'root' }),\n    __param(3, Inject(PLATFORM_ID))\n], OccPersonalizationTimeInterceptor);\n\nconst interceptors$3 = [\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: OccPersonalizationIdInterceptor,\n        multi: true,\n    },\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: OccPersonalizationTimeInterceptor,\n        multi: true,\n    },\n];\n\nvar PersonalizationModule_1;\nlet PersonalizationModule = PersonalizationModule_1 = class PersonalizationModule {\n    static forRoot() {\n        return {\n            ngModule: PersonalizationModule_1,\n            providers: [...interceptors$3],\n        };\n    }\n};\nPersonalizationModule = PersonalizationModule_1 = __decorate([\n    NgModule({\n        imports: [ConfigModule.withConfig(defaultPersonalizationConfig)],\n        providers: [{ provide: PersonalizationConfig, useExisting: Config }],\n    })\n], PersonalizationModule);\n\nlet PersonalizationContextService = class PersonalizationContextService {\n    constructor(config, cmsService) {\n        this.config = config;\n        this.cmsService = cmsService;\n    }\n    getPersonalizationContext() {\n        return this.cmsService.getCurrentPage().pipe(filter(Boolean), map((page) => page.slots[this.config.personalization.context.slotPosition]), filter(Boolean), map((slot) => slot.components.find(i => i.uid === this.config.personalization.context.componentId)), filter(Boolean), map((component) => this.buildPersonalizationContext(component.properties.script.data)));\n    }\n    buildPersonalizationContext(data) {\n        const context = JSON.parse(atob(data));\n        context.actions.forEach(action => {\n            Object.keys(action).forEach(key => {\n                action[key] = atob(action[key]);\n            });\n        });\n        for (let i = 0; i < context.segments.length; i++) {\n            context.segments[i] = atob(context.segments[i]);\n        }\n        return context;\n    }\n};\nPersonalizationContextService.ctorParameters = () => [\n    { type: PersonalizationConfig },\n    { type: CmsService }\n];\nPersonalizationContextService.ɵprov = ɵɵdefineInjectable({ factory: function PersonalizationContextService_Factory() { return new PersonalizationContextService(ɵɵinject(PersonalizationConfig), ɵɵinject(CmsService)); }, token: PersonalizationContextService, providedIn: \"root\" });\nPersonalizationContextService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], PersonalizationContextService);\n\nfunction getReducers$a() {\n    return entityLoaderReducer(PROCESS_FEATURE);\n}\nconst reducerToken$a = new InjectionToken('ProcessReducers');\nconst reducerProvider$a = {\n    provide: reducerToken$a,\n    useFactory: getReducers$a,\n};\n\nlet ProcessStoreModule = class ProcessStoreModule {\n};\nProcessStoreModule = __decorate([\n    NgModule({\n        imports: [StateModule, StoreModule.forFeature(PROCESS_FEATURE, reducerToken$a)],\n        providers: [reducerProvider$a],\n    })\n], ProcessStoreModule);\n\nvar ProcessModule_1;\nlet ProcessModule = ProcessModule_1 = class ProcessModule {\n    static forRoot() {\n        return {\n            ngModule: ProcessModule_1,\n            providers: [],\n        };\n    }\n};\nProcessModule = ProcessModule_1 = __decorate([\n    NgModule({\n        imports: [ProcessStoreModule],\n    })\n], ProcessModule);\n\nlet ProductConnector = class ProductConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    get(productCode, scope = '') {\n        return this.adapter.load(productCode, scope);\n    }\n    getMany(products) {\n        if (!this.adapter.loadMany) {\n            return products.map(product => (Object.assign(Object.assign({}, product), { data$: this.adapter.load(product.code, product.scope) })));\n        }\n        return this.adapter.loadMany(products);\n    }\n};\nProductConnector.ctorParameters = () => [\n    { type: ProductAdapter }\n];\nProductConnector.ɵprov = ɵɵdefineInjectable({ factory: function ProductConnector_Factory() { return new ProductConnector(ɵɵinject(ProductAdapter)); }, token: ProductConnector, providedIn: \"root\" });\nProductConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ProductConnector);\n\nlet ProductReferencesConnector = class ProductReferencesConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    get(productCode, referenceType, pageSize) {\n        return this.adapter.load(productCode, referenceType, pageSize);\n    }\n};\nProductReferencesConnector.ctorParameters = () => [\n    { type: ProductReferencesAdapter }\n];\nProductReferencesConnector.ɵprov = ɵɵdefineInjectable({ factory: function ProductReferencesConnector_Factory() { return new ProductReferencesConnector(ɵɵinject(ProductReferencesAdapter)); }, token: ProductReferencesConnector, providedIn: \"root\" });\nProductReferencesConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ProductReferencesConnector);\n\nlet ProductReviewsConnector = class ProductReviewsConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    get(productCode, maxCount) {\n        return this.adapter.load(productCode, maxCount);\n    }\n    add(productCode, review) {\n        return this.adapter.post(productCode, review);\n    }\n};\nProductReviewsConnector.ctorParameters = () => [\n    { type: ProductReviewsAdapter }\n];\nProductReviewsConnector.ɵprov = ɵɵdefineInjectable({ factory: function ProductReviewsConnector_Factory() { return new ProductReviewsConnector(ɵɵinject(ProductReviewsAdapter)); }, token: ProductReviewsConnector, providedIn: \"root\" });\nProductReviewsConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ProductReviewsConnector);\n\nlet ProductSearchConnector = class ProductSearchConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    search(query, searchConfig) {\n        return this.adapter.search(query, searchConfig);\n    }\n    getSuggestions(term, pageSize) {\n        return this.adapter.loadSuggestions(term, pageSize);\n    }\n};\nProductSearchConnector.ctorParameters = () => [\n    { type: ProductSearchAdapter }\n];\nProductSearchConnector.ɵprov = ɵɵdefineInjectable({ factory: function ProductSearchConnector_Factory() { return new ProductSearchConnector(ɵɵinject(ProductSearchAdapter)); }, token: ProductSearchConnector, providedIn: \"root\" });\nProductSearchConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ProductSearchConnector);\n\nconst LOAD_PRODUCT_REFERENCES = '[Product] Load Product References Data';\nconst LOAD_PRODUCT_REFERENCES_FAIL = '[Product] Load Product References Data Fail';\nconst LOAD_PRODUCT_REFERENCES_SUCCESS = '[Product] Load Product References Data Success';\nconst CLEAN_PRODUCT_REFERENCES = '[Product] Clean Product References';\nclass LoadProductReferences {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_REFERENCES;\n    }\n}\nclass LoadProductReferencesFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_REFERENCES_FAIL;\n    }\n}\nclass LoadProductReferencesSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_REFERENCES_SUCCESS;\n    }\n}\nclass CleanProductReferences {\n    constructor() {\n        this.type = CLEAN_PRODUCT_REFERENCES;\n    }\n}\n\nconst LOAD_PRODUCT_REVIEWS = '[Product] Load Product Reviews Data';\nconst LOAD_PRODUCT_REVIEWS_FAIL = '[Product] Load Product Reviews Data Fail';\nconst LOAD_PRODUCT_REVIEWS_SUCCESS = '[Product] Load Product Reviews Data Success';\nconst POST_PRODUCT_REVIEW = '[Product] Post Product Review';\nconst POST_PRODUCT_REVIEW_FAIL = '[Product] Post Product Review Fail';\nconst POST_PRODUCT_REVIEW_SUCCESS = '[Product] Post Product Review Success';\nclass LoadProductReviews {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_REVIEWS;\n    }\n}\nclass LoadProductReviewsFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_REVIEWS_FAIL;\n    }\n}\nclass LoadProductReviewsSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_REVIEWS_SUCCESS;\n    }\n}\nclass PostProductReview {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = POST_PRODUCT_REVIEW;\n    }\n}\nclass PostProductReviewFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = POST_PRODUCT_REVIEW_FAIL;\n    }\n}\nclass PostProductReviewSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = POST_PRODUCT_REVIEW_SUCCESS;\n    }\n}\n\nconst SEARCH_PRODUCTS = '[Product] Search Products';\nconst SEARCH_PRODUCTS_FAIL = '[Product] Search Products Fail';\nconst SEARCH_PRODUCTS_SUCCESS = '[Product] Search Products Success';\nconst GET_PRODUCT_SUGGESTIONS = '[Product] Get Product Suggestions';\nconst GET_PRODUCT_SUGGESTIONS_SUCCESS = '[Product] Get Product Suggestions Success';\nconst GET_PRODUCT_SUGGESTIONS_FAIL = '[Product] Get Product Suggestions Fail';\nconst CLEAR_PRODUCT_SEARCH_RESULT = '[Product] Clear Product Search Result';\nclass SearchProducts {\n    constructor(payload, auxiliary) {\n        this.payload = payload;\n        this.auxiliary = auxiliary;\n        this.type = SEARCH_PRODUCTS;\n    }\n}\nclass SearchProductsFail {\n    constructor(payload, auxiliary) {\n        this.payload = payload;\n        this.auxiliary = auxiliary;\n        this.type = SEARCH_PRODUCTS_FAIL;\n    }\n}\nclass SearchProductsSuccess {\n    constructor(payload, auxiliary) {\n        this.payload = payload;\n        this.auxiliary = auxiliary;\n        this.type = SEARCH_PRODUCTS_SUCCESS;\n    }\n}\nclass GetProductSuggestions {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = GET_PRODUCT_SUGGESTIONS;\n    }\n}\nclass GetProductSuggestionsSuccess {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = GET_PRODUCT_SUGGESTIONS_SUCCESS;\n    }\n}\nclass GetProductSuggestionsFail {\n    constructor(payload) {\n        this.payload = payload;\n        this.type = GET_PRODUCT_SUGGESTIONS_FAIL;\n    }\n}\nclass ClearProductSearchResult {\n    constructor(payload = {\n        clearPageResults: false,\n        clearSearchboxResults: false,\n    }) {\n        this.payload = payload;\n        this.type = CLEAR_PRODUCT_SEARCH_RESULT;\n    }\n}\n\nconst PRODUCT_FEATURE = 'product';\nconst PRODUCT_DETAIL_ENTITY = '[Product] Detail Entity';\n\nvar EntityScopedLoaderActions;\n(function (EntityScopedLoaderActions) {\n    function entityScopedLoadMeta(entityType, id, scope) {\n        return Object.assign(Object.assign({}, entityLoadMeta(entityType, id)), { scope });\n    }\n    EntityScopedLoaderActions.entityScopedLoadMeta = entityScopedLoadMeta;\n    function entityScopedFailMeta(entityType, id, scope, error) {\n        return Object.assign(Object.assign({}, entityFailMeta(entityType, id, error)), { scope });\n    }\n    EntityScopedLoaderActions.entityScopedFailMeta = entityScopedFailMeta;\n    function entityScopedSuccessMeta(entityType, id, scope) {\n        return Object.assign(Object.assign({}, entitySuccessMeta(entityType, id)), { scope });\n    }\n    EntityScopedLoaderActions.entityScopedSuccessMeta = entityScopedSuccessMeta;\n    function entityScopedResetMeta(entityType, id, scope) {\n        return Object.assign(Object.assign({}, entityResetMeta(entityType, id)), { scope });\n    }\n    EntityScopedLoaderActions.entityScopedResetMeta = entityScopedResetMeta;\n    class EntityScopedLoadAction {\n        constructor(entityType, id, scope) {\n            this.type = ENTITY_LOAD_ACTION;\n            this.meta = entityScopedLoadMeta(entityType, id, scope);\n        }\n    }\n    EntityScopedLoaderActions.EntityScopedLoadAction = EntityScopedLoadAction;\n    class EntityScopedFailAction {\n        constructor(entityType, id, scope, error) {\n            this.type = ENTITY_FAIL_ACTION;\n            this.meta = entityScopedFailMeta(entityType, id, scope, error);\n        }\n    }\n    EntityScopedLoaderActions.EntityScopedFailAction = EntityScopedFailAction;\n    class EntityScopedSuccessAction {\n        constructor(entityType, id, scope, payload) {\n            this.payload = payload;\n            this.type = ENTITY_SUCCESS_ACTION;\n            this.meta = entityScopedSuccessMeta(entityType, id, scope);\n        }\n    }\n    EntityScopedLoaderActions.EntityScopedSuccessAction = EntityScopedSuccessAction;\n    class EntityScopedResetAction {\n        constructor(entityType, id, scope) {\n            this.type = ENTITY_RESET_ACTION;\n            this.meta = entityScopedResetMeta(entityType, id, scope);\n        }\n    }\n    EntityScopedLoaderActions.EntityScopedResetAction = EntityScopedResetAction;\n})(EntityScopedLoaderActions || (EntityScopedLoaderActions = {}));\n\nconst LOAD_PRODUCT = '[Product] Load Product Data';\nconst LOAD_PRODUCT_FAIL = '[Product] Load Product Data Fail';\nconst LOAD_PRODUCT_SUCCESS = '[Product] Load Product Data Success';\nclass LoadProduct extends EntityScopedLoaderActions.EntityScopedLoadAction {\n    constructor(payload, scope = '') {\n        super(PRODUCT_DETAIL_ENTITY, payload, scope);\n        this.payload = payload;\n        this.type = LOAD_PRODUCT;\n    }\n}\nclass LoadProductFail extends EntityScopedLoaderActions.EntityScopedFailAction {\n    constructor(productCode, payload, scope = '') {\n        super(PRODUCT_DETAIL_ENTITY, productCode, scope, payload);\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_FAIL;\n    }\n}\nclass LoadProductSuccess extends EntityScopedLoaderActions.EntityScopedSuccessAction {\n    constructor(payload, scope = '') {\n        super(PRODUCT_DETAIL_ENTITY, payload.code, scope);\n        this.payload = payload;\n        this.type = LOAD_PRODUCT_SUCCESS;\n    }\n}\n\n\n\nvar productGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LOAD_PRODUCT_REFERENCES: LOAD_PRODUCT_REFERENCES,\n    LOAD_PRODUCT_REFERENCES_FAIL: LOAD_PRODUCT_REFERENCES_FAIL,\n    LOAD_PRODUCT_REFERENCES_SUCCESS: LOAD_PRODUCT_REFERENCES_SUCCESS,\n    CLEAN_PRODUCT_REFERENCES: CLEAN_PRODUCT_REFERENCES,\n    LoadProductReferences: LoadProductReferences,\n    LoadProductReferencesFail: LoadProductReferencesFail,\n    LoadProductReferencesSuccess: LoadProductReferencesSuccess,\n    CleanProductReferences: CleanProductReferences,\n    LOAD_PRODUCT_REVIEWS: LOAD_PRODUCT_REVIEWS,\n    LOAD_PRODUCT_REVIEWS_FAIL: LOAD_PRODUCT_REVIEWS_FAIL,\n    LOAD_PRODUCT_REVIEWS_SUCCESS: LOAD_PRODUCT_REVIEWS_SUCCESS,\n    POST_PRODUCT_REVIEW: POST_PRODUCT_REVIEW,\n    POST_PRODUCT_REVIEW_FAIL: POST_PRODUCT_REVIEW_FAIL,\n    POST_PRODUCT_REVIEW_SUCCESS: POST_PRODUCT_REVIEW_SUCCESS,\n    LoadProductReviews: LoadProductReviews,\n    LoadProductReviewsFail: LoadProductReviewsFail,\n    LoadProductReviewsSuccess: LoadProductReviewsSuccess,\n    PostProductReview: PostProductReview,\n    PostProductReviewFail: PostProductReviewFail,\n    PostProductReviewSuccess: PostProductReviewSuccess,\n    SEARCH_PRODUCTS: SEARCH_PRODUCTS,\n    SEARCH_PRODUCTS_FAIL: SEARCH_PRODUCTS_FAIL,\n    SEARCH_PRODUCTS_SUCCESS: SEARCH_PRODUCTS_SUCCESS,\n    GET_PRODUCT_SUGGESTIONS: GET_PRODUCT_SUGGESTIONS,\n    GET_PRODUCT_SUGGESTIONS_SUCCESS: GET_PRODUCT_SUGGESTIONS_SUCCESS,\n    GET_PRODUCT_SUGGESTIONS_FAIL: GET_PRODUCT_SUGGESTIONS_FAIL,\n    CLEAR_PRODUCT_SEARCH_RESULT: CLEAR_PRODUCT_SEARCH_RESULT,\n    SearchProducts: SearchProducts,\n    SearchProductsFail: SearchProductsFail,\n    SearchProductsSuccess: SearchProductsSuccess,\n    GetProductSuggestions: GetProductSuggestions,\n    GetProductSuggestionsSuccess: GetProductSuggestionsSuccess,\n    GetProductSuggestionsFail: GetProductSuggestionsFail,\n    ClearProductSearchResult: ClearProductSearchResult,\n    LOAD_PRODUCT: LOAD_PRODUCT,\n    LOAD_PRODUCT_FAIL: LOAD_PRODUCT_FAIL,\n    LOAD_PRODUCT_SUCCESS: LOAD_PRODUCT_SUCCESS,\n    LoadProduct: LoadProduct,\n    LoadProductFail: LoadProductFail,\n    LoadProductSuccess: LoadProductSuccess\n});\n\nconst getProductsState = createFeatureSelector(PRODUCT_FEATURE);\n\nconst ɵ0$F = (state) => state.references;\nconst getProductReferencesState = createSelector(getProductsState, ɵ0$F);\nconst getSelectedProductReferencesFactory = (productCode, referenceType) => {\n    return createSelector(getProductReferencesState, referenceTypeData => {\n        if (referenceTypeData.productCode === productCode) {\n            if (!!referenceTypeData.list) {\n                if (referenceType) {\n                    return referenceTypeData.list.filter(item => item.referenceType === referenceType);\n                }\n                return referenceTypeData.list;\n            }\n            else {\n                return [];\n            }\n        }\n    });\n};\n\nconst ɵ0$G = (state) => state.reviews;\nconst getProductReviewsState = createSelector(getProductsState, ɵ0$G);\nconst getSelectedProductReviewsFactory = (productCode) => {\n    return createSelector(getProductReviewsState, reviewData => {\n        if (reviewData.productCode === productCode) {\n            return reviewData.list;\n        }\n    });\n};\n\nconst initialState$i = {\n    results: {},\n    suggestions: [],\n    auxResults: {},\n};\nfunction reducer$i(state = initialState$i, action) {\n    switch (action.type) {\n        case SEARCH_PRODUCTS_SUCCESS: {\n            const results = action.payload;\n            const res = action.auxiliary ? { auxResults: results } : { results };\n            return Object.assign(Object.assign({}, state), res);\n        }\n        case GET_PRODUCT_SUGGESTIONS_SUCCESS: {\n            const suggestions = action.payload;\n            return Object.assign(Object.assign({}, state), { suggestions });\n        }\n        case CLEAR_PRODUCT_SEARCH_RESULT: {\n            return Object.assign(Object.assign({}, state), { results: action.payload.clearPageResults ? {} : state.results, suggestions: action.payload.clearSearchboxResults\n                    ? []\n                    : state.suggestions, auxResults: action.payload.clearSearchboxResults\n                    ? {}\n                    : state.auxResults });\n        }\n    }\n    return state;\n}\nconst getSearchResults = (state) => state.results;\nconst getAuxSearchResults = (state) => state.auxResults;\nconst getProductSuggestions = (state) => state.suggestions;\n\nconst ɵ0$H = (state) => state.search;\nconst getProductsSearchState = createSelector(getProductsState, ɵ0$H);\nconst getSearchResults$1 = createSelector(getProductsSearchState, getSearchResults);\nconst getAuxSearchResults$1 = createSelector(getProductsSearchState, getAuxSearchResults);\nconst getProductSuggestions$1 = createSelector(getProductsSearchState, getProductSuggestions);\n\nconst ɵ0$I = (state) => state.details;\nconst getProductState = createSelector(getProductsState, ɵ0$I);\nconst getSelectedProductsFactory = (codes) => {\n    return createSelector(getProductState, (details) => {\n        return codes\n            .map(code => details.entities[code] ? details.entities[code].value : undefined)\n            .filter(product => product !== undefined);\n    });\n};\nconst getSelectedProductStateFactory = (code, scope) => {\n    return createSelector(getProductState, details => scope\n        ? entityStateSelector(details, code)[scope] || initialLoaderState\n        : entityStateSelector(details, code));\n};\nconst getSelectedProductFactory = (code, scope) => {\n    return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderValueSelector(productState));\n};\nconst getSelectedProductLoadingFactory = (code, scope) => {\n    return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderLoadingSelector(productState));\n};\nconst getSelectedProductSuccessFactory = (code, scope) => {\n    return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderSuccessSelector(productState));\n};\nconst getSelectedProductErrorFactory = (code, scope) => {\n    return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderErrorSelector(productState));\n};\nconst ɵ1$s = details => {\n    return Object.keys(details.entities);\n};\nconst getAllProductCodes = createSelector(getProductState, ɵ1$s);\n\n\n\nvar productGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getProductsState: getProductsState,\n    getProductReferencesState: getProductReferencesState,\n    getSelectedProductReferencesFactory: getSelectedProductReferencesFactory,\n    ɵ0: ɵ0$F,\n    getProductReviewsState: getProductReviewsState,\n    getSelectedProductReviewsFactory: getSelectedProductReviewsFactory,\n    getProductsSearchState: getProductsSearchState,\n    getSearchResults: getSearchResults$1,\n    getAuxSearchResults: getAuxSearchResults$1,\n    getProductSuggestions: getProductSuggestions$1,\n    getProductState: getProductState,\n    getSelectedProductsFactory: getSelectedProductsFactory,\n    getSelectedProductStateFactory: getSelectedProductStateFactory,\n    getSelectedProductFactory: getSelectedProductFactory,\n    getSelectedProductLoadingFactory: getSelectedProductLoadingFactory,\n    getSelectedProductSuccessFactory: getSelectedProductSuccessFactory,\n    getSelectedProductErrorFactory: getSelectedProductErrorFactory,\n    getAllProductCodes: getAllProductCodes,\n    ɵ1: ɵ1$s\n});\n\nlet ProductReferenceService = class ProductReferenceService {\n    constructor(store) {\n        this.store = store;\n    }\n    get(productCode, referenceType, pageSize) {\n        return this.store.pipe(select(getSelectedProductReferencesFactory(productCode, referenceType)), tap(references => {\n            if (references === undefined && productCode !== undefined) {\n                this.store.dispatch(new LoadProductReferences({\n                    productCode,\n                    referenceType,\n                    pageSize,\n                }));\n            }\n        }));\n    }\n    cleanReferences() {\n        this.store.dispatch(new CleanProductReferences());\n    }\n};\nProductReferenceService.ctorParameters = () => [\n    { type: Store }\n];\nProductReferenceService = __decorate([\n    Injectable()\n], ProductReferenceService);\n\nlet ProductReviewService = class ProductReviewService {\n    constructor(store) {\n        this.store = store;\n    }\n    getByProductCode(productCode) {\n        return this.store.pipe(select(getSelectedProductReviewsFactory(productCode)), tap(reviews => {\n            if (reviews === undefined && productCode !== undefined) {\n                this.store.dispatch(new LoadProductReviews(productCode));\n            }\n        }));\n    }\n    add(productCode, review) {\n        this.store.dispatch(new PostProductReview({\n            productCode: productCode,\n            review,\n        }));\n    }\n};\nProductReviewService.ctorParameters = () => [\n    { type: Store }\n];\nProductReviewService = __decorate([\n    Injectable()\n], ProductReviewService);\n\nlet ProductSearchService = class ProductSearchService {\n    constructor(store) {\n        this.store = store;\n    }\n    search(query, searchConfig) {\n        this.store.dispatch(new SearchProducts({\n            queryText: query,\n            searchConfig: searchConfig,\n        }));\n    }\n    getResults() {\n        return this.store.pipe(select(getSearchResults$1));\n    }\n    clearResults() {\n        this.store.dispatch(new ClearProductSearchResult({\n            clearPageResults: true,\n        }));\n    }\n};\nProductSearchService.ctorParameters = () => [\n    { type: Store }\n];\nProductSearchService = __decorate([\n    Injectable()\n], ProductSearchService);\n\nlet ProductLoadingService = class ProductLoadingService {\n    constructor(store, loadingScopes, actions$, platformId) {\n        this.store = store;\n        this.loadingScopes = loadingScopes;\n        this.actions$ = actions$;\n        this.platformId = platformId;\n        this.products = {};\n    }\n    get(productCode, scopes) {\n        scopes = this.loadingScopes.expand('product', scopes);\n        this.initProductScopes(productCode, scopes);\n        return this.products[productCode][this.getScopesIndex(scopes)];\n    }\n    initProductScopes(productCode, scopes) {\n        if (!this.products[productCode]) {\n            this.products[productCode] = {};\n        }\n        for (const scope of scopes) {\n            if (!this.products[productCode][scope]) {\n                this.products[productCode][scope] = this.getProductForScope(productCode, scope);\n            }\n        }\n        if (scopes.length > 1) {\n            this.products[productCode][this.getScopesIndex(scopes)] = combineLatest(scopes.map(scope => this.products[productCode][scope])).pipe(auditTime(0), map(productParts => productParts.every(Boolean)\n                ? deepMerge({}, ...productParts)\n                : undefined), distinctUntilChanged());\n        }\n    }\n    getScopesIndex(scopes) {\n        return scopes.join('ɵ');\n    }\n    /**\n     * Creates observable for providing specified product data for the scope\n     *\n     * @param productCode\n     * @param scope\n     */\n    getProductForScope(productCode, scope) {\n        const shouldLoad$ = this.store.pipe(select(getSelectedProductStateFactory(productCode, scope)), map(productState => !productState.loading && !productState.success && !productState.error), distinctUntilChanged(), filter(x => x));\n        const isLoading$ = this.store.pipe(select(getSelectedProductLoadingFactory(productCode, scope)));\n        const productLoadLogic$ = merge(shouldLoad$, ...this.getProductReloadTriggers(productCode, scope)).pipe(debounceTime(0), withLatestFrom(isLoading$), tap(([, isLoading]) => {\n            if (!isLoading) {\n                this.store.dispatch(new LoadProduct(productCode, scope));\n            }\n        }));\n        const productData$ = this.store.pipe(select(getSelectedProductFactory(productCode, scope)));\n        return using(() => productLoadLogic$.subscribe(), () => productData$).pipe(shareReplay({ bufferSize: 1, refCount: true }));\n    }\n    /**\n     * Returns reload triggers for product per scope\n     *\n     * @param productCode\n     * @param scope\n     */\n    getProductReloadTriggers(productCode, scope) {\n        const triggers = [];\n        // max age trigger add\n        const maxAge = this.loadingScopes.getMaxAge('product', scope);\n        if (maxAge && isPlatformBrowser(this.platformId)) {\n            // we want to grab load product success and load product fail for this product and scope\n            const loadFinish$ = this.actions$.pipe(filter((action) => (action.type === LOAD_PRODUCT_SUCCESS ||\n                action.type === LOAD_PRODUCT_FAIL) &&\n                action.meta.entityId === productCode &&\n                action.meta.scope === scope));\n            const loadStart$ = this.actions$.pipe(ofType(LOAD_PRODUCT), filter((action) => action.payload === productCode && action.meta.scope === scope));\n            triggers.push(this.getMaxAgeTrigger(loadStart$, loadFinish$, maxAge));\n        }\n        return triggers;\n    }\n    /**\n     * Generic method that returns stream triggering reload by maxAge\n     *\n     * Could be refactored to separate service in future to use in other\n     * max age reload implementations\n     *\n     * @param loadStart$ Stream that emits on load start\n     * @param loadFinish$ Stream that emits on load finish\n     * @param maxAge max age\n     */\n    getMaxAgeTrigger(loadStart$, loadFinish$, maxAge, scheduler) {\n        let timestamp = 0;\n        const now = () => (scheduler ? scheduler.now() : Date.now());\n        const timestamp$ = loadFinish$.pipe(tap(() => (timestamp = now())));\n        const shouldReload$ = defer(() => {\n            const age = now() - timestamp;\n            const timestampRefresh$ = timestamp$.pipe(delay(maxAge, scheduler), mapTo(true), withdrawOn(loadStart$));\n            if (age > maxAge) {\n                // we should emit first value immediately\n                return merge(of(true), timestampRefresh$);\n            }\n            else if (age === 0) {\n                // edge case, we should emit max age timeout after next load success\n                // could happen with artificial schedulers\n                return timestampRefresh$;\n            }\n            else {\n                // we should emit first value when age will expire\n                return merge(of(true).pipe(delay(maxAge - age, scheduler)), timestampRefresh$);\n            }\n        });\n        return shouldReload$;\n    }\n};\nProductLoadingService.ctorParameters = () => [\n    { type: Store },\n    { type: LoadingScopesService },\n    { type: Actions },\n    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\nProductLoadingService.ɵprov = ɵɵdefineInjectable({ factory: function ProductLoadingService_Factory() { return new ProductLoadingService(ɵɵinject(Store), ɵɵinject(LoadingScopesService), ɵɵinject(Actions), ɵɵinject(PLATFORM_ID)); }, token: ProductLoadingService, providedIn: \"root\" });\nProductLoadingService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    }),\n    __param(3, Inject(PLATFORM_ID))\n], ProductLoadingService);\n\nlet ProductService = class ProductService {\n    constructor(store, productLoading) {\n        this.store = store;\n        this.productLoading = productLoading;\n        /** @deprecated since 1.4 */\n        this.products = {};\n    }\n    /**\n     * Returns the product observable. The product will be loaded\n     * whenever there's no value observed.\n     *\n     * The underlying product loader ensures that the product is\n     * only loaded once, even in case of parallel observers.\n     *\n     * You should provide product data scope you are interested in to not load all\n     * the data if not needed. You can provide more than one scope.\n     *\n     * @param productCode Product code to load\n     * @param scopes Scope or scopes of the product data\n     */\n    get(productCode, scopes = '') {\n        // TODO: Remove, deprecated since 1.4\n        if (!this.productLoading) {\n            if (!this.products[productCode]) {\n                this.products[productCode] = this.store.pipe(select(getSelectedProductStateFactory(productCode)), observeOn(queueScheduler), tap(productState => {\n                    const attemptedLoad = productState.loading ||\n                        productState.success ||\n                        productState.error;\n                    if (!attemptedLoad) {\n                        this.store.dispatch(new LoadProduct(productCode));\n                    }\n                }), map(productState => productState.value), shareReplay({ bufferSize: 1, refCount: true }));\n            }\n            return this.products[productCode];\n        }\n        // END OF (TODO: Remove, deprecated since 1.4)\n        return this.productLoading.get(productCode, [].concat(scopes));\n    }\n    /**\n     * Returns boolean observable for product's loading state\n     */\n    isLoading(productCode, scope = '') {\n        return this.store.pipe(select(getSelectedProductLoadingFactory(productCode, scope)));\n    }\n    /**\n     * Returns boolean observable for product's load success state\n     */\n    isSuccess(productCode, scope = '') {\n        return this.store.pipe(select(getSelectedProductSuccessFactory(productCode, scope)));\n    }\n    /**\n     * Returns boolean observable for product's load error state\n     */\n    hasError(productCode, scope = '') {\n        return this.store.pipe(select(getSelectedProductErrorFactory(productCode, scope)));\n    }\n    /**\n     * Reloads the product. The product is loaded implicetly\n     * whenever selected by the `get`, but in some cases an\n     * explicit reload might be needed.\n     */\n    reload(productCode, scope = '') {\n        this.store.dispatch(new LoadProduct(productCode, scope));\n    }\n};\nProductService.ctorParameters = () => [\n    { type: Store },\n    { type: ProductLoadingService }\n];\nProductService = __decorate([\n    Injectable()\n], ProductService);\n\nlet SearchboxService = class SearchboxService extends ProductSearchService {\n    /**\n     * dispatch the search for the search box\n     */\n    search(query, searchConfig) {\n        this.store.dispatch(new SearchProducts({\n            queryText: query,\n            searchConfig: searchConfig,\n        }, true));\n    }\n    getResults() {\n        return this.store.pipe(select(getAuxSearchResults$1));\n    }\n    /**\n     * clears the products and suggestions\n     */\n    clearResults() {\n        this.store.dispatch(new ClearProductSearchResult({\n            clearSearchboxResults: true,\n        }));\n    }\n    getSuggestionResults() {\n        return this.store.pipe(select(getProductSuggestions$1));\n    }\n    searchSuggestions(query, searchConfig) {\n        this.store.dispatch(new GetProductSuggestions({\n            term: query,\n            searchConfig: searchConfig,\n        }));\n    }\n};\nSearchboxService.ɵprov = ɵɵdefineInjectable({ factory: function SearchboxService_Factory() { return new SearchboxService(ɵɵinject(Store)); }, token: SearchboxService, providedIn: \"root\" });\nSearchboxService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SearchboxService);\n\n/**\n * Resolves the page data for the Product Listing Page\n * based on the `PageType.CATEGORY_PAGE`.\n *\n * The page title, and breadcrumbs are resolved in this implementation only.\n */\nlet CategoryPageMetaResolver = class CategoryPageMetaResolver extends PageMetaResolver {\n    constructor(routingService, productSearchService, cms, translation) {\n        super();\n        this.routingService = routingService;\n        this.productSearchService = productSearchService;\n        this.cms = cms;\n        this.translation = translation;\n        // reusable observable for search page data\n        this.searchPage$ = this.cms.getCurrentPage().pipe(filter(Boolean), switchMap((page) => \n        // only the existence of a plp component tells us if products\n        // are rendered or if this is an ordinary content page\n        this.hasProductListComponent(page)\n            ? this.productSearchService.getResults().pipe(filter(Boolean))\n            : of(page)));\n        this.pageType = PageType.CATEGORY_PAGE;\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return this.cms.getCurrentPage().pipe(filter(Boolean), switchMap((page) => {\n            // only the existence of a plp component tells us if products\n            // are rendered or if this is an ordinary content page\n            if (this.hasProductListComponent(page)) {\n                return this.productSearchService.getResults().pipe(filter(data => data.breadcrumbs && data.breadcrumbs.length > 0), switchMap(data => combineLatest([\n                    this.resolveTitle(data),\n                    this.resolveBreadcrumbLabel().pipe(switchMap(label => this.resolveBreadcrumbs(data, label))),\n                ])), map(([title, breadcrumbs]) => ({ title, breadcrumbs })));\n            }\n            else {\n                return of({\n                    title: page.title || page.name,\n                });\n            }\n        }));\n    }\n    resolveTitle(searchPage) {\n        const searchPage$ = searchPage ? of(searchPage) : this.searchPage$;\n        return searchPage$.pipe(filter((page) => !!page.pagination), switchMap(p => this.translation.translate('pageMetaResolver.category.title', {\n            count: p.pagination.totalResults,\n            query: p.breadcrumbs[0].facetValueName,\n        })));\n    }\n    /**\n     * @deprecated since version 1.3\n     * This method will removed with with 2.0\n     */\n    resolveBreadcrumbLabel() {\n        return this.translation.translate('common.home');\n    }\n    resolveBreadcrumbs(searchPage, breadcrumbLabel) {\n        const sources = searchPage && breadcrumbLabel\n            ? [of(searchPage), of(breadcrumbLabel)]\n            : [this.searchPage$.pipe(), this.translation.translate('common.home')];\n        return combineLatest(sources).pipe(map(([p, label]) => p.breadcrumbs\n            ? this.resolveBreadcrumbData(p, label)\n            : null));\n    }\n    resolveBreadcrumbData(page, label) {\n        const breadcrumbs = [];\n        breadcrumbs.push({ label: label, link: '/' });\n        for (const br of page.breadcrumbs) {\n            if (br.facetCode === 'category' || br.facetCode === 'allCategories') {\n                breadcrumbs.push({\n                    label: br.facetValueName,\n                    link: `/c/${br.facetValueCode}`,\n                });\n            }\n            if (br.facetCode === 'brand') {\n                breadcrumbs.push({\n                    label: br.facetValueName,\n                    link: `/Brands/${br.facetValueName}/c/${br.facetValueCode}`,\n                });\n            }\n        }\n        return breadcrumbs;\n    }\n    hasProductListComponent(page) {\n        return !!Object.keys(page.slots).find(key => !!page.slots[key].components.find(comp => comp.typeCode === 'CMSProductListComponent' ||\n            comp.typeCode === 'ProductGridComponent'));\n    }\n};\nCategoryPageMetaResolver.ctorParameters = () => [\n    { type: RoutingService },\n    { type: ProductSearchService },\n    { type: CmsService },\n    { type: TranslationService }\n];\nCategoryPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function CategoryPageMetaResolver_Factory() { return new CategoryPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductSearchService), ɵɵinject(CmsService), ɵɵinject(TranslationService)); }, token: CategoryPageMetaResolver, providedIn: \"root\" });\nCategoryPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CategoryPageMetaResolver);\n\n/**\n * Resolves the page data for the Product Detail Page\n * based on the `PageType.PRODUCT_PAGE`.\n *\n * The page title, heading, description, breadcrumbs and\n * first GALLERY image are resolved if available in the data.\n */\nlet ProductPageMetaResolver = class ProductPageMetaResolver extends PageMetaResolver {\n    constructor(routingService, productService, translation, features) {\n        super();\n        this.routingService = routingService;\n        this.productService = productService;\n        this.translation = translation;\n        this.features = features;\n        this.PRODUCT_SCOPE = this.features && this.features.isLevel('1.4') ? ProductScope.DETAILS : '';\n        // reusable observable for product data based on the current page\n        this.product$ = this.routingService.getRouterState().pipe(map(state => state.state.params['productCode']), filter(code => !!code), switchMap(code => this.productService.get(code, this.PRODUCT_SCOPE)), filter(Boolean));\n        this.pageType = PageType.PRODUCT_PAGE;\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return this.product$.pipe(switchMap((p) => combineLatest([\n            this.resolveHeading(p),\n            this.resolveTitle(p),\n            this.resolveDescription(p),\n            this.resolveBreadcrumbLabel().pipe(switchMap(label => this.resolveBreadcrumbs(p, label))),\n            this.resolveImage(p),\n            this.resolveRobots(p),\n        ])), map(([heading, title, description, breadcrumbs, image, robots]) => ({\n            heading,\n            title,\n            description,\n            breadcrumbs,\n            image,\n            robots,\n        })));\n    }\n    resolveHeading(product) {\n        const product$ = product ? of(product) : this.product$;\n        return product$.pipe(switchMap((p) => this.translation.translate('pageMetaResolver.product.heading', {\n            heading: p.name,\n        })));\n    }\n    resolveTitle(product) {\n        const product$ = product ? of(product) : this.product$;\n        return product$.pipe(switchMap((p) => {\n            let title = p.name;\n            title += this.resolveFirstCategory(p);\n            title += this.resolveManufacturer(p);\n            return this.translation.translate('pageMetaResolver.product.title', {\n                title: title,\n            });\n        }));\n    }\n    resolveDescription(product) {\n        const product$ = product ? of(product) : this.product$;\n        return product$.pipe(switchMap((p) => this.translation.translate('pageMetaResolver.product.description', {\n            description: p.summary,\n        })));\n    }\n    /**\n     * @deprecated since version 1.3\n     * This method will be removed with with 2.0\n     */\n    resolveBreadcrumbLabel() {\n        return this.translation.translate('common.home');\n    }\n    resolveBreadcrumbs(product, breadcrumbLabel) {\n        const sources = product && breadcrumbLabel\n            ? [of(product), of(breadcrumbLabel)]\n            : [this.product$.pipe(), this.translation.translate('common.home')];\n        return combineLatest(sources).pipe(map(([p, label]) => {\n            const breadcrumbs = [];\n            breadcrumbs.push({ label: label, link: '/' });\n            for (const { name, code, url } of p.categories || []) {\n                breadcrumbs.push({\n                    label: name || code,\n                    link: url,\n                });\n            }\n            return breadcrumbs;\n        }));\n    }\n    resolveImage(product) {\n        const product$ = product ? of(product) : this.product$;\n        return product$.pipe(map((p) => p.images &&\n            p.images.PRIMARY &&\n            p.images.PRIMARY.zoom &&\n            p.images.PRIMARY.zoom.url\n            ? p.images.PRIMARY.zoom.url\n            : null));\n    }\n    resolveFirstCategory(product) {\n        let firstCategory;\n        if (product.categories && product.categories.length > 0) {\n            firstCategory = product.categories[0];\n        }\n        return firstCategory\n            ? ` | ${firstCategory.name || firstCategory.code}`\n            : '';\n    }\n    resolveManufacturer(product) {\n        return product.manufacturer ? ` | ${product.manufacturer}` : '';\n    }\n    resolveRobots(product) {\n        const product$ = product ? of(product) : this.product$;\n        return product$.pipe(switchMap((p) => {\n            if (!p.purchasable) {\n                return of([PageRobotsMeta.FOLLOW, PageRobotsMeta.NOINDEX]);\n            }\n            else {\n                return of([PageRobotsMeta.FOLLOW, PageRobotsMeta.INDEX]);\n            }\n        }));\n    }\n};\nProductPageMetaResolver.ctorParameters = () => [\n    { type: RoutingService },\n    { type: ProductService },\n    { type: TranslationService },\n    { type: FeatureConfigService }\n];\nProductPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function ProductPageMetaResolver_Factory() { return new ProductPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductService), ɵɵinject(TranslationService), ɵɵinject(FeatureConfigService)); }, token: ProductPageMetaResolver, providedIn: \"root\" });\nProductPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], ProductPageMetaResolver);\n\n/**\n * Resolves the page data for the Search Result Page based on the\n * `PageType.CATEGORY_PAGE` and the `SearchResultsListPageTemplate` template.\n *\n * Only the page title is resolved in the implemenation.\n */\nlet SearchPageMetaResolver = class SearchPageMetaResolver extends PageMetaResolver {\n    constructor(routingService, productSearchService, translation) {\n        super();\n        this.routingService = routingService;\n        this.productSearchService = productSearchService;\n        this.translation = translation;\n        this.total$ = this.productSearchService.getResults().pipe(filter(data => !!(data && data.pagination)), map(results => results.pagination.totalResults));\n        this.query$ = this.routingService\n            .getRouterState()\n            .pipe(map(state => state.state.params['query']));\n        this.pageType = PageType.CONTENT_PAGE;\n        this.pageTemplate = 'SearchResultsListPageTemplate';\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return this.resolveTitle();\n    }\n    resolveTitle(total, query) {\n        const sources = total && query ? [of(total), of(query)] : [this.total$, this.query$];\n        return combineLatest(sources).pipe(switchMap(([t, q]) => this.translation.translate('pageMetaResolver.search.title', {\n            count: t,\n            query: q,\n        })));\n    }\n};\nSearchPageMetaResolver.ctorParameters = () => [\n    { type: RoutingService },\n    { type: ProductSearchService },\n    { type: TranslationService }\n];\nSearchPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function SearchPageMetaResolver_Factory() { return new SearchPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductSearchService), ɵɵinject(TranslationService)); }, token: SearchPageMetaResolver, providedIn: \"root\" });\nSearchPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SearchPageMetaResolver);\n\nlet ProductReferencesEffects = class ProductReferencesEffects {\n    constructor(actions$, productReferencesConnector) {\n        this.actions$ = actions$;\n        this.productReferencesConnector = productReferencesConnector;\n        this.loadProductReferences$ = this.actions$.pipe(ofType(LOAD_PRODUCT_REFERENCES), map((action) => action.payload), mergeMap(payload => {\n            return this.productReferencesConnector\n                .get(payload.productCode, payload.referenceType, payload.pageSize)\n                .pipe(map(data => {\n                return new LoadProductReferencesSuccess({\n                    productCode: payload.productCode,\n                    list: data,\n                });\n            }), catchError(_error => of(new LoadProductReferencesFail({\n                message: payload.productCode,\n            }))));\n        }));\n    }\n};\nProductReferencesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: ProductReferencesConnector }\n];\n__decorate([\n    Effect()\n], ProductReferencesEffects.prototype, \"loadProductReferences$\", void 0);\nProductReferencesEffects = __decorate([\n    Injectable()\n], ProductReferencesEffects);\n\nlet ProductReviewsEffects = class ProductReviewsEffects {\n    constructor(actions$, productReviewsConnector, globalMessageService) {\n        this.actions$ = actions$;\n        this.productReviewsConnector = productReviewsConnector;\n        this.globalMessageService = globalMessageService;\n        this.loadProductReviews$ = this.actions$.pipe(ofType(LOAD_PRODUCT_REVIEWS), map((action) => action.payload), mergeMap(productCode => {\n            return this.productReviewsConnector.get(productCode).pipe(map(data => {\n                return new LoadProductReviewsSuccess({\n                    productCode,\n                    list: data,\n                });\n            }), catchError(_error => of(new LoadProductReviewsFail({\n                message: productCode,\n            }))));\n        }));\n        this.postProductReview = this.actions$.pipe(ofType(POST_PRODUCT_REVIEW), map((action) => action.payload), mergeMap(payload => {\n            return this.productReviewsConnector\n                .add(payload.productCode, payload.review)\n                .pipe(map(reviewResponse => {\n                return new PostProductReviewSuccess(reviewResponse);\n            }), catchError(_error => of(new PostProductReviewFail(payload.productCode))));\n        }));\n        this.showGlobalMessageOnPostProductReviewSuccess$ = this.actions$.pipe(ofType(POST_PRODUCT_REVIEW_SUCCESS), tap(() => {\n            this.globalMessageService.add({ key: 'productReview.thankYouForReview' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);\n        }));\n    }\n};\nProductReviewsEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: ProductReviewsConnector },\n    { type: GlobalMessageService }\n];\n__decorate([\n    Effect()\n], ProductReviewsEffects.prototype, \"loadProductReviews$\", void 0);\n__decorate([\n    Effect()\n], ProductReviewsEffects.prototype, \"postProductReview\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], ProductReviewsEffects.prototype, \"showGlobalMessageOnPostProductReviewSuccess$\", void 0);\nProductReviewsEffects = __decorate([\n    Injectable()\n], ProductReviewsEffects);\n\nlet ProductsSearchEffects = class ProductsSearchEffects {\n    constructor(actions$, productSearchConnector) {\n        this.actions$ = actions$;\n        this.productSearchConnector = productSearchConnector;\n        this.searchProducts$ = this.actions$.pipe(ofType(SEARCH_PRODUCTS), groupBy((action) => action.auxiliary), mergeMap(group => group.pipe(switchMap((action) => {\n            return this.productSearchConnector\n                .search(action.payload.queryText, action.payload.searchConfig)\n                .pipe(map(data => {\n                return new SearchProductsSuccess(data, action.auxiliary);\n            }), catchError(error => of(new SearchProductsFail(makeErrorSerializable(error), action.auxiliary))));\n        }))));\n        this.getProductSuggestions$ = this.actions$.pipe(ofType(GET_PRODUCT_SUGGESTIONS), map((action) => action.payload), switchMap(payload => {\n            return this.productSearchConnector\n                .getSuggestions(payload.term, payload.searchConfig.pageSize)\n                .pipe(map(suggestions => {\n                if (suggestions === undefined) {\n                    return new GetProductSuggestionsSuccess([]);\n                }\n                return new GetProductSuggestionsSuccess(suggestions);\n            }), catchError(error => of(new GetProductSuggestionsFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nProductsSearchEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: ProductSearchConnector }\n];\n__decorate([\n    Effect()\n], ProductsSearchEffects.prototype, \"searchProducts$\", void 0);\n__decorate([\n    Effect()\n], ProductsSearchEffects.prototype, \"getProductSuggestions$\", void 0);\nProductsSearchEffects = __decorate([\n    Injectable()\n], ProductsSearchEffects);\n\nlet ProductEffects = class ProductEffects {\n    constructor(actions$, productConnector) {\n        this.actions$ = actions$;\n        this.productConnector = productConnector;\n        // we want to cancel all ongoing requests when currency or language changes,\n        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n        this.loadProduct$ = createEffect(() => ({ scheduler, debounce = 0 } = {}) => this.actions$.pipe(ofType(LOAD_PRODUCT), map((action) => ({\n            code: action.payload,\n            scope: action.meta.scope,\n        })), \n        // we are grouping all load actions that happens at the same time\n        // to optimize loading and pass them all to productConnector.getMany\n        bufferDebounceTime(debounce, scheduler), mergeMap(products => merge(...this.productConnector\n            .getMany(products)\n            .map(this.productLoadEffect))), withdrawOn(this.contextChange$)));\n    }\n    productLoadEffect(productLoad) {\n        return productLoad.data$.pipe(map(data => new LoadProductSuccess(Object.assign({ code: productLoad.code }, data), productLoad.scope)), catchError(error => {\n            return of(new LoadProductFail(productLoad.code, makeErrorSerializable(error), productLoad.scope));\n        }));\n    }\n};\nProductEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: ProductConnector }\n];\nProductEffects = __decorate([\n    Injectable()\n], ProductEffects);\n\nconst effects$a = [\n    ProductsSearchEffects,\n    ProductEffects,\n    ProductReviewsEffects,\n    ProductReferencesEffects,\n];\n\nconst initialState$j = {\n    productCode: '',\n    list: [],\n};\nfunction reducer$j(state = initialState$j, action) {\n    switch (action.type) {\n        case LOAD_PRODUCT_REFERENCES_SUCCESS: {\n            const productCode = action.payload.productCode;\n            const list = action.payload.list;\n            return Object.assign(Object.assign({}, state), { list: [...state.list, ...(list ? list : [])].reduce((productReferences, productReference) => {\n                    if (!productReferences.some(obj => obj.referenceType === productReference.referenceType &&\n                        obj.target.code === productReference.target.code)) {\n                        productReferences.push(productReference);\n                    }\n                    return productReferences;\n                }, []), productCode });\n        }\n        case CLEAN_PRODUCT_REFERENCES: {\n            return initialState$j;\n        }\n    }\n    return state;\n}\nconst getProductReferenceList = (state) => state.list;\nconst getProductReferenceProductCode = (state) => state.productCode;\n\nconst initialState$k = {\n    productCode: '',\n    list: [],\n};\nfunction reducer$k(state = initialState$k, action) {\n    switch (action.type) {\n        case LOAD_PRODUCT_REVIEWS_SUCCESS: {\n            const productCode = action.payload.productCode;\n            const list = action.payload.list;\n            return Object.assign(Object.assign({}, state), { productCode,\n                list });\n        }\n    }\n    return state;\n}\nconst getReviewList = (state) => state.list;\nconst getReviewProductCode = (state) => state.productCode;\n\n/**\n * Higher order reducer designed to add scope support for loader reducer\n *\n * For backward compatibility, we accommodate scopes alongside current\n * loading/error/success/value flags, thus those names can't be used as scope\n * names.\n *\n * TODO: Improve, issue #5445\n *\n * @param entityType\n * @param reducer\n */\nfunction scopedLoaderReducer(entityType, reducer) {\n    const loader = loaderReducer(entityType, reducer);\n    return (state = initialLoaderState, action) => {\n        if (action &&\n            action.meta &&\n            action.meta.entityType === entityType &&\n            action.meta.scope) {\n            return Object.assign(Object.assign({}, state), { [action.meta.scope]: loader(state[action.meta.scope], action) });\n        }\n        else {\n            return loader(state, action);\n        }\n    };\n}\n\n/**\n * Higher order reducer that wraps scopedLoaderReducer and EntityReducer enhancing\n * single state reducer to support multiple entities with generic loading flags and scopes\n */\nfunction entityScopedLoaderReducer(entityType, reducer) {\n    return entityReducer(entityType, scopedLoaderReducer(entityType, reducer));\n}\n\nfunction getReducers$b() {\n    return {\n        search: reducer$i,\n        details: entityScopedLoaderReducer(PRODUCT_DETAIL_ENTITY),\n        reviews: reducer$k,\n        references: reducer$j,\n    };\n}\nconst reducerToken$b = new InjectionToken('ProductReducers');\nconst reducerProvider$b = {\n    provide: reducerToken$b,\n    useFactory: getReducers$b,\n};\nfunction clearProductsState(reducer) {\n    return function (state, action) {\n        if (action.type === CURRENCY_CHANGE ||\n            action.type === LANGUAGE_CHANGE) {\n            state = undefined;\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers$6 = [clearProductsState];\n\nfunction productStoreConfigFactory() {\n    // if we want to reuse PRODUCT_FEATURE const in config, we have to use factory instead of plain object\n    const config = {\n        state: {\n            ssrTransfer: {\n                keys: { [PRODUCT_FEATURE]: StateTransferType.TRANSFER_STATE },\n            },\n        },\n    };\n    return config;\n}\nlet ProductStoreModule = class ProductStoreModule {\n};\nProductStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StoreModule.forFeature(PRODUCT_FEATURE, reducerToken$b, { metaReducers: metaReducers$6 }),\n            EffectsModule.forFeature(effects$a),\n            ConfigModule.withConfigFactory(productStoreConfigFactory),\n        ],\n        providers: [reducerProvider$b],\n    })\n], ProductStoreModule);\n\nvar ProductModule_1;\nconst pageTitleResolvers = [\n    {\n        provide: PageMetaResolver,\n        useExisting: ProductPageMetaResolver,\n        multi: true,\n    },\n    {\n        provide: PageMetaResolver,\n        useExisting: CategoryPageMetaResolver,\n        multi: true,\n    },\n    {\n        provide: PageMetaResolver,\n        useExisting: SearchPageMetaResolver,\n        multi: true,\n    },\n];\nlet ProductModule = ProductModule_1 = class ProductModule {\n    static forRoot() {\n        return {\n            ngModule: ProductModule_1,\n            providers: [\n                ProductService,\n                ProductSearchService,\n                ProductReviewService,\n                ProductReferenceService,\n                ...pageTitleResolvers,\n            ],\n        };\n    }\n};\nProductModule = ProductModule_1 = __decorate([\n    NgModule({\n        imports: [ProductStoreModule],\n    })\n], ProductModule);\n\nlet SmartEditService = class SmartEditService {\n    constructor(cmsService, routingService, baseSiteService, zone, winRef) {\n        this.cmsService = cmsService;\n        this.routingService = routingService;\n        this.baseSiteService = baseSiteService;\n        this.zone = zone;\n        this.winRef = winRef;\n        this.isPreviewPage = false;\n        this.getCmsTicket();\n        if (winRef.nativeWindow) {\n            const window = winRef.nativeWindow;\n            // rerender components and slots after editing\n            window.smartedit = window.smartedit || {};\n            window.smartedit.renderComponent = (componentId, componentType, parentId) => {\n                return this.renderComponent(componentId, componentType, parentId);\n            };\n            // reprocess page\n            window.smartedit.reprocessPage = this.reprocessPage;\n        }\n    }\n    get cmsTicketId() {\n        return this._cmsTicketId;\n    }\n    getCmsTicket() {\n        combineLatest([\n            this.cmsService.getCurrentPage(),\n            this.routingService.getRouterState(),\n        ])\n            .pipe(takeWhile(([cmsPage]) => cmsPage === undefined), filter(([, routerState]) => {\n            if (routerState.nextState && !this._cmsTicketId) {\n                this._cmsTicketId =\n                    routerState.nextState.queryParams['cmsTicketId'];\n                if (this._cmsTicketId) {\n                    return true;\n                }\n            }\n            return false;\n        }), take(1))\n            .subscribe(_ => {\n            this.cmsService.launchInSmartEdit = true;\n            this.getDefaultPreviewCode();\n        });\n    }\n    getDefaultPreviewCode() {\n        this.baseSiteService\n            .getBaseSiteData()\n            .pipe(filter(site => Object.keys(site).length !== 0), take(1))\n            .subscribe(site => {\n            this.defaultPreviewCategoryCode = site.defaultPreviewCategoryCode;\n            this.defaultPreviewProductCode = site.defaultPreviewProductCode;\n            this.addPageContract();\n        });\n    }\n    addPageContract() {\n        this.cmsService.getCurrentPage().subscribe(cmsPage => {\n            if (cmsPage && this._cmsTicketId) {\n                this._currentPageId = cmsPage.pageId;\n                // before adding contract to page, we need redirect to that page\n                this.goToPreviewPage(cmsPage);\n                // remove old page contract\n                const previousContract = [];\n                Array.from(this.winRef.document.body.classList).forEach(attr => previousContract.push(attr));\n                previousContract.forEach(attr => this.winRef.document.body.classList.remove(attr));\n                // add new page contract\n                if (cmsPage.properties && cmsPage.properties.smartedit) {\n                    const seClasses = cmsPage.properties.smartedit.classes.split(' ');\n                    seClasses.forEach(classItem => {\n                        this.winRef.document.body.classList.add(classItem);\n                    });\n                }\n            }\n        });\n    }\n    goToPreviewPage(cmsPage) {\n        // only the first page is the smartedit preview page\n        if (!this.isPreviewPage) {\n            this.isPreviewPage = true;\n            if (cmsPage.type === PageType.PRODUCT_PAGE &&\n                this.defaultPreviewProductCode) {\n                this.routingService.go({\n                    cxRoute: 'product',\n                    params: { code: this.defaultPreviewProductCode, name: '' },\n                });\n            }\n            else if (cmsPage.type === PageType.CATEGORY_PAGE &&\n                this.defaultPreviewCategoryCode) {\n                this.routingService.go({\n                    cxRoute: 'category',\n                    params: { code: this.defaultPreviewCategoryCode },\n                });\n            }\n        }\n    }\n    renderComponent(componentId, componentType, parentId) {\n        if (componentId) {\n            this.zone.run(() => {\n                // without parentId, it is slot\n                if (!parentId) {\n                    if (this._currentPageId) {\n                        this.cmsService.refreshPageById(this._currentPageId);\n                    }\n                    else {\n                        this.cmsService.refreshLatestPage();\n                    }\n                }\n                else if (componentType) {\n                    this.cmsService.refreshComponent(componentId);\n                }\n            });\n        }\n        return true;\n    }\n    reprocessPage() {\n        // TODO: reprocess page API\n    }\n};\nSmartEditService.ctorParameters = () => [\n    { type: CmsService },\n    { type: RoutingService },\n    { type: BaseSiteService },\n    { type: NgZone },\n    { type: WindowRef }\n];\nSmartEditService.ɵprov = ɵɵdefineInjectable({ factory: function SmartEditService_Factory() { return new SmartEditService(ɵɵinject(CmsService), ɵɵinject(RoutingService), ɵɵinject(BaseSiteService), ɵɵinject(NgZone), ɵɵinject(WindowRef)); }, token: SmartEditService, providedIn: \"root\" });\nSmartEditService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SmartEditService);\n\nlet CmsTicketInterceptor = class CmsTicketInterceptor {\n    constructor(service) {\n        this.service = service;\n    }\n    intercept(request, next) {\n        if (request.url.includes('/cms/') && this.service.cmsTicketId) {\n            request = request.clone({\n                setParams: {\n                    cmsTicketId: this.service.cmsTicketId,\n                },\n            });\n        }\n        return next.handle(request);\n    }\n};\nCmsTicketInterceptor.ctorParameters = () => [\n    { type: SmartEditService }\n];\nCmsTicketInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function CmsTicketInterceptor_Factory() { return new CmsTicketInterceptor(ɵɵinject(SmartEditService)); }, token: CmsTicketInterceptor, providedIn: \"root\" });\nCmsTicketInterceptor = __decorate([\n    Injectable({ providedIn: 'root' })\n], CmsTicketInterceptor);\n\nconst interceptors$4 = [\n    {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: CmsTicketInterceptor,\n        multi: true,\n    },\n];\n\nvar SmartEditModule_1;\nlet SmartEditModule = SmartEditModule_1 = class SmartEditModule {\n    static forRoot() {\n        return {\n            ngModule: SmartEditModule_1,\n            providers: [...interceptors$4],\n        };\n    }\n};\nSmartEditModule = SmartEditModule_1 = __decorate([\n    NgModule({})\n], SmartEditModule);\n\n/**\n * The wrapper over the standard ngExpressEngine, that provides tokens for Spartacus\n * @param ngExpressEngine\n */\nclass NgExpressEngineDecorator {\n    /**\n     * Returns the higher order ngExpressEngine with provided tokens for Spartacus\n     *\n     * @param ngExpressEngine\n     */\n    static get(ngExpressEngine) {\n        const result = function cxNgExpressEngine(setupOptions) {\n            return (filePath, options, callback) => {\n                const engineInstance = ngExpressEngine(Object.assign(Object.assign({}, setupOptions), { providers: [\n                        ...getServerRequestProviders(options),\n                        ...(setupOptions.providers || []),\n                    ] }));\n                return engineInstance(filePath, options, callback);\n            };\n        };\n        return result;\n    }\n}\n/**\n * Returns Spartacus' providers to be passed to the Angular express engine (in SSR)\n *\n * @param options\n */\nfunction getServerRequestProviders(options) {\n    return [\n        {\n            provide: SERVER_REQUEST_URL,\n            useValue: getRequestUrl(options.req),\n        },\n        {\n            provide: SERVER_REQUEST_ORIGIN,\n            useValue: getRequestOrigin(options.req),\n        },\n    ];\n}\nfunction getRequestUrl(req) {\n    return getRequestOrigin(req) + req.originalUrl;\n}\nfunction getRequestOrigin(req) {\n    return req.protocol + '://' + req.get('host');\n}\n\nclass StoreFinderConfig {\n}\n\nconst STORE_FINDER_FEATURE = 'stores';\nconst STORE_FINDER_DATA = '[StoreFinder] Store Finder Data';\n\nconst FIND_STORES_ON_HOLD = '[StoreFinder] On Hold';\nconst FIND_STORES = '[StoreFinder] Find Stores';\nconst FIND_STORES_FAIL = '[StoreFinder] Find Stores Fail';\nconst FIND_STORES_SUCCESS = '[StoreFinder] Find Stores Success';\nconst FIND_STORE_BY_ID = '[StoreFinder] Find a Store by Id';\nconst FIND_STORE_BY_ID_FAIL = '[StoreFinder] Find a Store by Id Fail';\nconst FIND_STORE_BY_ID_SUCCESS = '[StoreFinder] Find a Store by Id Success';\nclass FindStoresOnHold extends LoaderLoadAction {\n    constructor() {\n        super(STORE_FINDER_DATA);\n        this.type = FIND_STORES_ON_HOLD;\n    }\n}\nclass FindStores extends LoaderLoadAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA);\n        this.payload = payload;\n        this.type = FIND_STORES;\n    }\n}\nclass FindStoresFail extends LoaderFailAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA, payload);\n        this.payload = payload;\n        this.type = FIND_STORES_FAIL;\n    }\n}\nclass FindStoresSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA);\n        this.payload = payload;\n        this.type = FIND_STORES_SUCCESS;\n    }\n}\nclass FindStoreById extends LoaderLoadAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA);\n        this.payload = payload;\n        this.type = FIND_STORE_BY_ID;\n    }\n}\nclass FindStoreByIdFail extends LoaderFailAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA, payload);\n        this.payload = payload;\n        this.type = FIND_STORE_BY_ID_FAIL;\n    }\n}\nclass FindStoreByIdSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA);\n        this.payload = payload;\n        this.type = FIND_STORE_BY_ID_SUCCESS;\n    }\n}\n\nconst VIEW_ALL_STORES = '[StoreFinder] View All Stores';\nconst VIEW_ALL_STORES_FAIL = '[StoreFinder] View All Stores Fail';\nconst VIEW_ALL_STORES_SUCCESS = '[StoreFinder] View All Stores Success';\nclass ViewAllStores extends LoaderLoadAction {\n    constructor() {\n        super(STORE_FINDER_DATA);\n        this.type = VIEW_ALL_STORES;\n    }\n}\nclass ViewAllStoresFail extends LoaderFailAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA, payload);\n        this.payload = payload;\n        this.type = VIEW_ALL_STORES_FAIL;\n    }\n}\nclass ViewAllStoresSuccess extends LoaderSuccessAction {\n    constructor(payload) {\n        super(STORE_FINDER_DATA);\n        this.payload = payload;\n        this.type = VIEW_ALL_STORES_SUCCESS;\n    }\n}\n\n\n\nvar storeFinderGroup_actions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    FIND_STORES_ON_HOLD: FIND_STORES_ON_HOLD,\n    FIND_STORES: FIND_STORES,\n    FIND_STORES_FAIL: FIND_STORES_FAIL,\n    FIND_STORES_SUCCESS: FIND_STORES_SUCCESS,\n    FIND_STORE_BY_ID: FIND_STORE_BY_ID,\n    FIND_STORE_BY_ID_FAIL: FIND_STORE_BY_ID_FAIL,\n    FIND_STORE_BY_ID_SUCCESS: FIND_STORE_BY_ID_SUCCESS,\n    FindStoresOnHold: FindStoresOnHold,\n    FindStores: FindStores,\n    FindStoresFail: FindStoresFail,\n    FindStoresSuccess: FindStoresSuccess,\n    FindStoreById: FindStoreById,\n    FindStoreByIdFail: FindStoreByIdFail,\n    FindStoreByIdSuccess: FindStoreByIdSuccess,\n    VIEW_ALL_STORES: VIEW_ALL_STORES,\n    VIEW_ALL_STORES_FAIL: VIEW_ALL_STORES_FAIL,\n    VIEW_ALL_STORES_SUCCESS: VIEW_ALL_STORES_SUCCESS,\n    ViewAllStores: ViewAllStores,\n    ViewAllStoresFail: ViewAllStoresFail,\n    ViewAllStoresSuccess: ViewAllStoresSuccess\n});\n\nconst getStoreFinderState = createFeatureSelector(STORE_FINDER_FEATURE);\n\nconst ɵ0$J = (storesState) => storesState.findStores;\nconst getFindStoresState = createSelector(getStoreFinderState, ɵ0$J);\nconst ɵ1$t = state => loaderValueSelector(state);\nconst getFindStoresEntities = createSelector(getFindStoresState, ɵ1$t);\nconst ɵ2$k = state => loaderLoadingSelector(state);\nconst getStoresLoading = createSelector(getFindStoresState, ɵ2$k);\n\nconst ɵ0$K = (storesState) => storesState.viewAllStores;\nconst getViewAllStoresState = createSelector(getStoreFinderState, ɵ0$K);\nconst ɵ1$u = state => loaderValueSelector(state);\nconst getViewAllStoresEntities = createSelector(getViewAllStoresState, ɵ1$u);\nconst ɵ2$l = state => loaderLoadingSelector(state);\nconst getViewAllStoresLoading = createSelector(getViewAllStoresState, ɵ2$l);\n\n\n\nvar storeFinderGroup_selectors = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getFindStoresState: getFindStoresState,\n    getFindStoresEntities: getFindStoresEntities,\n    getStoresLoading: getStoresLoading,\n    ɵ0: ɵ0$J,\n    ɵ1: ɵ1$t,\n    ɵ2: ɵ2$k,\n    getViewAllStoresState: getViewAllStoresState,\n    getViewAllStoresEntities: getViewAllStoresEntities,\n    getViewAllStoresLoading: getViewAllStoresLoading\n});\n\nlet StoreFinderService = class StoreFinderService {\n    constructor(store, winRef, globalMessageService, routingService) {\n        this.store = store;\n        this.winRef = winRef;\n        this.globalMessageService = globalMessageService;\n        this.routingService = routingService;\n        this.geolocationWatchId = null;\n    }\n    /**\n     * Returns boolean observable for store's loading state\n     */\n    getStoresLoading() {\n        return this.store.pipe(select(getStoresLoading));\n    }\n    /**\n     * Returns observable for store's entities\n     */\n    getFindStoresEntities() {\n        return this.store.pipe(select(getFindStoresEntities));\n    }\n    /**\n     * Returns boolean observable for view all store's loading state\n     */\n    getViewAllStoresLoading() {\n        return this.store.pipe(select(getViewAllStoresLoading));\n    }\n    /**\n     * Returns observable for view all store's entities\n     */\n    getViewAllStoresEntities() {\n        return this.store.pipe(select(getViewAllStoresEntities));\n    }\n    /**\n     * Store finding action functionality\n     * @param queryText text query\n     * @param searchConfig search configuration\n     * @param longitudeLatitude longitude and latitude coordinates\n     * @param countryIsoCode country ISO code\n     * @param useMyLocation current location coordinates\n     */\n    findStoresAction(queryText, searchConfig, longitudeLatitude, countryIsoCode, useMyLocation) {\n        if (useMyLocation && this.winRef.nativeWindow) {\n            this.clearWatchGeolocation(new FindStoresOnHold());\n            this.geolocationWatchId = this.winRef.nativeWindow.navigator.geolocation.watchPosition((pos) => {\n                const position = {\n                    longitude: pos.coords.longitude,\n                    latitude: pos.coords.latitude,\n                };\n                this.clearWatchGeolocation(new FindStores({\n                    queryText: queryText,\n                    searchConfig: searchConfig,\n                    longitudeLatitude: position,\n                    countryIsoCode: countryIsoCode,\n                }));\n            }, () => {\n                this.globalMessageService.add({ key: 'storeFinder.geolocationNotEnabled' }, GlobalMessageType.MSG_TYPE_ERROR);\n                this.routingService.go(['/store-finder']);\n            });\n        }\n        else {\n            this.clearWatchGeolocation(new FindStores({\n                queryText: queryText,\n                searchConfig: searchConfig,\n                longitudeLatitude: longitudeLatitude,\n                countryIsoCode: countryIsoCode,\n            }));\n        }\n    }\n    /**\n     * View all stores\n     */\n    viewAllStores() {\n        this.clearWatchGeolocation(new ViewAllStores());\n    }\n    /**\n     * View all stores by id\n     * @param storeId store id\n     */\n    viewStoreById(storeId) {\n        this.clearWatchGeolocation(new FindStoreById({ storeId }));\n    }\n    clearWatchGeolocation(callbackAction) {\n        if (this.geolocationWatchId !== null) {\n            this.winRef.nativeWindow.navigator.geolocation.clearWatch(this.geolocationWatchId);\n            this.geolocationWatchId = null;\n        }\n        this.store.dispatch(callbackAction);\n    }\n};\nStoreFinderService.ctorParameters = () => [\n    { type: Store },\n    { type: WindowRef },\n    { type: GlobalMessageService },\n    { type: RoutingService }\n];\nStoreFinderService = __decorate([\n    Injectable()\n], StoreFinderService);\n\nlet StoreDataService = class StoreDataService {\n    constructor() {\n        this.weekDays = {\n            0: 'Sun',\n            1: 'Mon',\n            2: 'Tue',\n            3: 'Wed',\n            4: 'Thu',\n            5: 'Fri',\n            6: 'Sat',\n        };\n    }\n    /**\n     * Returns store latitude\n     * @param location store location\n     */\n    getStoreLatitude(location) {\n        return location.geoPoint.latitude;\n    }\n    /**\n     * Returns store longitude\n     * @param location store location\n     */\n    getStoreLongitude(location) {\n        return location.geoPoint.longitude;\n    }\n    /**\n     * Returns store closing time\n     * @param location store location\n     * @param date date to compare\n     */\n    getStoreClosingTime(location, date) {\n        const requestedDaySchedule = this.getSchedule(location, date);\n        if (requestedDaySchedule) {\n            if (requestedDaySchedule.closed && requestedDaySchedule.closed === true) {\n                return 'closed';\n            }\n            if (requestedDaySchedule.closingTime) {\n                return requestedDaySchedule.closingTime.formattedHour;\n            }\n        }\n    }\n    /**\n     * Returns store opening time\n     * @param location store location\n     * @param date date to compare\n     */\n    getStoreOpeningTime(location, date) {\n        const requestedDaySchedule = this.getSchedule(location, date);\n        if (requestedDaySchedule) {\n            if (requestedDaySchedule.closed && requestedDaySchedule.closed === true) {\n                return 'closed';\n            }\n            if (requestedDaySchedule.openingTime) {\n                return requestedDaySchedule.openingTime.formattedHour;\n            }\n        }\n    }\n    /**\n     * Extracts schedule from the given location for the given date\n     * @param location location\n     * @param date date\n     *\n     * @returns payload describing the store's schedule for the given day.\n     */\n    getSchedule(location, date) {\n        const weekday = this.weekDays[date.getDay()];\n        return location.openingHours.weekDayOpeningList.find(weekDayOpeningListItem => weekDayOpeningListItem.weekDay === weekday);\n    }\n};\nStoreDataService = __decorate([\n    Injectable()\n], StoreDataService);\n\nlet ExternalJsFileLoader = class ExternalJsFileLoader {\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * Loads a javascript from an external URL\n     * @param src URL for the script to be loaded\n     * @param params additional parameters to be attached to the given URL\n     * @param callback a function to be invoked after the script has been loaded\n     */\n    load(src, params, callback) {\n        const script = this.document.createElement('script');\n        script.type = 'text/javascript';\n        if (params) {\n            script.src = src + this.parseParams(params);\n        }\n        else {\n            script.src = src;\n        }\n        script.async = true;\n        script.defer = true;\n        if (callback) {\n            script.addEventListener('load', callback);\n        }\n        document.head.appendChild(script);\n    }\n    /**\n     * Parses the given object with parameters to a string \"param1=value1&param2=value2\"\n     * @param params object containing parameters\n     */\n    parseParams(params) {\n        let result = '';\n        const keysArray = Object.keys(params);\n        if (keysArray.length > 0) {\n            result =\n                '?' +\n                    keysArray\n                        .map(key => encodeURI(key) + '=' + encodeURI(params[key]))\n                        .join('&');\n        }\n        return result;\n    }\n};\nExternalJsFileLoader.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nExternalJsFileLoader = __decorate([\n    Injectable(),\n    __param(0, Inject(DOCUMENT))\n], ExternalJsFileLoader);\n\nlet GoogleMapRendererService = class GoogleMapRendererService {\n    constructor(config, externalJsFileLoader, storeDataService) {\n        this.config = config;\n        this.externalJsFileLoader = externalJsFileLoader;\n        this.storeDataService = storeDataService;\n        this.googleMap = null;\n    }\n    /**\n     * Renders google map on the given element and draws markers on it.\n     * If map already exists it will use an existing map otherwise it will create one\n     * @param mapElement HTML element inside of which the map will be displayed\n     * @param locations array containign geo data to be displayed on the map\n     * @param selectMarkerHandler function to handle whenever a marker on a map is clicked\n     */\n    renderMap(mapElement, locations, selectMarkerHandler) {\n        if (this.googleMap === null) {\n            this.externalJsFileLoader.load(this.config.googleMaps.apiUrl, { key: this.config.googleMaps.apiKey }, () => {\n                this.drawMap(mapElement, locations, selectMarkerHandler);\n            });\n        }\n        else {\n            this.drawMap(mapElement, locations, selectMarkerHandler);\n        }\n    }\n    /**\n     * Centers the map to the given point\n     * @param latitute latitude of the new center\n     * @param longitude longitude of the new center\n     */\n    centerMap(latitute, longitude) {\n        this.googleMap.panTo({ lat: latitute, lng: longitude });\n        this.googleMap.setZoom(this.config.googleMaps.selectedMarkerScale);\n    }\n    /**\n     * Defines and returns {@link google.maps.LatLng} representing a point where the map will be centered\n     * @param locations list of locations\n     */\n    defineMapCenter(locations) {\n        return new google.maps.LatLng(this.storeDataService.getStoreLatitude(locations[0]), this.storeDataService.getStoreLongitude(locations[0]));\n    }\n    /**\n     * Creates google map inside if the given HTML element centered to the given point\n     * @param mapElement {@link HTMLElement} inside of which the map will be created\n     * @param mapCenter {@link google.maps.LatLng} the point where the map will be centered\n     */\n    initMap(mapElement, mapCenter) {\n        const gestureOption = 'greedy';\n        const mapProp = {\n            center: mapCenter,\n            zoom: this.config.googleMaps.scale,\n            mapTypeId: google.maps.MapTypeId.ROADMAP,\n            gestureHandling: gestureOption,\n        };\n        this.googleMap = new google.maps.Map(mapElement, mapProp);\n    }\n    /**\n     * Erases the current map's markers and create a new one based on the given locations\n     * @param locations array of locations to be displayed on the map\n     * @param selectMarkerHandler function to handle whenever a marker on a map is clicked\n     */\n    createMarkers(locations, selectMarkerHandler) {\n        this.markers = [];\n        locations.forEach((element, index) => {\n            const marker = new google.maps.Marker({\n                position: new google.maps.LatLng(this.storeDataService.getStoreLatitude(element), this.storeDataService.getStoreLongitude(element)),\n                label: index + 1 + '',\n            });\n            this.markers.push(marker);\n            marker.setMap(this.googleMap);\n            marker.addListener('mouseover', function () {\n                marker.setAnimation(google.maps.Animation.BOUNCE);\n            });\n            marker.addListener('mouseout', function () {\n                marker.setAnimation(null);\n            });\n            if (selectMarkerHandler) {\n                marker.addListener('click', function () {\n                    selectMarkerHandler(index);\n                });\n            }\n        });\n    }\n    /**\n     * Initialize and draw the map\n     * @param mapElement {@link HTMLElement} inside of which the map will be drawn\n     * @param locations array of locations to be displayed on the map\n     * @param selectMarkerHandler function to handle whenever a marker on a map is clicked\n     */\n    drawMap(mapElement, locations, selectMarkerHandler) {\n        this.initMap(mapElement, this.defineMapCenter(locations));\n        this.createMarkers(locations, selectMarkerHandler);\n    }\n};\nGoogleMapRendererService.ctorParameters = () => [\n    { type: StoreFinderConfig },\n    { type: ExternalJsFileLoader },\n    { type: StoreDataService }\n];\nGoogleMapRendererService = __decorate([\n    Injectable()\n], GoogleMapRendererService);\n\nconst defaultStoreFinderConfig = {\n    googleMaps: {\n        apiUrl: 'https://maps.googleapis.com/maps/api/js',\n        apiKey: '',\n        scale: 5,\n        selectedMarkerScale: 17,\n    },\n};\n\nfunction getReducers$c() {\n    return {\n        findStores: loaderReducer(STORE_FINDER_DATA),\n        viewAllStores: loaderReducer(STORE_FINDER_DATA),\n    };\n}\nconst reducerToken$c = new InjectionToken('StoreFinderReducers');\nconst reducerProvider$c = {\n    provide: reducerToken$c,\n    useFactory: getReducers$c,\n};\nconst metaReducers$7 = [];\n\nlet FindStoresEffect = class FindStoresEffect {\n    constructor(actions$, storeFinderConnector) {\n        this.actions$ = actions$;\n        this.storeFinderConnector = storeFinderConnector;\n        this.findStores$ = this.actions$.pipe(ofType(FIND_STORES), map((action) => action.payload), mergeMap(payload => this.storeFinderConnector\n            .search(payload.queryText, payload.searchConfig, payload.longitudeLatitude)\n            .pipe(map(data => {\n            if (payload.countryIsoCode) {\n                data.stores = data.stores.filter(store => store.address.country.isocode === payload.countryIsoCode);\n            }\n            return new FindStoresSuccess(data);\n        }), catchError(error => of(new FindStoresFail(makeErrorSerializable(error)))))));\n        this.findStoreById$ = this.actions$.pipe(ofType(FIND_STORE_BY_ID), map((action) => action.payload), switchMap(payload => this.storeFinderConnector.get(payload.storeId).pipe(map(data => new FindStoreByIdSuccess(data)), catchError(error => of(new FindStoreByIdFail(makeErrorSerializable(error)))))));\n    }\n};\nFindStoresEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: StoreFinderConnector }\n];\n__decorate([\n    Effect()\n], FindStoresEffect.prototype, \"findStores$\", void 0);\n__decorate([\n    Effect()\n], FindStoresEffect.prototype, \"findStoreById$\", void 0);\nFindStoresEffect = __decorate([\n    Injectable()\n], FindStoresEffect);\n\nlet ViewAllStoresEffect = class ViewAllStoresEffect {\n    constructor(actions$, storeFinderConnector) {\n        this.actions$ = actions$;\n        this.storeFinderConnector = storeFinderConnector;\n        this.viewAllStores$ = this.actions$.pipe(ofType(VIEW_ALL_STORES), switchMap(() => {\n            return this.storeFinderConnector.getCounts().pipe(map(data => {\n                data.sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0));\n                return new ViewAllStoresSuccess(data);\n            }), catchError(error => of(new ViewAllStoresFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nViewAllStoresEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: StoreFinderConnector }\n];\n__decorate([\n    Effect()\n], ViewAllStoresEffect.prototype, \"viewAllStores$\", void 0);\nViewAllStoresEffect = __decorate([\n    Injectable()\n], ViewAllStoresEffect);\n\nconst effects$b = [FindStoresEffect, ViewAllStoresEffect];\n\nlet StoreFinderStoreModule = class StoreFinderStoreModule {\n};\nStoreFinderStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            HttpClientModule,\n            StoreModule.forFeature(STORE_FINDER_FEATURE, reducerToken$c),\n            EffectsModule.forFeature(effects$b),\n        ],\n        providers: [reducerProvider$c],\n    })\n], StoreFinderStoreModule);\n\nlet StoreFinderCoreModule = class StoreFinderCoreModule {\n};\nStoreFinderCoreModule = __decorate([\n    NgModule({\n        imports: [\n            ConfigModule.withConfig(defaultStoreFinderConfig),\n            StoreFinderStoreModule,\n        ],\n        providers: [\n            StoreFinderService,\n            StoreDataService,\n            GoogleMapRendererService,\n            ExternalJsFileLoader,\n            { provide: StoreFinderConfig, useExisting: Config },\n        ],\n    })\n], StoreFinderCoreModule);\n\nlet UserConnector = class UserConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    get(userId) {\n        return this.adapter.load(userId);\n    }\n    update(username, user) {\n        return this.adapter.update(username, user);\n    }\n    register(user) {\n        return this.adapter.register(user);\n    }\n    registerGuest(guid, password) {\n        return this.adapter.registerGuest(guid, password);\n    }\n    requestForgotPasswordEmail(userEmailAddress) {\n        return this.adapter.requestForgotPasswordEmail(userEmailAddress);\n    }\n    resetPassword(token, newPassword) {\n        return this.adapter.resetPassword(token, newPassword);\n    }\n    updateEmail(userId, currentPassword, newUserId) {\n        return this.adapter.updateEmail(userId, currentPassword, newUserId);\n    }\n    updatePassword(userId, oldPassword, newPassword) {\n        return this.adapter.updatePassword(userId, oldPassword, newPassword);\n    }\n    remove(userId) {\n        return this.adapter.remove(userId);\n    }\n    getTitles() {\n        return this.adapter.loadTitles();\n    }\n};\nUserConnector.ctorParameters = () => [\n    { type: UserAdapter }\n];\nUserConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserConnector_Factory() { return new UserConnector(ɵɵinject(UserAdapter)); }, token: UserConnector, providedIn: \"root\" });\nUserConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserConnector);\n\nlet UserConsentConnector = class UserConsentConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    loadConsents(userId) {\n        return this.adapter.loadConsents(userId);\n    }\n    giveConsent(userId, consentTemplateId, consentTemplateVersion) {\n        return this.adapter.giveConsent(userId, consentTemplateId, consentTemplateVersion);\n    }\n    withdrawConsent(userId, consentCode) {\n        return this.adapter.withdrawConsent(userId, consentCode);\n    }\n};\nUserConsentConnector.ctorParameters = () => [\n    { type: UserConsentAdapter }\n];\nUserConsentConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserConsentConnector_Factory() { return new UserConsentConnector(ɵɵinject(UserConsentAdapter)); }, token: UserConsentConnector, providedIn: \"root\" });\nUserConsentConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserConsentConnector);\n\nlet UserPaymentConnector = class UserPaymentConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    getAll(userId) {\n        return this.adapter.loadAll(userId);\n    }\n    delete(userId, paymentMethodID) {\n        return this.adapter.delete(userId, paymentMethodID);\n    }\n    setDefault(userId, paymentMethodID) {\n        return this.adapter.setDefault(userId, paymentMethodID);\n    }\n};\nUserPaymentConnector.ctorParameters = () => [\n    { type: UserPaymentAdapter }\n];\nUserPaymentConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserPaymentConnector_Factory() { return new UserPaymentConnector(ɵɵinject(UserPaymentAdapter)); }, token: UserPaymentConnector, providedIn: \"root\" });\nUserPaymentConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserPaymentConnector);\n\nlet UserOrderConnector = class UserOrderConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    get(userId, orderCode) {\n        return this.adapter.load(userId, orderCode);\n    }\n    getHistory(userId, pageSize, currentPage, sort) {\n        return this.adapter.loadHistory(userId, pageSize, currentPage, sort);\n    }\n    getConsignmentTracking(orderCode, consignmentCode, userId) {\n        return this.adapter.getConsignmentTracking(orderCode, consignmentCode, userId);\n    }\n    cancel(userId, orderCode, cancelRequestInput) {\n        return this.adapter.cancel(userId, orderCode, cancelRequestInput);\n    }\n    return(userId, returnRequestInput) {\n        return this.adapter.createReturnRequest(userId, returnRequestInput);\n    }\n    getReturnRequestDetail(userId, returnRequestCode) {\n        return this.adapter.loadReturnRequestDetail(userId, returnRequestCode);\n    }\n    getReturnRequestList(userId, pageSize, currentPage, sort) {\n        return this.adapter.loadReturnRequestList(userId, pageSize, currentPage, sort);\n    }\n    cancelReturnRequest(userId, returnRequestCode, returnRequestModification) {\n        return this.adapter.cancelReturnRequest(userId, returnRequestCode, returnRequestModification);\n    }\n};\nUserOrderConnector.ctorParameters = () => [\n    { type: UserOrderAdapter }\n];\nUserOrderConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserOrderConnector_Factory() { return new UserOrderConnector(ɵɵinject(UserOrderAdapter)); }, token: UserOrderConnector, providedIn: \"root\" });\nUserOrderConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserOrderConnector);\n\nlet CustomerCouponConnector = class CustomerCouponConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    getCustomerCoupons(userId, pageSize, currentPage, sort) {\n        return this.adapter.getCustomerCoupons(userId, pageSize, currentPage, sort);\n    }\n    turnOnNotification(userId, couponCode) {\n        return this.adapter.turnOnNotification(userId, couponCode);\n    }\n    turnOffNotification(userId, couponCode) {\n        return this.adapter.turnOffNotification(userId, couponCode);\n    }\n    claimCustomerCoupon(userId, couponCode) {\n        return this.adapter.claimCustomerCoupon(userId, couponCode);\n    }\n};\nCustomerCouponConnector.ctorParameters = () => [\n    { type: CustomerCouponAdapter }\n];\nCustomerCouponConnector.ɵprov = ɵɵdefineInjectable({ factory: function CustomerCouponConnector_Factory() { return new CustomerCouponConnector(ɵɵinject(CustomerCouponAdapter)); }, token: CustomerCouponConnector, providedIn: \"root\" });\nCustomerCouponConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CustomerCouponConnector);\n\nlet UserInterestsConnector = class UserInterestsConnector {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    getInterests(userId, pageSize, currentPage, sort, productCode, notificationType) {\n        return this.adapter.getInterests(userId, pageSize, currentPage, sort, productCode, notificationType);\n    }\n    removeInterest(userId, item) {\n        return this.adapter.removeInterest(userId, item);\n    }\n    addInterest(userId, productCode, notificationType) {\n        return this.adapter.addInterest(userId, productCode, notificationType);\n    }\n};\nUserInterestsConnector.ctorParameters = () => [\n    { type: UserInterestsAdapter }\n];\nUserInterestsConnector.ɵprov = ɵɵdefineInjectable({ factory: function UserInterestsConnector_Factory() { return new UserInterestsConnector(ɵɵinject(UserInterestsAdapter)); }, token: UserInterestsConnector, providedIn: \"root\" });\nUserInterestsConnector = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserInterestsConnector);\n\n/**\n * Unified facade for both anonymous and registered user consents.\n */\nlet ConsentService = class ConsentService {\n    constructor(anonymousConsentsService, userConsentService) {\n        this.anonymousConsentsService = anonymousConsentsService;\n        this.userConsentService = userConsentService;\n    }\n    /**\n     * Returns either anonymous consent or registered consent as they are emmited.\n     * @param templateCode for which to return either anonymous or registered consent.\n     */\n    getConsent(templateCode) {\n        return merge(this.userConsentService.getConsent(templateCode), this.anonymousConsentsService.getConsent(templateCode));\n    }\n    /**\n     * Checks if the `templateId`'s template has a given consent.\n     * The method returns `false` if the consent doesn't exist or if it's withdrawn. Otherwise, `true` is returned.\n     *\n     * @param templateId of a template which's consent should be checked\n     */\n    checkConsentGivenByTemplateId(templateId) {\n        return this.getConsent(templateId).pipe(map(consent => {\n            if (!consent) {\n                return false;\n            }\n            return this.isAnonymousConsentType(consent)\n                ? this.anonymousConsentsService.isConsentGiven(consent)\n                : this.userConsentService.isConsentGiven(consent);\n        }), distinctUntilChanged());\n    }\n    /**\n     * Checks if the `templateId`'s template has a withdrawn consent.\n     * The method returns `true` if the consent doesn't exist or if it's withdrawn. Otherwise, `false` is returned.\n     *\n     * @param templateId of a template which's consent should be checked\n     */\n    checkConsentWithdrawnByTemplateId(templateId) {\n        return this.getConsent(templateId).pipe(map(consent => {\n            if (!consent) {\n                return true;\n            }\n            return this.isAnonymousConsentType(consent)\n                ? this.anonymousConsentsService.isConsentWithdrawn(consent)\n                : this.userConsentService.isConsentWithdrawn(consent);\n        }), distinctUntilChanged());\n    }\n    /**\n     *\n     * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentGiven(consent)` or `this.userConsentService.isConsentGiven`\n     *\n     * @param consent a consent to check\n     */\n    isConsentGiven(consent) {\n        return this.isAnonymousConsentType(consent)\n            ? this.anonymousConsentsService.isConsentGiven(consent)\n            : this.userConsentService.isConsentGiven(consent);\n    }\n    /**\n     *\n     * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentWithdrawn(consent)` or `this.userConsentService.isConsentWithdrawn`\n     *\n     * @param consent a consent to check\n     */\n    isConsentWithdrawn(consent) {\n        return this.isAnonymousConsentType(consent)\n            ? this.anonymousConsentsService.isConsentWithdrawn(consent)\n            : this.userConsentService.isConsentWithdrawn(consent);\n    }\n    /**\n     * Returns `true` if the provided consent is of type `AnonymousConsent`. Otherwise, `false` is returned.\n     */\n    isAnonymousConsentType(consent) {\n        if (!consent) {\n            return false;\n        }\n        return consent.templateCode !== undefined;\n    }\n    /**\n     * Returns `true` if the provided consent is of type `Consent`. Otherwise, `false` is returned.\n     */\n    isConsentType(consent) {\n        if (!consent) {\n            return false;\n        }\n        return consent.code !== undefined;\n    }\n};\nConsentService.ctorParameters = () => [\n    { type: AnonymousConsentsService },\n    { type: UserConsentService }\n];\nConsentService.ɵprov = ɵɵdefineInjectable({ factory: function ConsentService_Factory() { return new ConsentService(ɵɵinject(AnonymousConsentsService), ɵɵinject(UserConsentService)); }, token: ConsentService, providedIn: \"root\" });\nConsentService = __decorate([\n    Injectable({ providedIn: 'root' })\n], ConsentService);\n\nlet UserAddressService = class UserAddressService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Retrieves user's addresses\n     */\n    loadAddresses() {\n        this.withUserId(userId => this.store.dispatch(new LoadUserAddresses(userId)));\n    }\n    /**\n     * Adds user address\n     * @param address a user address\n     */\n    addUserAddress(address) {\n        this.withUserId(userId => this.store.dispatch(new AddUserAddress({\n            userId,\n            address,\n        })));\n    }\n    /**\n     * Sets user address as default\n     * @param addressId a user address ID\n     */\n    setAddressAsDefault(addressId) {\n        this.withUserId(userId => this.store.dispatch(new UpdateUserAddress({\n            userId,\n            addressId,\n            address: { defaultAddress: true },\n        })));\n    }\n    /**\n     * Updates existing user address\n     * @param addressId a user address ID\n     * @param address a user address\n     */\n    updateUserAddress(addressId, address) {\n        this.withUserId(userId => this.store.dispatch(new UpdateUserAddress({\n            userId,\n            addressId,\n            address,\n        })));\n    }\n    /**\n     * Deletes existing user address\n     * @param addressId a user address ID\n     */\n    deleteUserAddress(addressId) {\n        this.withUserId(userId => this.store.dispatch(new DeleteUserAddress({\n            userId,\n            addressId,\n        })));\n    }\n    /**\n     * Returns addresses\n     */\n    getAddresses() {\n        return this.store.pipe(select(getAddresses));\n    }\n    /**\n     * Returns a loading flag for addresses\n     */\n    getAddressesLoading() {\n        return this.store.pipe(select(getAddressesLoading));\n    }\n    getAddressesLoadedSuccess() {\n        return this.store.pipe(select(getAddressesLoadedSuccess));\n    }\n    /**\n     * Retrieves delivery countries\n     */\n    loadDeliveryCountries() {\n        this.store.dispatch(new LoadDeliveryCountries());\n    }\n    /**\n     * Returns all delivery countries\n     */\n    getDeliveryCountries() {\n        return this.store.pipe(select(getAllDeliveryCountries));\n    }\n    /**\n     * Returns a country based on the provided `isocode`\n     * @param isocode an isocode for a country\n     */\n    getCountry(isocode) {\n        return this.store.pipe(select(countrySelectorFactory(isocode)));\n    }\n    /**\n     * Retrieves regions for specified country by `countryIsoCode`\n     * @param countryIsoCode\n     */\n    loadRegions(countryIsoCode) {\n        this.store.dispatch(new LoadRegions(countryIsoCode));\n    }\n    /**\n     * Clear regions in store - useful when changing country\n     */\n    clearRegions() {\n        this.store.dispatch(new ClearRegions());\n    }\n    /**\n     * Returns all regions\n     */\n    getRegions(countryIsoCode) {\n        return this.store.pipe(select(getRegionsDataAndLoading), map(({ regions, country, loading, loaded }) => {\n            if (!countryIsoCode && (loading || loaded)) {\n                this.clearRegions();\n                return [];\n            }\n            else if (loading && !loaded) {\n                // don't interrupt loading\n                return [];\n            }\n            else if (!loading && countryIsoCode !== country && countryIsoCode) {\n                // country changed - clear store and load new regions\n                if (country) {\n                    this.clearRegions();\n                }\n                this.loadRegions(countryIsoCode);\n                return [];\n            }\n            return regions;\n        }));\n    }\n    /**\n     * Utility method to distinquish pre / post 1.3.0 in a convenient way.\n     *\n     */\n    withUserId(callback) {\n        if (this.authService) {\n            this.authService\n                .getOccUserId()\n                .pipe(take(1))\n                .subscribe(userId => callback(userId));\n        }\n        else {\n            // TODO(issue:#5628) Deprecated since 1.3.0\n            callback(OCC_USER_ID_CURRENT);\n        }\n    }\n};\nUserAddressService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nUserAddressService.ɵprov = ɵɵdefineInjectable({ factory: function UserAddressService_Factory() { return new UserAddressService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserAddressService, providedIn: \"root\" });\nUserAddressService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserAddressService);\n\nlet UserOrderService = class UserOrderService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Returns an order's detail\n     */\n    getOrderDetails() {\n        return this.store.pipe(select(getOrderDetails));\n    }\n    /**\n     * Retrieves order's details\n     *\n     * @param orderCode an order code\n     */\n    loadOrderDetails(orderCode) {\n        this.withUserId(userId => this.store.dispatch(new LoadOrderDetails({\n            userId,\n            orderCode,\n        })));\n    }\n    /**\n     * Clears order's details\n     */\n    clearOrderDetails() {\n        this.store.dispatch(new ClearOrderDetails());\n    }\n    /**\n     * Returns order history list\n     */\n    getOrderHistoryList(pageSize) {\n        return this.store.pipe(select(getOrdersState), tap(orderListState => {\n            const attemptedLoad = orderListState.loading ||\n                orderListState.success ||\n                orderListState.error;\n            if (!attemptedLoad) {\n                this.loadOrderList(pageSize);\n            }\n        }), map(orderListState => orderListState.value));\n    }\n    /**\n     * Returns a loaded flag for order history list\n     */\n    getOrderHistoryListLoaded() {\n        return this.store.pipe(select(getOrdersLoaded));\n    }\n    /**\n     * Retrieves an order list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadOrderList(pageSize, currentPage, sort) {\n        this.withUserId(userId => this.store.dispatch(new LoadUserOrders({\n            userId,\n            pageSize,\n            currentPage,\n            sort,\n        })));\n    }\n    /**\n     * Cleaning order list\n     */\n    clearOrderList() {\n        this.store.dispatch(new ClearUserOrders());\n    }\n    /**\n     *  Returns a consignment tracking detail\n     */\n    getConsignmentTracking() {\n        return this.store.pipe(select(getConsignmentTracking));\n    }\n    /**\n     * Retrieves consignment tracking details\n     * @param orderCode an order code\n     * @param consignmentCode a consignment code\n     */\n    loadConsignmentTracking(orderCode, consignmentCode) {\n        this.withUserId(userId => this.store.dispatch(new LoadConsignmentTracking({\n            userId,\n            orderCode,\n            consignmentCode,\n        })));\n    }\n    /**\n     * Cleaning consignment tracking\n     */\n    clearConsignmentTracking() {\n        this.store.dispatch(new ClearConsignmentTracking());\n    }\n    /*\n     * Cancel an order\n     */\n    cancelOrder(orderCode, cancelRequestInput) {\n        this.withUserId(userId => {\n            this.store.dispatch(new CancelOrder({\n                userId,\n                orderCode,\n                cancelRequestInput,\n            }));\n        });\n    }\n    /**\n     * Returns the cancel order loading flag\n     */\n    getCancelOrderLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(CANCEL_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Returns the cancel order success flag\n     */\n    getCancelOrderSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(CANCEL_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Resets the cancel order process flags\n     */\n    resetCancelOrderProcessState() {\n        return this.store.dispatch(new ResetCancelOrderProcess());\n    }\n    /**\n     * Utility method to distinquish pre / post 1.3.0 in a convenient way.\n     *\n     */\n    withUserId(callback) {\n        if (this.authService) {\n            this.authService\n                .getOccUserId()\n                .pipe(take(1))\n                .subscribe(userId => callback(userId));\n        }\n        else {\n            // TODO(issue:#5628) Deprecated since 1.3.0\n            callback(OCC_USER_ID_CURRENT);\n        }\n    }\n};\nUserOrderService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nUserOrderService.ɵprov = ɵɵdefineInjectable({ factory: function UserOrderService_Factory() { return new UserOrderService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserOrderService, providedIn: \"root\" });\nUserOrderService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserOrderService);\n\nlet CustomerCouponService = class CustomerCouponService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Retrieves customer's coupons\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadCustomerCoupons(pageSize, currentPage, sort) {\n        this.store.dispatch(new LoadCustomerCoupons({\n            userId: OCC_USER_ID_CURRENT,\n            pageSize: pageSize,\n            currentPage: currentPage,\n            sort: sort,\n        }));\n    }\n    /**\n     * Returns customer coupon search result\n     * @param pageSize page size\n     */\n    getCustomerCoupons(pageSize) {\n        return this.store.pipe(select(getCustomerCouponsState), tap(customerCouponsState => {\n            const attemptedLoad = customerCouponsState.loading ||\n                customerCouponsState.success ||\n                customerCouponsState.error;\n            if (!attemptedLoad) {\n                this.loadCustomerCoupons(pageSize);\n            }\n        }), map(customerCouponsState => customerCouponsState.value));\n    }\n    /**\n     * Returns a loaded flag for customer coupons\n     */\n    getCustomerCouponsLoaded() {\n        return this.store.pipe(select(getCustomerCouponsLoaded));\n    }\n    /**\n     * Returns a loading flag for customer coupons\n     */\n    getCustomerCouponsLoading() {\n        return this.store.pipe(select(getCustomerCouponsLoading));\n    }\n    /**\n     * Subscribe a CustomerCoupon Notification\n     * @param couponCode a customer coupon code\n     */\n    subscribeCustomerCoupon(couponCode) {\n        this.store.dispatch(new SubscribeCustomerCoupon({\n            userId: OCC_USER_ID_CURRENT,\n            couponCode: couponCode,\n        }));\n    }\n    /**\n     * Returns the subscribe customer coupon notification process loading flag\n     */\n    getSubscribeCustomerCouponResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the subscribe customer coupon notification process success flag\n     */\n    getSubscribeCustomerCouponResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the subscribe customer coupon notification process error flag\n     */\n    getSubscribeCustomerCouponResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Unsubscribe a CustomerCoupon Notification\n     * @param couponCode a customer coupon code\n     */\n    unsubscribeCustomerCoupon(couponCode) {\n        this.store.dispatch(new UnsubscribeCustomerCoupon({\n            userId: OCC_USER_ID_CURRENT,\n            couponCode: couponCode,\n        }));\n    }\n    /**\n     * Returns the unsubscribe customer coupon notification process loading flag\n     */\n    getUnsubscribeCustomerCouponResultLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the unsubscribe customer coupon notification process success flag\n     */\n    getUnsubscribeCustomerCouponResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the unsubscribe customer coupon notification process error flag\n     */\n    getUnsubscribeCustomerCouponResultError() {\n        return this.store.pipe(select(getProcessErrorFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Claim a CustomerCoupon\n     * @param couponCode a customer coupon code\n     */\n    claimCustomerCoupon(couponCode) {\n        this.store.dispatch(new ClaimCustomerCoupon({\n            userId: OCC_USER_ID_CURRENT,\n            couponCode: couponCode,\n        }));\n    }\n    /**\n     * Returns the claim customer coupon notification process success flag\n     */\n    getClaimCustomerCouponResultSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(CLAIM_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n};\nCustomerCouponService.ctorParameters = () => [\n    { type: Store }\n];\nCustomerCouponService.ɵprov = ɵɵdefineInjectable({ factory: function CustomerCouponService_Factory() { return new CustomerCouponService(ɵɵinject(Store)); }, token: CustomerCouponService, providedIn: \"root\" });\nCustomerCouponService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], CustomerCouponService);\n\nlet UserPaymentService = class UserPaymentService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Loads all user's payment methods.\n     */\n    loadPaymentMethods() {\n        this.withUserId(userId => this.store.dispatch(new LoadUserPaymentMethods(userId)));\n    }\n    /**\n     * Returns all user's payment methods\n     */\n    getPaymentMethods() {\n        return this.store.pipe(select(getPaymentMethods));\n    }\n    /**\n     * Returns a loading flag for payment methods\n     */\n    getPaymentMethodsLoading() {\n        return this.store.pipe(select(getPaymentMethodsLoading));\n    }\n    getPaymentMethodsLoadedSuccess() {\n        return this.store.pipe(select(getPaymentMethodsLoadedSuccess));\n    }\n    /**\n     * Sets the payment as a default one\n     * @param paymentMethodId a payment method ID\n     */\n    setPaymentMethodAsDefault(paymentMethodId) {\n        this.withUserId(userId => this.store.dispatch(new SetDefaultUserPaymentMethod({\n            userId,\n            paymentMethodId,\n        })));\n    }\n    /**\n     * Deletes the payment method\n     *\n     * @param paymentMethodId a payment method ID\n     */\n    deletePaymentMethod(paymentMethodId) {\n        this.withUserId(userId => this.store.dispatch(new DeleteUserPaymentMethod({\n            userId,\n            paymentMethodId,\n        })));\n    }\n    /**\n     * Returns all billing countries\n     */\n    getAllBillingCountries() {\n        return this.store.pipe(select(getAllBillingCountries));\n    }\n    /**\n     * Retrieves billing countries\n     */\n    loadBillingCountries() {\n        this.store.dispatch(new LoadBillingCountries());\n    }\n    /**\n     * Utility method to distinquish pre / post 1.3.0 in a convenient way.\n     *\n     */\n    withUserId(callback) {\n        if (this.authService) {\n            this.authService\n                .getOccUserId()\n                .pipe(take(1))\n                .subscribe(userId => callback(userId));\n        }\n        else {\n            // TODO(issue:#5628) Deprecated since 1.3.0\n            callback(OCC_USER_ID_CURRENT);\n        }\n    }\n};\nUserPaymentService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nUserPaymentService.ɵprov = ɵɵdefineInjectable({ factory: function UserPaymentService_Factory() { return new UserPaymentService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserPaymentService, providedIn: \"root\" });\nUserPaymentService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserPaymentService);\n\nlet OrderReturnRequestService = class OrderReturnRequestService {\n    constructor(store, authService) {\n        this.store = store;\n        this.authService = authService;\n    }\n    /**\n     * Create order return request\n     * @param orderCode an order code\n     * @param returnRequestInput order return request entry input\n     */\n    createOrderReturnRequest(returnRequestInput) {\n        this.withUserId(userId => {\n            this.store.dispatch(new CreateOrderReturnRequest({\n                userId,\n                returnRequestInput,\n            }));\n        });\n    }\n    /**\n     * Return an order return request\n     */\n    getOrderReturnRequest() {\n        return this.store.pipe(select(getOrderReturnRequest));\n    }\n    /**\n     * Gets order return request list\n     */\n    getOrderReturnRequestList(pageSize) {\n        return this.store.pipe(select(getOrderReturnRequestListState), tap(returnListState => {\n            const attemptedLoad = returnListState.loading ||\n                returnListState.success ||\n                returnListState.error;\n            if (!attemptedLoad) {\n                this.loadOrderReturnRequestList(pageSize);\n            }\n        }), map(returnListState => returnListState.value));\n    }\n    /**\n     * Loads order return request detail\n     * @param returnRequestCode\n     */\n    loadOrderReturnRequestDetail(returnRequestCode) {\n        this.withUserId(userId => {\n            this.store.dispatch(new LoadOrderReturnRequest({\n                userId: userId,\n                returnRequestCode,\n            }));\n        });\n    }\n    /**\n     * Loads order return request list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadOrderReturnRequestList(pageSize, currentPage, sort) {\n        this.withUserId(userId => {\n            this.store.dispatch(new LoadOrderReturnRequestList({\n                userId: userId,\n                pageSize: pageSize,\n                currentPage: currentPage,\n                sort: sort,\n            }));\n        });\n    }\n    /**\n     * Cleaning order return request list\n     */\n    clearOrderReturnRequestList() {\n        this.store.dispatch(new ClearOrderReturnRequestList());\n    }\n    /**\n     * Get the order return request loading flag\n     */\n    getReturnRequestLoading() {\n        return this.store.pipe(select(getOrderReturnRequestLoading));\n    }\n    /**\n     * Get the order return request success flag\n     */\n    getReturnRequestSuccess() {\n        return this.store.pipe(select(getOrderReturnRequestSuccess));\n    }\n    /**\n     * Cleaning order return request details\n     */\n    clearOrderReturnRequestDetail() {\n        this.store.dispatch(new ClearOrderReturnRequest());\n    }\n    /*\n     * Cancel order return request\n     */\n    cancelOrderReturnRequest(returnRequestCode, returnRequestModification) {\n        this.withUserId(userId => {\n            this.store.dispatch(new CancelOrderReturnRequest({\n                userId,\n                returnRequestCode,\n                returnRequestModification,\n            }));\n        });\n    }\n    /**\n     * Returns the cancel return request loading flag\n     */\n    getCancelReturnRequestLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(CANCEL_RETURN_PROCESS_ID)));\n    }\n    /**\n     * Returns the cancel return request success flag\n     */\n    getCancelReturnRequestSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(CANCEL_RETURN_PROCESS_ID)));\n    }\n    /**\n     * Resets the cancel return request process flags\n     */\n    resetCancelReturnRequestProcessState() {\n        return this.store.dispatch(new ResetCancelReturnProcess());\n    }\n    /*\n     * Utility method to distinquish pre / post 1.3.0 in a convenient way.\n     *\n     */\n    withUserId(callback) {\n        if (this.authService) {\n            this.authService\n                .getOccUserId()\n                .pipe(take(1))\n                .subscribe(userId => callback(userId));\n        }\n        else {\n            // TODO(issue:#5628) Deprecated since 1.3.0\n            callback(OCC_USER_ID_CURRENT);\n        }\n    }\n};\nOrderReturnRequestService.ctorParameters = () => [\n    { type: Store },\n    { type: AuthService }\n];\nOrderReturnRequestService.ɵprov = ɵɵdefineInjectable({ factory: function OrderReturnRequestService_Factory() { return new OrderReturnRequestService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: OrderReturnRequestService, providedIn: \"root\" });\nOrderReturnRequestService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], OrderReturnRequestService);\n\nlet UserNotificationPreferenceService = class UserNotificationPreferenceService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Returns all notification preferences.\n     */\n    getPreferences() {\n        return this.store.pipe(select(getPreferences));\n    }\n    /**\n     * Returns all enabled notification preferences.\n     */\n    getEnabledPreferences() {\n        return this.store.pipe(select(getEnabledPreferences));\n    }\n    /**\n     * Loads all notification preferences.\n     */\n    loadPreferences() {\n        this.store.dispatch(new LoadNotificationPreferences(OCC_USER_ID_CURRENT));\n    }\n    /**\n     * Clear all notification preferences.\n     */\n    clearPreferences() {\n        this.store.dispatch(new ClearNotificationPreferences());\n    }\n    /**\n     * Returns a loading flag for notification preferences.\n     */\n    getPreferencesLoading() {\n        return this.store.pipe(select(getPreferencesLoading));\n    }\n    /**\n     * Updating notification preferences.\n     * @param preferences a preference list\n     */\n    updatePreferences(preferences) {\n        this.store.dispatch(new UpdateNotificationPreferences({\n            userId: OCC_USER_ID_CURRENT,\n            preferences: preferences,\n        }));\n    }\n    /**\n     * Returns a loading flag for updating preferences.\n     */\n    getUpdatePreferencesResultLoading() {\n        return this.store.select(getProcessLoadingFactory(UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID));\n    }\n    /**\n     * Resets the update notification preferences process state. The state needs to be\n     * reset after the process concludes, regardless if it's a success or an error.\n     */\n    resetNotificationPreferences() {\n        this.store.dispatch(new ResetNotificationPreferences());\n    }\n};\nUserNotificationPreferenceService.ctorParameters = () => [\n    { type: Store }\n];\nUserNotificationPreferenceService.ɵprov = ɵɵdefineInjectable({ factory: function UserNotificationPreferenceService_Factory() { return new UserNotificationPreferenceService(ɵɵinject(Store)); }, token: UserNotificationPreferenceService, providedIn: \"root\" });\nUserNotificationPreferenceService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserNotificationPreferenceService);\n\nlet UserInterestsService = class UserInterestsService {\n    constructor(store) {\n        this.store = store;\n    }\n    /**\n     * Retrieves an product interest list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadProductInterests(pageSize, currentPage, sort, productCode, notificationType) {\n        this.store.dispatch(new LoadProductInterests({\n            userId: OCC_USER_ID_CURRENT,\n            pageSize: pageSize,\n            currentPage: currentPage,\n            sort: sort,\n            productCode: productCode,\n            notificationType: notificationType,\n        }));\n    }\n    /**\n     * Returns product interests\n     */\n    getProductInterests() {\n        return this.store.pipe(select(getInterests));\n    }\n    /**\n     * Returns product interests\n     * @param pageSize the page size\n     */\n    getAndLoadProductInterests(pageSize) {\n        return this.store.pipe(select(getInterestsState), tap(interestListState => {\n            const attemptedLoad = interestListState.loading ||\n                interestListState.success ||\n                interestListState.error;\n            if (!attemptedLoad) {\n                this.loadProductInterests(pageSize);\n            }\n        }), map(interestListState => interestListState.value));\n    }\n    /**\n     * Returns a loading flag for product interests\n     */\n    getProdutInterestsLoading() {\n        return this.store.pipe(select(getInterestsLoading));\n    }\n    /**\n     * Removes a ProductInterestRelation\n     * @param item product interest relation item\n     * @param singleDelete flag to delete only one interest\n     */\n    removeProdutInterest(item, singleDelete) {\n        this.store.dispatch(new RemoveProductInterest({\n            userId: OCC_USER_ID_CURRENT,\n            item: item,\n            singleDelete: singleDelete,\n        }));\n    }\n    /**\n     * Returns a loading flag for removing product interests.\n     */\n    getRemoveProdutInterestLoading() {\n        return this.store.pipe(select(getProcessLoadingFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));\n    }\n    /**\n     * Returns a success flag for removing a product interests.\n     */\n    getRemoveProdutInterestSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));\n    }\n    /**\n     * Add a new product interest.\n     *\n     * @param productCode the product code\n     * @param notificationType the notification type\n     */\n    addProductInterest(productCode, notificationType) {\n        this.store.dispatch(new AddProductInterest({\n            userId: OCC_USER_ID_CURRENT,\n            productCode: productCode,\n            notificationType: notificationType,\n        }));\n    }\n    /**\n     * Returns a success flag for adding a product interest.\n     */\n    getAddProductInterestSuccess() {\n        return this.store.pipe(select(getProcessSuccessFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));\n    }\n    /**\n     * Returns a error flag for adding a product interest.\n     */\n    getAddProductInterestError() {\n        return this.store.pipe(select(getProcessErrorFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));\n    }\n    /**\n     * Reset product interest adding state.\n     */\n    resetAddInterestState() {\n        this.store.dispatch(new ResetAddInterestState());\n    }\n    /**\n     * Reset product interest removing state.\n     */\n    resetRemoveInterestState() {\n        this.store.dispatch(new ResetRemoveInterestState());\n    }\n    /**\n     * Clears product interests\n     */\n    clearProductInterests() {\n        this.store.dispatch(new ClearProductInterests());\n    }\n};\nUserInterestsService.ctorParameters = () => [\n    { type: Store }\n];\nUserInterestsService.ɵprov = ɵɵdefineInjectable({ factory: function UserInterestsService_Factory() { return new UserInterestsService(ɵɵinject(Store)); }, token: UserInterestsService, providedIn: \"root\" });\nUserInterestsService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], UserInterestsService);\n\nconst initialState$l = {\n    entities: {},\n};\nfunction reducer$l(state = initialState$l, action) {\n    switch (action.type) {\n        case LOAD_BILLING_COUNTRIES_SUCCESS: {\n            const billingCountries = action.payload;\n            const entities = billingCountries.reduce((countryEntities, name) => {\n                return Object.assign(Object.assign({}, countryEntities), { [name.isocode]: name });\n            }, Object.assign({}, state.entities));\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n        case CLEAR_USER_MISCS_DATA: {\n            return initialState$l;\n        }\n    }\n    return state;\n}\n\nconst initialState$m = {};\nfunction reducer$m(state = initialState$m, action) {\n    switch (action.type) {\n        case LOAD_CONSIGNMENT_TRACKING_SUCCESS: {\n            const tracking = action.payload;\n            return {\n                tracking,\n            };\n        }\n        case CLEAR_CONSIGNMENT_TRACKING: {\n            return initialState$m;\n        }\n    }\n    return state;\n}\n\nconst initialState$n = {\n    entities: {},\n};\nfunction reducer$n(state = initialState$n, action) {\n    switch (action.type) {\n        case LOAD_DELIVERY_COUNTRIES_SUCCESS: {\n            const deliveryCountries = action.payload;\n            const entities = deliveryCountries.reduce((countryEntities, country) => {\n                return Object.assign(Object.assign({}, countryEntities), { [country.isocode]: country });\n            }, Object.assign({}, state.entities));\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n        case CLEAR_USER_MISCS_DATA: {\n            return initialState$n;\n        }\n    }\n    return state;\n}\n\nconst initialState$o = [];\nfunction reducer$o(state = initialState$o, action) {\n    switch (action.type) {\n        case LOAD_NOTIFICATION_PREFERENCES_FAIL: {\n            return initialState$o;\n        }\n        case LOAD_NOTIFICATION_PREFERENCES_SUCCESS:\n        case UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: {\n            return action.payload ? action.payload : initialState$o;\n        }\n    }\n    return state;\n}\n\nconst initialState$p = {};\nfunction reducer$p(state = initialState$p, action) {\n    switch (action.type) {\n        case LOAD_ORDER_DETAILS_SUCCESS: {\n            const order = action.payload;\n            return order;\n        }\n    }\n    return state;\n}\n\nconst initialState$q = [];\nfunction reducer$q(state = initialState$q, action) {\n    switch (action.type) {\n        case LOAD_USER_PAYMENT_METHODS_SUCCESS: {\n            return action.payload ? action.payload : initialState$q;\n        }\n        case LOAD_USER_PAYMENT_METHODS_FAIL: {\n            return initialState$q;\n        }\n    }\n    return state;\n}\n\nconst initialState$r = {\n    entities: [],\n    country: null,\n};\nfunction reducer$r(state = initialState$r, action) {\n    switch (action.type) {\n        case LOAD_REGIONS_SUCCESS: {\n            const entities = action.payload.entities;\n            const country = action.payload.country;\n            if (entities || country) {\n                return Object.assign(Object.assign({}, state), { entities,\n                    country });\n            }\n            return initialState$r;\n        }\n    }\n    return state;\n}\n\nconst initialState$s = false;\nfunction reducer$s(state = initialState$s, action) {\n    switch (action.type) {\n        case RESET_PASSWORD_SUCCESS: {\n            return true;\n        }\n    }\n    return state;\n}\n\nconst initialState$t = {\n    entities: {},\n};\nfunction reducer$t(state = initialState$t, action) {\n    switch (action.type) {\n        case LOAD_TITLES_SUCCESS: {\n            const titles = action.payload;\n            const entities = titles.reduce((titleEntities, name) => {\n                return Object.assign(Object.assign({}, titleEntities), { [name.code]: name });\n            }, Object.assign({}, state.entities));\n            return Object.assign(Object.assign({}, state), { entities });\n        }\n        case CLEAR_USER_MISCS_DATA: {\n            return initialState$t;\n        }\n    }\n    return state;\n}\n\nconst initialState$u = [];\nfunction reducer$u(state = initialState$u, action) {\n    switch (action.type) {\n        case LOAD_USER_ADDRESSES_FAIL: {\n            return initialState$u;\n        }\n        case LOAD_USER_ADDRESSES_SUCCESS: {\n            return action.payload ? action.payload : initialState$u;\n        }\n    }\n    return state;\n}\n\nconst initialState$v = [];\nfunction reducer$v(state = initialState$v, action) {\n    switch (action.type) {\n        case LOAD_USER_CONSENTS_SUCCESS: {\n            const consents = action.payload;\n            return consents ? consents : initialState$v;\n        }\n        case GIVE_USER_CONSENT_SUCCESS: {\n            const updatedConsentTemplate = action.consentTemplate;\n            return state.map(consentTemplate => consentTemplate.id === updatedConsentTemplate.id\n                ? updatedConsentTemplate\n                : consentTemplate);\n        }\n    }\n    return state;\n}\n\nconst initialState$w = {};\nfunction reducer$w(state = initialState$w, action) {\n    switch (action.type) {\n        case LOAD_USER_DETAILS_SUCCESS: {\n            return action.payload;\n        }\n        case UPDATE_USER_DETAILS_SUCCESS: {\n            const updatedDetails = Object.assign(Object.assign({}, state), action.userUpdates);\n            return Object.assign(Object.assign({}, updatedDetails), { name: `${updatedDetails.firstName} ${updatedDetails.lastName}` });\n        }\n    }\n    return state;\n}\n\nconst initialState$x = {\n    orders: [],\n    pagination: {},\n    sorts: [],\n};\nfunction reducer$x(state = initialState$x, action) {\n    switch (action.type) {\n        case LOAD_USER_ORDERS_SUCCESS: {\n            return action.payload ? action.payload : initialState$x;\n        }\n        case LOAD_USER_ORDERS_FAIL: {\n            return initialState$x;\n        }\n    }\n    return state;\n}\n\nconst initialState$y = {\n    coupons: [],\n    sorts: [],\n    pagination: {},\n};\nfunction reducer$y(state = initialState$y, action) {\n    switch (action.type) {\n        case LOAD_CUSTOMER_COUPONS_SUCCESS: {\n            return action.payload;\n        }\n        case SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: {\n            const updatedCustomerCoupon = action.payload.coupon;\n            const customerCoupons = new Array(state.coupons.length);\n            state.coupons.forEach((customerCoupon, index) => customerCoupon.couponId === updatedCustomerCoupon.couponId\n                ? (customerCoupons[index] = updatedCustomerCoupon)\n                : (customerCoupons[index] = customerCoupon));\n            return Object.assign(Object.assign({}, state), { coupons: customerCoupons });\n        }\n        case UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: {\n            const updatedCouponCode = action.payload;\n            const customerCoupons = new Array(state.coupons.length);\n            state.coupons.forEach((customerCoupon, index) => customerCoupon.couponId === updatedCouponCode\n                ? (customerCoupons[index] = Object.assign(Object.assign({}, customerCoupon), { notificationOn: false }))\n                : (customerCoupons[index] = customerCoupon));\n            return Object.assign(Object.assign({}, state), { coupons: customerCoupons });\n        }\n    }\n    return state;\n}\n\nconst initialState$z = {\n    results: [],\n    pagination: {},\n    sorts: [],\n};\nfunction reducer$z(state = initialState$z, action) {\n    switch (action.type) {\n        case LOAD_PRODUCT_INTERESTS_SUCCESS: {\n            return action.payload ? action.payload : initialState$z;\n        }\n        case LOAD_PRODUCT_INTERESTS_FAIL: {\n            return initialState$z;\n        }\n    }\n    return state;\n}\n\nconst initialState$A = {\n    returnRequests: [],\n    pagination: {},\n    sorts: [],\n};\nfunction reducer$A(state = initialState$A, action) {\n    switch (action.type) {\n        case LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: {\n            return action.payload ? action.payload : initialState$A;\n        }\n    }\n    return state;\n}\n\nfunction getReducers$d() {\n    return {\n        account: combineReducers({\n            details: reducer$w,\n        }),\n        addresses: loaderReducer(USER_ADDRESSES, reducer$u),\n        billingCountries: reducer$l,\n        consents: loaderReducer(USER_CONSENTS, reducer$v),\n        payments: loaderReducer(USER_PAYMENT_METHODS, reducer$q),\n        orders: loaderReducer(USER_ORDERS, reducer$x),\n        order: loaderReducer(USER_ORDER_DETAILS, reducer$p),\n        orderReturn: loaderReducer(USER_RETURN_REQUEST_DETAILS),\n        orderReturnList: loaderReducer(USER_RETURN_REQUESTS, reducer$A),\n        countries: reducer$n,\n        titles: reducer$t,\n        regions: loaderReducer(REGIONS, reducer$r),\n        resetPassword: reducer$s,\n        consignmentTracking: reducer$m,\n        customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$y),\n        notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$o),\n        productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$z),\n    };\n}\nconst reducerToken$d = new InjectionToken('UserReducers');\nconst reducerProvider$d = {\n    provide: reducerToken$d,\n    useFactory: getReducers$d,\n};\nfunction clearUserState(reducer) {\n    return function (state, action) {\n        if (action.type === LOGOUT) {\n            state = undefined;\n        }\n        return reducer(state, action);\n    };\n}\nconst metaReducers$8 = [clearUserState];\n\nlet BillingCountriesEffect = class BillingCountriesEffect {\n    constructor(actions$, siteConnector) {\n        this.actions$ = actions$;\n        this.siteConnector = siteConnector;\n        this.loadBillingCountries$ = this.actions$.pipe(ofType(LOAD_BILLING_COUNTRIES), switchMap(() => {\n            return this.siteConnector.getCountries(CountryType.BILLING).pipe(map(countries => new LoadBillingCountriesSuccess(countries)), catchError(error => of(new LoadBillingCountriesFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nBillingCountriesEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: SiteConnector }\n];\n__decorate([\n    Effect()\n], BillingCountriesEffect.prototype, \"loadBillingCountries$\", void 0);\nBillingCountriesEffect = __decorate([\n    Injectable()\n], BillingCountriesEffect);\n\nlet ClearMiscsDataEffect = class ClearMiscsDataEffect {\n    constructor(actions$) {\n        this.actions$ = actions$;\n        this.clearMiscsData$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), map(() => {\n            return new ClearUserMiscsData();\n        }));\n    }\n};\nClearMiscsDataEffect.ctorParameters = () => [\n    { type: Actions }\n];\n__decorate([\n    Effect()\n], ClearMiscsDataEffect.prototype, \"clearMiscsData$\", void 0);\nClearMiscsDataEffect = __decorate([\n    Injectable()\n], ClearMiscsDataEffect);\n\nlet ConsignmentTrackingEffects = class ConsignmentTrackingEffects {\n    constructor(actions$, userOrderConnector) {\n        this.actions$ = actions$;\n        this.userOrderConnector = userOrderConnector;\n        this.loadConsignmentTracking$ = this.actions$.pipe(ofType(LOAD_CONSIGNMENT_TRACKING), map((action) => action.payload), switchMap(payload => {\n            return this.userOrderConnector\n                .getConsignmentTracking(payload.orderCode, payload.consignmentCode, payload.userId)\n                .pipe(map((tracking) => new LoadConsignmentTrackingSuccess(tracking)), catchError(error => of(new LoadConsignmentTrackingFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nConsignmentTrackingEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserOrderConnector }\n];\n__decorate([\n    Effect()\n], ConsignmentTrackingEffects.prototype, \"loadConsignmentTracking$\", void 0);\nConsignmentTrackingEffects = __decorate([\n    Injectable()\n], ConsignmentTrackingEffects);\n\nlet DeliveryCountriesEffects = class DeliveryCountriesEffects {\n    constructor(actions$, siteConnector) {\n        this.actions$ = actions$;\n        this.siteConnector = siteConnector;\n        this.loadDeliveryCountries$ = this.actions$.pipe(ofType(LOAD_DELIVERY_COUNTRIES), switchMap(() => {\n            return this.siteConnector.getCountries(CountryType.SHIPPING).pipe(map(countries => new LoadDeliveryCountriesSuccess(countries)), catchError(error => of(new LoadDeliveryCountriesFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nDeliveryCountriesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: SiteConnector }\n];\n__decorate([\n    Effect()\n], DeliveryCountriesEffects.prototype, \"loadDeliveryCountries$\", void 0);\nDeliveryCountriesEffects = __decorate([\n    Injectable()\n], DeliveryCountriesEffects);\n\nlet ForgotPasswordEffects = class ForgotPasswordEffects {\n    constructor(actions$, userAccountConnector) {\n        this.actions$ = actions$;\n        this.userAccountConnector = userAccountConnector;\n        this.requestForgotPasswordEmail$ = this.actions$.pipe(ofType(FORGOT_PASSWORD_EMAIL_REQUEST), map((action) => {\n            return action.payload;\n        }), concatMap(userEmailAddress => {\n            return this.userAccountConnector\n                .requestForgotPasswordEmail(userEmailAddress)\n                .pipe(switchMap(() => [\n                new ForgotPasswordEmailRequestSuccess(),\n                new AddMessage({\n                    text: { key: 'forgottenPassword.passwordResetEmailSent' },\n                    type: GlobalMessageType.MSG_TYPE_CONFIRMATION,\n                }),\n            ]), catchError(error => of(new ForgotPasswordEmailRequestFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nForgotPasswordEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], ForgotPasswordEffects.prototype, \"requestForgotPasswordEmail$\", void 0);\nForgotPasswordEffects = __decorate([\n    Injectable()\n], ForgotPasswordEffects);\n\nlet NotificationPreferenceEffects = class NotificationPreferenceEffects {\n    constructor(actions$, connector) {\n        this.actions$ = actions$;\n        this.connector = connector;\n        this.loadPreferences$ = this.actions$.pipe(ofType(LOAD_NOTIFICATION_PREFERENCES), map((action) => action.payload), switchMap(payload => this.connector.loadAll(payload).pipe(map(preferences => new LoadNotificationPreferencesSuccess(preferences)), catchError(error => of(new LoadNotificationPreferencesFail(makeErrorSerializable(error)))))));\n        this.updatePreferences$ = this.actions$.pipe(ofType(UPDATE_NOTIFICATION_PREFERENCES), map((action) => action.payload), mergeMap(payload => this.connector.update(payload.userId, payload.preferences).pipe(map(() => new UpdateNotificationPreferencesSuccess(payload.preferences)), catchError(error => of(new UpdateNotificationPreferencesFail(makeErrorSerializable(error)))))));\n    }\n};\nNotificationPreferenceEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserNotificationPreferenceConnector }\n];\n__decorate([\n    Effect()\n], NotificationPreferenceEffects.prototype, \"loadPreferences$\", void 0);\n__decorate([\n    Effect()\n], NotificationPreferenceEffects.prototype, \"updatePreferences$\", void 0);\nNotificationPreferenceEffects = __decorate([\n    Injectable()\n], NotificationPreferenceEffects);\n\nlet OrderDetailsEffect = class OrderDetailsEffect {\n    constructor(actions$, orderConnector) {\n        this.actions$ = actions$;\n        this.orderConnector = orderConnector;\n        this.loadOrderDetails$ = this.actions$.pipe(ofType(LOAD_ORDER_DETAILS), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector.get(payload.userId, payload.orderCode).pipe(map((order) => {\n                return new LoadOrderDetailsSuccess(order);\n            }), catchError(error => of(new LoadOrderDetailsFail(makeErrorSerializable(error)))));\n        }));\n        this.cancelOrder$ = this.actions$.pipe(ofType(CANCEL_ORDER), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector\n                .cancel(payload.userId, payload.orderCode, payload.cancelRequestInput)\n                .pipe(map(_ => new CancelOrderSuccess()), catchError(error => of(new CancelOrderFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nOrderDetailsEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: UserOrderConnector }\n];\n__decorate([\n    Effect()\n], OrderDetailsEffect.prototype, \"loadOrderDetails$\", void 0);\n__decorate([\n    Effect()\n], OrderDetailsEffect.prototype, \"cancelOrder$\", void 0);\nOrderDetailsEffect = __decorate([\n    Injectable()\n], OrderDetailsEffect);\n\nlet OrderReturnRequestEffect = class OrderReturnRequestEffect {\n    constructor(actions$, orderConnector) {\n        this.actions$ = actions$;\n        this.orderConnector = orderConnector;\n        this.createReturnRequest$ = this.actions$.pipe(ofType(CREATE_ORDER_RETURN_REQUEST), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector\n                .return(payload.userId, payload.returnRequestInput)\n                .pipe(map((returnRequest) => new CreateOrderReturnRequestSuccess(returnRequest)), catchError(error => of(new CreateOrderReturnRequestFail(makeErrorSerializable(error)))));\n        }));\n        this.loadReturnRequest$ = this.actions$.pipe(ofType(LOAD_ORDER_RETURN_REQUEST), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector\n                .getReturnRequestDetail(payload.userId, payload.returnRequestCode)\n                .pipe(map((returnRequest) => new LoadOrderReturnRequestSuccess(returnRequest)), catchError(error => of(new LoadOrderReturnRequestFail(makeErrorSerializable(error)))));\n        }));\n        this.cancelReturnRequest$ = this.actions$.pipe(ofType(CANCEL_ORDER_RETURN_REQUEST), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector\n                .cancelReturnRequest(payload.userId, payload.returnRequestCode, payload.returnRequestModification)\n                .pipe(map(_ => new CancelOrderReturnRequestSuccess()), catchError(error => of(new CancelOrderReturnRequestFail(makeErrorSerializable(error)))));\n        }));\n        this.loadReturnRequestList$ = this.actions$.pipe(ofType(LOAD_ORDER_RETURN_REQUEST_LIST), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector\n                .getReturnRequestList(payload.userId, payload.pageSize, payload.currentPage, payload.sort)\n                .pipe(map((returnRequestList) => new LoadOrderReturnRequestListSuccess(returnRequestList)), catchError(error => of(new LoadOrderReturnRequestListFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nOrderReturnRequestEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: UserOrderConnector }\n];\n__decorate([\n    Effect()\n], OrderReturnRequestEffect.prototype, \"createReturnRequest$\", void 0);\n__decorate([\n    Effect()\n], OrderReturnRequestEffect.prototype, \"loadReturnRequest$\", void 0);\n__decorate([\n    Effect()\n], OrderReturnRequestEffect.prototype, \"cancelReturnRequest$\", void 0);\n__decorate([\n    Effect()\n], OrderReturnRequestEffect.prototype, \"loadReturnRequestList$\", void 0);\nOrderReturnRequestEffect = __decorate([\n    Injectable()\n], OrderReturnRequestEffect);\n\nlet UserPaymentMethodsEffects = class UserPaymentMethodsEffects {\n    constructor(actions$, userPaymentMethodConnector) {\n        this.actions$ = actions$;\n        this.userPaymentMethodConnector = userPaymentMethodConnector;\n        this.loadUserPaymentMethods$ = this.actions$.pipe(ofType(LOAD_USER_PAYMENT_METHODS), map((action) => action.payload), mergeMap(payload => {\n            return this.userPaymentMethodConnector.getAll(payload).pipe(map((payments) => {\n                return new LoadUserPaymentMethodsSuccess(payments);\n            }), catchError(error => of(new LoadUserPaymentMethodsFail(makeErrorSerializable(error)))));\n        }));\n        this.setDefaultUserPaymentMethod$ = this.actions$.pipe(ofType(SET_DEFAULT_USER_PAYMENT_METHOD), map((action) => action.payload), mergeMap(payload => {\n            return this.userPaymentMethodConnector\n                .setDefault(payload.userId, payload.paymentMethodId)\n                .pipe(switchMap(data => [\n                new SetDefaultUserPaymentMethodSuccess(data),\n                new LoadUserPaymentMethods(payload.userId),\n            ]), catchError(error => of(new SetDefaultUserPaymentMethodFail(makeErrorSerializable(error)))));\n        }));\n        this.deleteUserPaymentMethod$ = this.actions$.pipe(ofType(DELETE_USER_PAYMENT_METHOD), map((action) => action.payload), mergeMap(payload => {\n            return this.userPaymentMethodConnector\n                .delete(payload.userId, payload.paymentMethodId)\n                .pipe(switchMap(data => [\n                new DeleteUserPaymentMethodSuccess(data),\n                new LoadUserPaymentMethods(payload.userId),\n            ]), catchError(error => of(new DeleteUserPaymentMethodFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nUserPaymentMethodsEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserPaymentConnector }\n];\n__decorate([\n    Effect()\n], UserPaymentMethodsEffects.prototype, \"loadUserPaymentMethods$\", void 0);\n__decorate([\n    Effect()\n], UserPaymentMethodsEffects.prototype, \"setDefaultUserPaymentMethod$\", void 0);\n__decorate([\n    Effect()\n], UserPaymentMethodsEffects.prototype, \"deleteUserPaymentMethod$\", void 0);\nUserPaymentMethodsEffects = __decorate([\n    Injectable()\n], UserPaymentMethodsEffects);\n\nlet RegionsEffects = class RegionsEffects {\n    constructor(actions$, siteConnector) {\n        this.actions$ = actions$;\n        this.siteConnector = siteConnector;\n        this.loadRegions$ = this.actions$.pipe(ofType(LOAD_REGIONS), map((action) => {\n            return action.payload;\n        }), switchMap((countryCode) => {\n            return this.siteConnector.getRegions(countryCode).pipe(map(regions => new LoadRegionsSuccess({\n                entities: regions,\n                country: countryCode,\n            })), catchError(error => of(new LoadRegionsFail(makeErrorSerializable(error)))));\n        }));\n        this.resetRegions$ = this.actions$.pipe(ofType(CLEAR_USER_MISCS_DATA, CLEAR_REGIONS), map(() => {\n            return new LoaderResetAction(REGIONS);\n        }));\n    }\n};\nRegionsEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: SiteConnector }\n];\n__decorate([\n    Effect()\n], RegionsEffects.prototype, \"loadRegions$\", void 0);\n__decorate([\n    Effect()\n], RegionsEffects.prototype, \"resetRegions$\", void 0);\nRegionsEffects = __decorate([\n    Injectable()\n], RegionsEffects);\n\nlet ResetPasswordEffects = class ResetPasswordEffects {\n    constructor(actions$, userAccountConnector) {\n        this.actions$ = actions$;\n        this.userAccountConnector = userAccountConnector;\n        this.resetPassword$ = this.actions$.pipe(ofType(RESET_PASSWORD), map((action) => action.payload), switchMap(({ token, password }) => {\n            return this.userAccountConnector.resetPassword(token, password).pipe(switchMap(() => [\n                new ResetPasswordSuccess(),\n                new AddMessage({\n                    text: { key: 'forgottenPassword.passwordResetSuccess' },\n                    type: GlobalMessageType.MSG_TYPE_CONFIRMATION,\n                }),\n            ]), catchError(error => of(new ResetPasswordFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nResetPasswordEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], ResetPasswordEffects.prototype, \"resetPassword$\", void 0);\nResetPasswordEffects = __decorate([\n    Injectable()\n], ResetPasswordEffects);\n\nlet TitlesEffects = class TitlesEffects {\n    constructor(actions$, userAccountConnector) {\n        this.actions$ = actions$;\n        this.userAccountConnector = userAccountConnector;\n        this.loadTitles$ = this.actions$.pipe(ofType(LOAD_TITLES), switchMap(() => {\n            return this.userAccountConnector.getTitles().pipe(map(titles => {\n                return new LoadTitlesSuccess(titles);\n            }), catchError(error => of(new LoadTitlesFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nTitlesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], TitlesEffects.prototype, \"loadTitles$\", void 0);\nTitlesEffects = __decorate([\n    Injectable()\n], TitlesEffects);\n\nlet UpdateEmailEffects = class UpdateEmailEffects {\n    constructor(actions$, userAccountConnector) {\n        this.actions$ = actions$;\n        this.userAccountConnector = userAccountConnector;\n        this.updateEmail$ = this.actions$.pipe(ofType(UPDATE_EMAIL), map((action) => action.payload), concatMap(payload => this.userAccountConnector\n            .updateEmail(payload.uid, payload.password, payload.newUid)\n            .pipe(map(() => new UpdateEmailSuccessAction(payload.newUid)), catchError(error => of(new UpdateEmailErrorAction(makeErrorSerializable(error)))))));\n    }\n};\nUpdateEmailEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], UpdateEmailEffects.prototype, \"updateEmail$\", void 0);\nUpdateEmailEffects = __decorate([\n    Injectable()\n], UpdateEmailEffects);\n\nlet UpdatePasswordEffects = class UpdatePasswordEffects {\n    constructor(actions$, userAccountConnector) {\n        this.actions$ = actions$;\n        this.userAccountConnector = userAccountConnector;\n        this.updatePassword$ = this.actions$.pipe(ofType(UPDATE_PASSWORD), map((action) => action.payload), concatMap(payload => this.userAccountConnector\n            .updatePassword(payload.userId, payload.oldPassword, payload.newPassword)\n            .pipe(map(_ => new UpdatePasswordSuccess()), catchError(error => of(new UpdatePasswordFail(makeErrorSerializable(error)))))));\n    }\n};\nUpdatePasswordEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], UpdatePasswordEffects.prototype, \"updatePassword$\", void 0);\nUpdatePasswordEffects = __decorate([\n    Injectable()\n], UpdatePasswordEffects);\n\nlet UserAddressesEffects = class UserAddressesEffects {\n    constructor(actions$, userAddressConnector, userAddressService, messageService) {\n        this.actions$ = actions$;\n        this.userAddressConnector = userAddressConnector;\n        this.userAddressService = userAddressService;\n        this.messageService = messageService;\n        this.loadUserAddresses$ = this.actions$.pipe(ofType(LOAD_USER_ADDRESSES), map((action) => action.payload), mergeMap(payload => {\n            return this.userAddressConnector.getAll(payload).pipe(map((addresses) => {\n                return new LoadUserAddressesSuccess(addresses);\n            }), catchError(error => of(new LoadUserAddressesFail(makeErrorSerializable(error)))));\n        }));\n        this.addUserAddress$ = this.actions$.pipe(ofType(ADD_USER_ADDRESS), map((action) => action.payload), mergeMap(payload => {\n            return this.userAddressConnector\n                .add(payload.userId, payload.address)\n                .pipe(map((data) => {\n                return new AddUserAddressSuccess(data);\n            }), catchError(error => of(new AddUserAddressFail(makeErrorSerializable(error)))));\n        }));\n        this.updateUserAddress$ = this.actions$.pipe(ofType(UPDATE_USER_ADDRESS), map((action) => action.payload), mergeMap(payload => {\n            return this.userAddressConnector\n                .update(payload.userId, payload.addressId, payload.address)\n                .pipe(map(data => {\n                // don't show the message if just setting address as default\n                if (payload.address &&\n                    Object.keys(payload.address).length === 1 &&\n                    payload.address.defaultAddress) {\n                    return new LoadUserAddresses(payload.userId);\n                }\n                else {\n                    return new UpdateUserAddressSuccess(data);\n                }\n            }), catchError(error => of(new UpdateUserAddressFail(makeErrorSerializable(error)))));\n        }));\n        this.deleteUserAddress$ = this.actions$.pipe(ofType(DELETE_USER_ADDRESS), map((action) => action.payload), mergeMap(payload => {\n            return this.userAddressConnector\n                .delete(payload.userId, payload.addressId)\n                .pipe(map(data => {\n                return new DeleteUserAddressSuccess(data);\n            }), catchError(error => of(new DeleteUserAddressFail(makeErrorSerializable(error)))));\n        }));\n        /**\n         *  Reload addresses and notify about add success\n         */\n        this.showGlobalMessageOnAddSuccess$ = this.actions$.pipe(ofType(ADD_USER_ADDRESS_SUCCESS), tap(() => {\n            this.loadAddresses();\n            this.showGlobalMessage('addressForm.userAddressAddSuccess');\n        }));\n        /**\n         *  Reload addresses and notify about update success\n         */\n        this.showGlobalMessageOnUpdateSuccess$ = this.actions$.pipe(ofType(UPDATE_USER_ADDRESS_SUCCESS), tap(() => {\n            this.loadAddresses();\n            this.showGlobalMessage('addressForm.userAddressUpdateSuccess');\n        }));\n        /**\n         *  Reload addresses and notify about delete success\n         */\n        this.showGlobalMessageOnDeleteSuccess$ = this.actions$.pipe(ofType(DELETE_USER_ADDRESS_SUCCESS), tap(() => {\n            this.loadAddresses();\n            this.showGlobalMessage('addressForm.userAddressDeleteSuccess');\n        }));\n    }\n    /**\n     * Show global confirmation message with provided text\n     */\n    showGlobalMessage(text) {\n        this.messageService.add({ key: text }, GlobalMessageType.MSG_TYPE_CONFIRMATION);\n    }\n    loadAddresses() {\n        this.userAddressService.loadAddresses();\n    }\n};\nUserAddressesEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserAddressConnector },\n    { type: UserAddressService },\n    { type: GlobalMessageService }\n];\n__decorate([\n    Effect()\n], UserAddressesEffects.prototype, \"loadUserAddresses$\", void 0);\n__decorate([\n    Effect()\n], UserAddressesEffects.prototype, \"addUserAddress$\", void 0);\n__decorate([\n    Effect()\n], UserAddressesEffects.prototype, \"updateUserAddress$\", void 0);\n__decorate([\n    Effect()\n], UserAddressesEffects.prototype, \"deleteUserAddress$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], UserAddressesEffects.prototype, \"showGlobalMessageOnAddSuccess$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], UserAddressesEffects.prototype, \"showGlobalMessageOnUpdateSuccess$\", void 0);\n__decorate([\n    Effect({ dispatch: false })\n], UserAddressesEffects.prototype, \"showGlobalMessageOnDeleteSuccess$\", void 0);\nUserAddressesEffects = __decorate([\n    Injectable()\n], UserAddressesEffects);\n\nlet UserConsentsEffect = class UserConsentsEffect {\n    constructor(actions$, userConsentConnector) {\n        this.actions$ = actions$;\n        this.userConsentConnector = userConsentConnector;\n        this.resetConsents$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), map(() => new ResetLoadUserConsents()));\n        this.getConsents$ = this.actions$.pipe(ofType(LOAD_USER_CONSENTS), map((action) => action.payload), concatMap(userId => this.userConsentConnector.loadConsents(userId).pipe(map(consents => new LoadUserConsentsSuccess(consents)), catchError(error => of(new LoadUserConsentsFail(makeErrorSerializable(error)))))));\n        this.giveConsent$ = this.actions$.pipe(ofType(GIVE_USER_CONSENT, TRANSFER_ANONYMOUS_CONSENT), concatMap(action => this.userConsentConnector\n            .giveConsent(action.payload.userId, action.payload.consentTemplateId, action.payload.consentTemplateVersion)\n            .pipe(map(consent => new GiveUserConsentSuccess(consent)), catchError(error => {\n            const errors = [\n                new GiveUserConsentFail(makeErrorSerializable(error)),\n            ];\n            if (action.type === TRANSFER_ANONYMOUS_CONSENT &&\n                error.status === 409) {\n                errors.push(new RemoveMessagesByType(GlobalMessageType.MSG_TYPE_ERROR));\n            }\n            return of(...errors);\n        }))));\n        this.withdrawConsent$ = this.actions$.pipe(ofType(WITHDRAW_USER_CONSENT), map((action) => action.payload), concatMap(({ userId, consentCode }) => this.userConsentConnector.withdrawConsent(userId, consentCode).pipe(map(() => new WithdrawUserConsentSuccess()), catchError(error => of(new WithdrawUserConsentFail(makeErrorSerializable(error)))))));\n    }\n};\nUserConsentsEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConsentConnector }\n];\n__decorate([\n    Effect()\n], UserConsentsEffect.prototype, \"resetConsents$\", void 0);\n__decorate([\n    Effect()\n], UserConsentsEffect.prototype, \"getConsents$\", void 0);\n__decorate([\n    Effect()\n], UserConsentsEffect.prototype, \"giveConsent$\", void 0);\n__decorate([\n    Effect()\n], UserConsentsEffect.prototype, \"withdrawConsent$\", void 0);\nUserConsentsEffect = __decorate([\n    Injectable()\n], UserConsentsEffect);\n\nlet UserDetailsEffects = class UserDetailsEffects {\n    constructor(actions$, userConnector) {\n        this.actions$ = actions$;\n        this.userConnector = userConnector;\n        this.loadUserDetails$ = this.actions$.pipe(ofType(LOAD_USER_DETAILS), map((action) => action.payload), mergeMap(userId => {\n            return this.userConnector.get(userId).pipe(map((user) => {\n                return new LoadUserDetailsSuccess(user);\n            }), catchError(error => of(new LoadUserDetailsFail(makeErrorSerializable(error)))));\n        }));\n        this.updateUserDetails$ = this.actions$.pipe(ofType(UPDATE_USER_DETAILS), map((action) => action.payload), concatMap(payload => this.userConnector.update(payload.username, payload.userDetails).pipe(map(_ => new UpdateUserDetailsSuccess(payload.userDetails)), catchError(error => of(new UpdateUserDetailsFail(makeErrorSerializable(error)))))));\n    }\n};\nUserDetailsEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], UserDetailsEffects.prototype, \"loadUserDetails$\", void 0);\n__decorate([\n    Effect()\n], UserDetailsEffects.prototype, \"updateUserDetails$\", void 0);\nUserDetailsEffects = __decorate([\n    Injectable()\n], UserDetailsEffects);\n\nlet UserOrdersEffect = class UserOrdersEffect {\n    constructor(actions$, orderConnector) {\n        this.actions$ = actions$;\n        this.orderConnector = orderConnector;\n        this.loadUserOrders$ = this.actions$.pipe(ofType(LOAD_USER_ORDERS), map((action) => action.payload), switchMap(payload => {\n            return this.orderConnector\n                .getHistory(payload.userId, payload.pageSize, payload.currentPage, payload.sort)\n                .pipe(map((orders) => {\n                return new LoadUserOrdersSuccess(orders);\n            }), catchError(error => of(new LoadUserOrdersFail(makeErrorSerializable(error)))));\n        }));\n        this.resetUserOrders$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), map(() => {\n            return new ClearUserOrders();\n        }));\n    }\n};\nUserOrdersEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: UserOrderConnector }\n];\n__decorate([\n    Effect()\n], UserOrdersEffect.prototype, \"loadUserOrders$\", void 0);\n__decorate([\n    Effect()\n], UserOrdersEffect.prototype, \"resetUserOrders$\", void 0);\nUserOrdersEffect = __decorate([\n    Injectable()\n], UserOrdersEffect);\n\nlet UserRegisterEffects = class UserRegisterEffects {\n    constructor(actions$, userConnector) {\n        this.actions$ = actions$;\n        this.userConnector = userConnector;\n        this.registerUser$ = this.actions$.pipe(ofType(REGISTER_USER), map((action) => action.payload), mergeMap((user) => this.userConnector.register(user).pipe(map(() => new RegisterUserSuccess()), catchError(error => of(new RegisterUserFail(makeErrorSerializable(error)))))));\n        this.registerGuest$ = this.actions$.pipe(ofType(REGISTER_GUEST), map((action) => action.payload), mergeMap(({ guid, password }) => this.userConnector.registerGuest(guid, password).pipe(switchMap(user => [\n            new LoadUserToken({\n                userId: user.uid,\n                password: password,\n            }),\n            new RegisterGuestSuccess(),\n        ]), catchError(error => of(new RegisterGuestFail(makeErrorSerializable(error)))))));\n        this.removeUser$ = this.actions$.pipe(ofType(REMOVE_USER), map((action) => action.payload), mergeMap((userId) => {\n            return this.userConnector.remove(userId).pipe(switchMap(_result => [\n                new RemoveUserSuccess(),\n                new Logout(),\n            ]), catchError(error => of(new RemoveUserFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nUserRegisterEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: UserConnector }\n];\n__decorate([\n    Effect()\n], UserRegisterEffects.prototype, \"registerUser$\", void 0);\n__decorate([\n    Effect()\n], UserRegisterEffects.prototype, \"registerGuest$\", void 0);\n__decorate([\n    Effect()\n], UserRegisterEffects.prototype, \"removeUser$\", void 0);\nUserRegisterEffects = __decorate([\n    Injectable()\n], UserRegisterEffects);\n\nlet CustomerCouponEffects = class CustomerCouponEffects {\n    constructor(actions$, customerCouponConnector) {\n        this.actions$ = actions$;\n        this.customerCouponConnector = customerCouponConnector;\n        this.loadCustomerCoupons$ = this.actions$.pipe(ofType(LOAD_CUSTOMER_COUPONS), map((action) => action.payload), mergeMap(payload => {\n            return this.customerCouponConnector\n                .getCustomerCoupons(payload.userId, payload.pageSize, payload.currentPage, payload.sort)\n                .pipe(map((coupons) => {\n                return new LoadCustomerCouponsSuccess(coupons);\n            }), catchError(error => of(new LoadCustomerCouponsFail(makeErrorSerializable(error)))));\n        }));\n        this.subscribeCustomerCoupon$ = this.actions$.pipe(ofType(SUBSCRIBE_CUSTOMER_COUPON), map((action) => action.payload), mergeMap(payload => {\n            return this.customerCouponConnector\n                .turnOnNotification(payload.userId, payload.couponCode)\n                .pipe(map((data) => {\n                return new SubscribeCustomerCouponSuccess(data);\n            }), catchError(error => of(new SubscribeCustomerCouponFail(makeErrorSerializable(error)))));\n        }));\n        this.unsubscribeCustomerCoupon$ = this.actions$.pipe(ofType(UNSUBSCRIBE_CUSTOMER_COUPON), map((action) => action.payload), mergeMap(payload => {\n            return this.customerCouponConnector\n                .turnOffNotification(payload.userId, payload.couponCode)\n                .pipe(map(() => {\n                return new UnsubscribeCustomerCouponSuccess(payload.couponCode);\n            }), catchError(error => of(new UnsubscribeCustomerCouponFail(makeErrorSerializable(error)))));\n        }));\n        this.claimCustomerCoupon$ = this.actions$.pipe(ofType(CLAIM_CUSTOMER_COUPON), map((action) => action.payload), mergeMap(payload => {\n            return this.customerCouponConnector\n                .claimCustomerCoupon(payload.userId, payload.couponCode)\n                .pipe(map(data => {\n                return new ClaimCustomerCouponSuccess(data);\n            }), catchError(error => of(new ClaimCustomerCouponFail(makeErrorSerializable(error)))));\n        }));\n    }\n};\nCustomerCouponEffects.ctorParameters = () => [\n    { type: Actions },\n    { type: CustomerCouponConnector }\n];\n__decorate([\n    Effect()\n], CustomerCouponEffects.prototype, \"loadCustomerCoupons$\", void 0);\n__decorate([\n    Effect()\n], CustomerCouponEffects.prototype, \"subscribeCustomerCoupon$\", void 0);\n__decorate([\n    Effect()\n], CustomerCouponEffects.prototype, \"unsubscribeCustomerCoupon$\", void 0);\n__decorate([\n    Effect()\n], CustomerCouponEffects.prototype, \"claimCustomerCoupon$\", void 0);\nCustomerCouponEffects = __decorate([\n    Injectable()\n], CustomerCouponEffects);\n\nlet ProductInterestsEffect = class ProductInterestsEffect {\n    constructor(actions$, userInterestsConnector) {\n        this.actions$ = actions$;\n        this.userInterestsConnector = userInterestsConnector;\n        this.loadProductInteres$ = this.actions$.pipe(ofType(LOAD_PRODUCT_INTERESTS), map((action) => action.payload), switchMap(payload => {\n            return this.userInterestsConnector\n                .getInterests(payload.userId, payload.pageSize, payload.currentPage, payload.sort, payload.productCode, payload.notificationType)\n                .pipe(map((interests) => {\n                return new LoadProductInterestsSuccess(interests);\n            }), catchError(error => of(new LoadProductInterestsFail(makeErrorSerializable(error)))));\n        }));\n        this.removeProductInterest$ = this.actions$.pipe(ofType(REMOVE_PRODUCT_INTEREST), map((action) => action.payload), switchMap(payload => this.userInterestsConnector\n            .removeInterest(payload.userId, payload.item)\n            .pipe(switchMap(data => [\n            new LoadProductInterests(payload.singleDelete\n                ? {\n                    userId: payload.userId,\n                    productCode: payload.item.product.code,\n                    notificationType: payload.item.productInterestEntry[0].interestType,\n                }\n                : { userId: payload.userId }),\n            new RemoveProductInterestSuccess(data),\n        ]), catchError(error => of(new RemoveProductInterestFail(makeErrorSerializable(error)))))));\n        this.addProductInterest$ = this.actions$.pipe(ofType(ADD_PRODUCT_INTEREST), map((action) => action.payload), switchMap(payload => this.userInterestsConnector\n            .addInterest(payload.userId, payload.productCode, payload.notificationType)\n            .pipe(switchMap((res) => [\n            new LoadProductInterests({\n                userId: payload.userId,\n                productCode: payload.productCode,\n                notificationType: payload.notificationType,\n            }),\n            new AddProductInterestSuccess(res),\n        ]), catchError(error => of(new AddProductInterestFail(makeErrorSerializable(error)))))));\n    }\n};\nProductInterestsEffect.ctorParameters = () => [\n    { type: Actions },\n    { type: UserInterestsConnector }\n];\n__decorate([\n    Effect()\n], ProductInterestsEffect.prototype, \"loadProductInteres$\", void 0);\n__decorate([\n    Effect()\n], ProductInterestsEffect.prototype, \"removeProductInterest$\", void 0);\n__decorate([\n    Effect()\n], ProductInterestsEffect.prototype, \"addProductInterest$\", void 0);\nProductInterestsEffect = __decorate([\n    Injectable()\n], ProductInterestsEffect);\n\nconst effects$c = [\n    ClearMiscsDataEffect,\n    DeliveryCountriesEffects,\n    RegionsEffects,\n    TitlesEffects,\n    UserDetailsEffects,\n    UserAddressesEffects,\n    UserPaymentMethodsEffects,\n    UserRegisterEffects,\n    UserOrdersEffect,\n    OrderDetailsEffect,\n    BillingCountriesEffect,\n    ResetPasswordEffects,\n    ForgotPasswordEffects,\n    UpdateEmailEffects,\n    UpdatePasswordEffects,\n    UserConsentsEffect,\n    ConsignmentTrackingEffects,\n    CustomerCouponEffects,\n    NotificationPreferenceEffects,\n    ProductInterestsEffect,\n    OrderReturnRequestEffect,\n];\n\nlet UserStoreModule = class UserStoreModule {\n};\nUserStoreModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            ReactiveFormsModule,\n            StateModule,\n            StoreModule.forFeature(USER_FEATURE, reducerToken$d, { metaReducers: metaReducers$8 }),\n            EffectsModule.forFeature(effects$c),\n            RouterModule,\n        ],\n        providers: [reducerProvider$d],\n    })\n], UserStoreModule);\n\nlet FindProductPageMetaResolver = class FindProductPageMetaResolver extends PageMetaResolver {\n    constructor(routingService, productSearchService, translation, authService) {\n        super();\n        this.routingService = routingService;\n        this.productSearchService = productSearchService;\n        this.translation = translation;\n        this.authService = authService;\n        this.totalAndCode$ = combineLatest([\n            this.productSearchService.getResults().pipe(filter(data => !!(data && data.pagination)), map(results => results.pagination.totalResults)),\n            this.routingService.getRouterState().pipe(map(state => state.state.queryParams['couponcode']), filter(Boolean)),\n        ]);\n        this.pageType = PageType.CONTENT_PAGE;\n        this.pageTemplate = 'SearchResultsListPageTemplate';\n    }\n    /**\n     * @deprecated since version 1.3\n     *\n     * The resolve method is no longer preferred and will be removed with release 2.0.\n     * The caller `PageMetaService` service is improved to expect all individual resolvers\n     * instead, so that the code is easier extensible.\n     */\n    resolve() {\n        return combineLatest([this.resolveTitle(), this.resolveBreadcrumbs()]).pipe(map(([title, breadcrumbs]) => ({\n            title,\n            breadcrumbs,\n        })));\n    }\n    resolveBreadcrumbs() {\n        const breadcrumbs = [{ label: 'Home', link: '/' }];\n        this.authService.isUserLoggedIn().subscribe(login => {\n            if (login)\n                breadcrumbs.push({ label: 'My Coupons', link: '/my-account/coupons' });\n        });\n        return of(breadcrumbs);\n    }\n    resolveTitle() {\n        return this.totalAndCode$.pipe(switchMap(([total, code]) => this.translation.translate('pageMetaResolver.search.findProductTitle', {\n            count: total,\n            coupon: code,\n        })));\n    }\n    getScore(page) {\n        let score = 0;\n        if (this.pageType) {\n            score += page.type === this.pageType ? 1 : -1;\n        }\n        if (this.pageTemplate) {\n            score += page.template === this.pageTemplate ? 1 : -1;\n        }\n        this.routingService\n            .getRouterState()\n            .pipe(map(state => {\n            return state.state.queryParams;\n        }), filter(Boolean))\n            .subscribe((queryParams) => {\n            if (queryParams) {\n                score += queryParams['couponcode'] ? 1 : -1;\n            }\n        })\n            .unsubscribe();\n        return score;\n    }\n};\nFindProductPageMetaResolver.ctorParameters = () => [\n    { type: RoutingService },\n    { type: ProductSearchService },\n    { type: TranslationService },\n    { type: AuthService }\n];\nFindProductPageMetaResolver.ɵprov = ɵɵdefineInjectable({ factory: function FindProductPageMetaResolver_Factory() { return new FindProductPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductSearchService), ɵɵinject(TranslationService), ɵɵinject(AuthService)); }, token: FindProductPageMetaResolver, providedIn: \"root\" });\nFindProductPageMetaResolver = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], FindProductPageMetaResolver);\n\nvar UserModule_1;\nlet UserModule = UserModule_1 = class UserModule {\n    static forRoot() {\n        return {\n            ngModule: UserModule_1,\n            providers: [\n                UserService,\n                {\n                    provide: PageMetaResolver,\n                    useExisting: FindProductPageMetaResolver,\n                    multi: true,\n                },\n            ],\n        };\n    }\n};\nUserModule = UserModule_1 = __decorate([\n    NgModule({\n        imports: [UserStoreModule],\n    })\n], UserModule);\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ADDRESS_NORMALIZER, ADDRESS_SERIALIZER, ADDRESS_VALIDATION_NORMALIZER, ADD_PRODUCT_INTEREST_PROCESS_ID, ADD_VOUCHER_PROCESS_ID, ANONYMOUS_CONSENTS, ANONYMOUS_CONSENTS_FEATURE, ANONYMOUS_CONSENTS_STORE_FEATURE, ANONYMOUS_CONSENT_STATUS, ANONYMOUS_USERID, ASM_FEATURE, AUTH_FEATURE, ActiveCartService, AnonymousConsentTemplatesAdapter, AnonymousConsentTemplatesConnector, anonymousConsentsGroup as AnonymousConsentsActions, AnonymousConsentsConfig, AnonymousConsentsModule, anonymousConsentsGroup_selectors as AnonymousConsentsSelectors, AnonymousConsentsService, customerGroup_actions as AsmActions, AsmAdapter, AsmAuthService, AsmConfig, AsmConnector, AsmModule, AsmOccModule, asmGroup_selectors as AsmSelectors, AsmService, authGroup_actions as AuthActions, AuthConfig, AuthGuard, AuthModule, AuthRedirectService, authGroup_selectors as AuthSelectors, AuthService, BASE_SITE_CONTEXT_ID, BadGatewayHandler, BadRequestHandler, BaseSiteService, CANCEL_ORDER_PROCESS_ID, CANCEL_RETURN_PROCESS_ID, CARD_TYPE_NORMALIZER, CART_DATA, CART_FEATURE, CART_MODIFICATION_NORMALIZER, CART_NORMALIZER, CART_VOUCHER_NORMALIZER, CHECKOUT_DETAILS, CHECKOUT_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, CLIENT_TOKEN_DATA, CMS_COMPONENT_NORMALIZER, CMS_FEATURE, CMS_FLEX_COMPONENT_TYPE, CMS_PAGE_NORMALIZER, COMPONENT_ENTITY, CONFIG_INITIALIZER, CONSENT_TEMPLATE_NORMALIZER, CONSIGNMENT_TRACKING_NORMALIZER, COUNTRY_NORMALIZER, CSAGENT_TOKEN_DATA, CURRENCY_CONTEXT_ID, CURRENCY_NORMALIZER, CUSTOMER_COUPONS, CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER, CUSTOMER_SEARCH_DATA, CUSTOMER_SEARCH_PAGE_NORMALIZER, cartGroup_actions as CartActions, CartAdapter, CartConnector, CartDataService, CartEffects, CartEntryAdapter, CartEntryConnector, CartEntryEffects, CartModule, CartOccModule, cartGroup_selectors as CartSelectors, CartService, CartVoucherAdapter, CartVoucherConnector, CartVoucherEffects, CartVoucherService, CategoryPageMetaResolver, checkoutGroup_actions as CheckoutActions, CheckoutAdapter, CheckoutConnector, CheckoutDeliveryAdapter, CheckoutDeliveryConnector, CheckoutDeliveryService, CheckoutModule, CheckoutOccModule, CheckoutPageMetaResolver, CheckoutPaymentAdapter, CheckoutPaymentConnector, CheckoutPaymentService, checkoutGroup_selectors as CheckoutSelectors, CheckoutService, cmsGroup_actions as CmsActions, CmsBannerCarouselEffect, CmsComponentAdapter, CmsComponentConnector, CmsConfig, CmsModule, CmsOccModule, CmsPageAdapter, CmsPageConnector, CmsPageTitleModule, cmsGroup_selectors as CmsSelectors, CmsService, CmsStructureConfig, CmsStructureConfigService, Config, ConfigChunk, ConfigInitializerModule, ConfigInitializerService, ConfigModule, ConfigValidatorToken, ConfigurableRoutesService, ConflictHandler, ConsentService, ContentPageMetaResolver, ContextServiceMap, ConverterService, CountryType, CurrencyService, CustomerCouponAdapter, CustomerCouponConnector, CustomerCouponService, CustomerSupportAgentTokenInterceptor, CxDatePipe, DEFAULT_LOCAL_STORAGE_KEY, DEFAULT_SESSION_STORAGE_KEY, DELIVERY_MODE_NORMALIZER, DeferLoadingStrategy, DynamicAttributeService, EMAIL_PATTERN, EXTERNAL_CONFIG_TRANSFER_ID, ExternalJsFileLoader, ExternalRoutesConfig, ExternalRoutesGuard, ExternalRoutesModule, ExternalRoutesService, FeatureConfigService, FeatureDirective, FeatureLevelDirective, FeaturesConfig, FeaturesConfigModule, ForbiddenHandler, GIVE_CONSENT_PROCESS_ID, GLOBAL_MESSAGE_FEATURE, GatewayTimeoutHandler, GlobService, globalMessageGroup_actions as GlobalMessageActions, GlobalMessageConfig, GlobalMessageModule, globalMessageGroup_selectors as GlobalMessageSelectors, GlobalMessageService, GlobalMessageType, GoogleMapRendererService, HttpErrorHandler, I18nConfig, I18nModule, I18nTestingModule, I18nextTranslationService, ImageType, InterceptorUtil, JSP_INCLUDE_CMS_COMPONENT_TYPE, JavaRegExpConverter, KYMA_FEATURE, kymaGroup_actions as KymaActions, KymaConfig, KymaModule, kymaGroup_selectors as KymaSelectors, KymaService, KymaServices, LANGUAGE_CONTEXT_ID, LANGUAGE_NORMALIZER, LanguageService, LoadingScopesService, MEDIA_BASE_URL_META_TAG_NAME, MEDIA_BASE_URL_META_TAG_PLACEHOLDER, MULTI_CART_DATA, MULTI_CART_FEATURE, MockDatePipe, MockTranslatePipe, multiCartGroup_selectors as MultiCartSelectors, MultiCartService, NAVIGATION_DETAIL_ENTITY, NOTIFICATION_PREFERENCES, NgExpressEngineDecorator, NotAuthGuard, NotFoundHandler, NotificationType, OCC_BASE_URL_META_TAG_NAME, OCC_BASE_URL_META_TAG_PLACEHOLDER, OCC_CART_ID_CURRENT, OCC_USER_ID_ANONYMOUS, OCC_USER_ID_CURRENT, OCC_USER_ID_GUEST, OPEN_ID_TOKEN_DATA, ORDER_HISTORY_NORMALIZER, ORDER_NORMALIZER, ORDER_RETURNS_NORMALIZER, ORDER_RETURN_REQUEST_INPUT_SERIALIZER, ORDER_RETURN_REQUEST_NORMALIZER, Occ, OccAnonymousConsentTemplatesAdapter, OccAsmAdapter, OccCartAdapter, OccCartEntryAdapter, OccCartNormalizer, OccCartVoucherAdapter, OccCheckoutAdapter, OccCheckoutDeliveryAdapter, OccCheckoutPaymentAdapter, OccCmsComponentAdapter, OccCmsPageAdapter, OccCmsPageNormalizer, OccConfig, OccConfigLoaderModule, OccConfigLoaderService, OccCustomerCouponAdapter, OccEndpointsService, OccFieldsService, OccLoadedConfigConverter, OccModule, OccOrderNormalizer, OccProductAdapter, OccProductReferencesAdapter, OccProductReferencesListNormalizer, OccProductReviewsAdapter, OccProductSearchAdapter, OccProductSearchPageNormalizer, OccRequestsOptimizerService, OccReturnRequestNormalizer, OccSiteAdapter, OccSitesConfigLoader, OccStoreFinderAdapter, OccUserAdapter, OccUserAddressAdapter, OccUserConsentAdapter, OccUserInterestsAdapter, OccUserInterestsNormalizer, OccUserNotificationPreferenceAdapter, OccUserOrderAdapter, OccUserPaymentAdapter, OrderReturnRequestService, PASSWORD_PATTERN, PAYMENT_DETAILS_NORMALIZER, PAYMENT_DETAILS_SERIALIZER, POINT_OF_SERVICE_NORMALIZER, PROCESS_FEATURE, PRODUCT_DETAIL_ENTITY, PRODUCT_FEATURE, PRODUCT_INTERESTS, PRODUCT_INTERESTS_NORMALIZER, PRODUCT_NORMALIZER, PRODUCT_REFERENCES_NORMALIZER, PRODUCT_REVIEW_NORMALIZER, PRODUCT_REVIEW_SERIALIZER, PRODUCT_SEARCH_PAGE_NORMALIZER, PRODUCT_SUGGESTION_NORMALIZER, PageContext, PageMetaResolver, PageMetaService, PageRobotsMeta, PageType, PersonalizationConfig, PersonalizationContextService, PersonalizationModule, PriceType, ProcessModule, process_selectors as ProcessSelectors, productGroup_actions as ProductActions, ProductAdapter, ProductConnector, ProductImageNormalizer, ProductLoadingService, ProductModule, ProductNameNormalizer, ProductOccModule, ProductPageMetaResolver, ProductReferenceNormalizer, ProductReferenceService, ProductReferencesAdapter, ProductReferencesConnector, ProductReviewService, ProductReviewsAdapter, ProductReviewsConnector, ProductScope, ProductSearchAdapter, ProductSearchConnector, ProductSearchService, productGroup_selectors as ProductSelectors, ProductService, ProductURLPipe, PromotionLocation, ProtectedRoutesGuard, ProtectedRoutesService, REGIONS, REGION_NORMALIZER, REGISTER_USER_PROCESS_ID, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, REMOVE_USER_PROCESS_ID, ROUTING_FEATURE, routingGroup_actions as RoutingActions, RoutingConfig, RoutingConfigService, RoutingModule, routingGroup_selectors as RoutingSelector, RoutingService, SERVER_REQUEST_ORIGIN, SERVER_REQUEST_URL, SET_DELIVERY_ADDRESS_PROCESS_ID, SET_DELIVERY_MODE_PROCESS_ID, SET_PAYMENT_DETAILS_PROCESS_ID, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID, SITE_CONTEXT_FEATURE, STORE_COUNT_NORMALIZER, STORE_FINDER_DATA, STORE_FINDER_FEATURE, STORE_FINDER_SEARCH_PAGE_NORMALIZER, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, SearchPageMetaResolver, SearchboxService, SelectiveCartService, SemanticPathService, SiteAdapter, SiteConnector, siteContextGroup_actions as SiteContextActions, SiteContextConfig, SiteContextInterceptor, SiteContextModule, SiteContextOccModule, siteContextGroup_selectors as SiteContextSelectors, SmartEditModule, SmartEditService, StateConfig, entity_action as StateEntityActions, entityLoader_action as StateEntityLoaderActions, entityLoader_selectors as StateEntityLoaderSelectors, entityProcessesLoader_action as StateEntityProcessesLoaderActions, entityProcessesLoader_selectors as StateEntityProcessesLoaderSelectors, entity_selectors as StateEntitySelectors, loader_action as StateLoaderActions, loader_selectors as StateLoaderSelectors, StateModule, processesLoader_action as StateProcessesLoaderActions, processesLoader_selectors as StateProcessesLoaderSelectors, StateTransferType, StorageSyncType, StoreDataService, storeFinderGroup_actions as StoreFinderActions, StoreFinderAdapter, StoreFinderConfig, StoreFinderConnector, StoreFinderCoreModule, StoreFinderOccModule, storeFinderGroup_selectors as StoreFinderSelectors, StoreFinderService, TITLE_NORMALIZER, TOKEN_REVOCATION_HEADER, TestConfigModule, TranslatePipe, TranslationChunkService, TranslationService, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, UPDATE_EMAIL_PROCESS_ID, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, UPDATE_PASSWORD_PROCESS_ID, UPDATE_USER_DETAILS_PROCESS_ID, USER_ADDRESSES, USER_CONSENTS, USER_FEATURE, USER_NORMALIZER, USER_ORDERS, USER_ORDER_DETAILS, USER_PAYMENT_METHODS, USER_RETURN_REQUESTS, USER_RETURN_REQUEST_DETAILS, USER_SERIALIZER, USER_SIGN_UP_SERIALIZER, USE_CLIENT_TOKEN, USE_CUSTOMER_SUPPORT_AGENT_TOKEN, UnknownErrorHandler, UrlMatcherFactoryService, UrlModule, UrlPipe, userGroup_actions as UserActions, UserAdapter, UserAddressAdapter, UserAddressConnector, UserAddressService, UserConnector, UserConsentAdapter, UserConsentConnector, UserConsentService, UserInterestsAdapter, UserInterestsConnector, UserInterestsService, UserModule, UserNotificationPreferenceService, UserOccModule, UserOrderAdapter, UserOrderConnector, UserOrderService, UserPaymentAdapter, UserPaymentConnector, UserPaymentService, UserService, usersGroup_selectors as UsersSelectors, VariantQualifier, VariantType, WITHDRAW_CONSENT_PROCESS_ID, WindowRef, WishListEffects, WishListService, clearCartState, clearMultiCartState, configInitializerFactory, configurationFactory, contextServiceMapProvider, deprecatedContextServiceProviders as contextServiceProviders, defaultAnonymousConsentsConfig, defaultCmsModuleConfig, defaultOccConfig, defaultStateConfig, effects$5 as effects, entityLoaderReducer, entityProcessesLoaderReducer, entityReducer, errorHandlers, getMultiCartReducers, getReducers$5 as getReducers, getServerRequestProviders, getStateSlice, httpErrorInterceptors, initConfigurableRoutes, deprecatedInitSiteContextRoutesHandler as initSiteContextRoutesHandler, initialEntityState, initialLoaderState, initialProcessesState, inititializeContext, isFeatureEnabled, isFeatureLevel, loaderReducer, mediaServerConfigFromMetaTagFactory, metaReducers$3 as metaReducers, multiCartMetaReducers, multiCartReducerProvider, multiCartReducerToken, occConfigValidator, occServerConfigFromMetaTagFactory, ofLoaderFail, ofLoaderLoad, ofLoaderSuccess, processesLoaderReducer, provideConfig, provideConfigFactory, provideConfigFromMetaTags, provideConfigValidator, reducerProvider$5 as reducerProvider, reducerToken$5 as reducerToken, serviceMapFactory, deprecatedSiteContextParamsProviders as siteContextParamsProviders, testestsd, validateConfig, withdrawOn, TEST_CONFIG_COOKIE_NAME as ɵa, configFromCookieFactory as ɵb, AnonymousConsentsInterceptor as ɵba, asmStoreConfigFactory as ɵbb, AsmStoreModule as ɵbc, getReducers$3 as ɵbd, reducerToken$3 as ɵbe, reducerProvider$3 as ɵbf, clearCustomerSupportAgentAsmState as ɵbg, metaReducers$2 as ɵbh, effects$3 as ɵbi, CustomerEffects as ɵbj, CustomerSupportAgentTokenEffects as ɵbk, UserAuthenticationTokenService as ɵbl, reducer$7 as ɵbm, defaultAsmConfig as ɵbn, interceptors$2 as ɵbo, CustomerSupportAgentAuthErrorInterceptor as ɵbp, CustomerSupportAgentErrorHandlingService as ɵbq, authStoreConfigFactory as ɵbr, AuthStoreModule as ɵbs, getReducers as ɵbt, reducerToken as ɵbu, reducerProvider as ɵbv, clearAuthState as ɵbw, metaReducers as ɵbx, effects as ɵby, ClientTokenEffect as ɵbz, CONFIG_INITIALIZER_FORROOT_GUARD as ɵc, UserTokenEffects as ɵca, ClientAuthenticationTokenService as ɵcb, reducer as ɵcc, defaultAuthConfig as ɵcd, interceptors as ɵce, ClientTokenInterceptor as ɵcf, UserTokenInterceptor as ɵcg, AuthErrorInterceptor as ɵch, UserErrorHandlingService as ɵci, UrlParsingService as ɵcj, ClientErrorHandlingService as ɵck, TokenRevocationInterceptor as ɵcl, AuthServices as ɵcm, cartStoreConfigFactory as ɵcn, CartStoreModule as ɵco, SaveCartConnector as ɵcp, SaveCartAdapter as ɵcq, reducer$9 as ɵcr, multiCartStoreConfigFactory as ɵcs, MultiCartStoreModule as ɵct, MultiCartEffects as ɵcu, processesLoaderReducer as ɵcv, activeCartReducer as ɵcw, cartEntitiesReducer as ɵcx, wishListReducer as ɵcy, CartPageMetaResolver as ɵcz, initConfig as ɵd, CheckoutStoreModule as ɵda, getReducers$6 as ɵdb, reducerToken$6 as ɵdc, reducerProvider$6 as ɵdd, effects$6 as ɵde, AddressVerificationEffect as ɵdf, CardTypesEffects as ɵdg, CheckoutEffects as ɵdh, reducer$c as ɵdi, reducer$b as ɵdj, reducer$a as ɵdk, cmsStoreConfigFactory as ɵdl, CmsStoreModule as ɵdm, getReducers$8 as ɵdn, reducerToken$8 as ɵdo, reducerProvider$8 as ɵdp, clearCmsState as ɵdq, metaReducers$4 as ɵdr, effects$8 as ɵds, ComponentsEffects as ɵdt, NavigationEntryItemEffects as ɵdu, PageEffects as ɵdv, reducer$g as ɵdw, reducer$h as ɵdx, reducer$e as ɵdy, reducer$f as ɵdz, initializeContext as ɵe, configValidatorFactory as ɵea, ConfigValidatorModule as ɵeb, GlobalMessageStoreModule as ɵec, getReducers$4 as ɵed, reducerToken$4 as ɵee, reducerProvider$4 as ɵef, reducer$8 as ɵeg, GlobalMessageEffect as ɵeh, defaultGlobalMessageConfigFactory as ɵei, InternalServerErrorHandler as ɵej, HttpErrorInterceptor as ɵek, defaultI18nConfig as ɵel, i18nextProviders as ɵem, i18nextInit as ɵen, MockTranslationService as ɵeo, kymaStoreConfigFactory as ɵep, KymaStoreModule as ɵeq, getReducers$9 as ɵer, reducerToken$9 as ɵes, reducerProvider$9 as ɵet, clearKymaState as ɵeu, metaReducers$5 as ɵev, effects$9 as ɵew, OpenIdTokenEffect as ɵex, OpenIdAuthenticationTokenService as ɵey, defaultKymaConfig as ɵez, contextServiceProviders as ɵf, defaultOccAsmConfig as ɵfa, defaultOccCartConfig as ɵfb, OccSaveCartAdapter as ɵfc, defaultOccProductConfig as ɵfd, defaultOccSiteContextConfig as ɵfe, defaultOccStoreFinderConfig as ɵff, defaultOccUserConfig as ɵfg, UserNotificationPreferenceAdapter as ɵfh, defaultPersonalizationConfig as ɵfi, interceptors$3 as ɵfj, OccPersonalizationIdInterceptor as ɵfk, OccPersonalizationTimeInterceptor as ɵfl, ProcessStoreModule as ɵfm, getReducers$a as ɵfn, reducerToken$a as ɵfo, reducerProvider$a as ɵfp, productStoreConfigFactory as ɵfq, ProductStoreModule as ɵfr, getReducers$b as ɵfs, reducerToken$b as ɵft, reducerProvider$b as ɵfu, clearProductsState as ɵfv, metaReducers$6 as ɵfw, effects$a as ɵfx, ProductReferencesEffects as ɵfy, ProductReviewsEffects as ɵfz, initSiteContextRoutesHandler as ɵg, ProductsSearchEffects as ɵga, ProductEffects as ɵgb, reducer$i as ɵgc, entityScopedLoaderReducer as ɵgd, scopedLoaderReducer as ɵge, reducer$k as ɵgf, reducer$j as ɵgg, PageMetaResolver as ɵgh, addExternalRoutesFactory as ɵgi, getReducers$7 as ɵgj, reducer$d as ɵgk, reducerToken$7 as ɵgl, reducerProvider$7 as ɵgm, CustomSerializer as ɵgn, effects$7 as ɵgo, RouterEffects as ɵgp, SiteContextParamsService as ɵgq, SiteContextUrlSerializer as ɵgr, SiteContextRoutesHandler as ɵgs, defaultSiteContextConfigFactory as ɵgt, siteContextStoreConfigFactory as ɵgu, SiteContextStoreModule as ɵgv, getReducers$1 as ɵgw, reducerToken$1 as ɵgx, reducerProvider$1 as ɵgy, effects$2 as ɵgz, siteContextParamsProviders as ɵh, LanguagesEffects as ɵha, CurrenciesEffects as ɵhb, BaseSiteEffects as ɵhc, reducer$3 as ɵhd, reducer$2 as ɵhe, reducer$1 as ɵhf, baseSiteConfigValidator as ɵhg, interceptors$4 as ɵhh, CmsTicketInterceptor as ɵhi, defaultStoreFinderConfig as ɵhj, StoreFinderStoreModule as ɵhk, getReducers$c as ɵhl, reducerToken$c as ɵhm, reducerProvider$c as ɵhn, effects$b as ɵho, FindStoresEffect as ɵhp, ViewAllStoresEffect as ɵhq, UserStoreModule as ɵhr, getReducers$d as ɵhs, reducerToken$d as ɵht, reducerProvider$d as ɵhu, clearUserState as ɵhv, metaReducers$8 as ɵhw, effects$c as ɵhx, BillingCountriesEffect as ɵhy, ClearMiscsDataEffect as ɵhz, anonymousConsentsStoreConfigFactory as ɵi, ConsignmentTrackingEffects as ɵia, DeliveryCountriesEffects as ɵib, NotificationPreferenceEffects as ɵic, OrderDetailsEffect as ɵid, OrderReturnRequestEffect as ɵie, UserPaymentMethodsEffects as ɵif, RegionsEffects as ɵig, ResetPasswordEffects as ɵih, TitlesEffects as ɵii, UserAddressesEffects as ɵij, UserConsentsEffect as ɵik, UserDetailsEffects as ɵil, UserOrdersEffect as ɵim, UserRegisterEffects as ɵin, CustomerCouponEffects as ɵio, ProductInterestsEffect as ɵip, ForgotPasswordEffects as ɵiq, UpdateEmailEffects as ɵir, UpdatePasswordEffects as ɵis, UserNotificationPreferenceConnector as ɵit, reducer$w as ɵiu, reducer$u as ɵiv, reducer$l as ɵiw, reducer$v as ɵix, reducer$q as ɵiy, reducer$x as ɵiz, AnonymousConsentsStoreModule as ɵj, reducer$p as ɵja, reducer$A as ɵjb, reducer$n as ɵjc, reducer$t as ɵjd, reducer$r as ɵje, reducer$s as ɵjf, reducer$m as ɵjg, reducer$y as ɵjh, reducer$o as ɵji, reducer$z as ɵjj, FindProductPageMetaResolver as ɵjk, PageMetaResolver as ɵjl, TRANSFER_STATE_META_REDUCER as ɵk, STORAGE_SYNC_META_REDUCER as ɵl, stateMetaReducers as ɵm, getStorageSyncReducer as ɵn, getTransferStateReducer as ɵo, getReducers$2 as ɵp, reducerToken$2 as ɵq, reducerProvider$2 as ɵr, clearAnonymousConsentTemplates as ɵs, metaReducers$1 as ɵt, effects$1 as ɵu, AnonymousConsentsEffects as ɵv, reducer$6 as ɵw, reducer$4 as ɵx, reducer$5 as ɵy, interceptors$1 as ɵz };\n"]}