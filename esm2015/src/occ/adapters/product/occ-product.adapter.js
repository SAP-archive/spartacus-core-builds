import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { OccEndpointsService } from '../../services/occ-endpoints.service';
import { ConverterService } from '../../../util/converter.service';
import { PRODUCT_NORMALIZER } from '../../../product/connectors/product/converters';
import { OccRequestsOptimizerService } from '../../services/occ-requests-optimizer.service';
let OccProductAdapter = class OccProductAdapter {
    constructor(http, occEndpoints, converter, requestsOptimizer) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        this.requestsOptimizer = requestsOptimizer;
    }
    load(productCode, scope) {
        return this.http
            .get(this.getEndpoint(productCode, scope))
            .pipe(this.converter.pipeable(PRODUCT_NORMALIZER));
    }
    loadMany(products) {
        const scopedDataWithUrls = products.map((model) => ({
            scopedData: model,
            url: this.getEndpoint(model.code, model.scope),
        }));
        return this.requestsOptimizer
            .scopedDataLoad(scopedDataWithUrls)
            .map((scopedProduct) => (Object.assign(Object.assign({}, scopedProduct), { data$: scopedProduct.data$.pipe(this.converter.pipeable(PRODUCT_NORMALIZER)) })));
    }
    getEndpoint(code, scope) {
        return this.occEndpoints.getUrl('product', {
            productCode: code,
        }, undefined, scope);
    }
};
OccProductAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService },
    { type: OccRequestsOptimizerService }
];
OccProductAdapter = __decorate([
    Injectable()
], OccProductAdapter);
export { OccProductAdapter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLXByb2R1Y3QuYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9vY2MvYWRhcHRlcnMvcHJvZHVjdC9vY2MtcHJvZHVjdC5hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUMzRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnREFBZ0QsQ0FBQztBQUtwRixPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQztBQUc1RixJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFpQjtJQUM1QixZQUNZLElBQWdCLEVBQ2hCLFlBQWlDLEVBQ2pDLFNBQTJCLEVBQzNCLGlCQUE4QztRQUg5QyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGlCQUFZLEdBQVosWUFBWSxDQUFxQjtRQUNqQyxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQUMzQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQTZCO0lBQ3ZELENBQUM7SUFFSixJQUFJLENBQUMsV0FBbUIsRUFBRSxLQUFjO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLElBQUk7YUFDYixHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsUUFBUSxDQUFDLFFBQTZCO1FBQ3BDLE1BQU0sa0JBQWtCLEdBQXdCLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkUsVUFBVSxFQUFFLEtBQUs7WUFDakIsR0FBRyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDO1NBQy9DLENBQUMsQ0FBQyxDQUFDO1FBRUosT0FBTyxJQUFJLENBQUMsaUJBQWlCO2FBQzFCLGNBQWMsQ0FBYyxrQkFBa0IsQ0FBQzthQUMvQyxHQUFHLENBQ0YsQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUNoQixDQUFDLGdDQUNJLGFBQWEsS0FDaEIsS0FBSyxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUM1QyxHQUNvQixDQUFBLENBQzFCLENBQUM7SUFDTixDQUFDO0lBRVMsV0FBVyxDQUFDLElBQVksRUFBRSxLQUFjO1FBQ2hELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQzdCLFNBQVMsRUFDVDtZQUNFLFdBQVcsRUFBRSxJQUFJO1NBQ2xCLEVBQ0QsU0FBUyxFQUNULEtBQUssQ0FDTixDQUFDO0lBQ0osQ0FBQztDQUNGLENBQUE7O1lBekNtQixVQUFVO1lBQ0YsbUJBQW1CO1lBQ3RCLGdCQUFnQjtZQUNSLDJCQUEyQjs7QUFML0MsaUJBQWlCO0lBRDdCLFVBQVUsRUFBRTtHQUNBLGlCQUFpQixDQTJDN0I7U0EzQ1ksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUHJvZHVjdEFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9wcm9kdWN0L2Nvbm5lY3RvcnMvcHJvZHVjdC9wcm9kdWN0LmFkYXB0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9jY0VuZHBvaW50c1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vY2MtZW5kcG9pbnRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udmVydGVyU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWwvY29udmVydGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgUFJPRFVDVF9OT1JNQUxJWkVSIH0gZnJvbSAnLi4vLi4vLi4vcHJvZHVjdC9jb25uZWN0b3JzL3Byb2R1Y3QvY29udmVydGVycyc7XG5pbXBvcnQgeyBQcm9kdWN0IH0gZnJvbSAnLi4vLi4vLi4vbW9kZWwvcHJvZHVjdC5tb2RlbCc7XG5pbXBvcnQgeyBTY29wZWRQcm9kdWN0RGF0YSB9IGZyb20gJy4uLy4uLy4uL3Byb2R1Y3QvY29ubmVjdG9ycy9wcm9kdWN0L3Njb3BlZC1wcm9kdWN0LWRhdGEnO1xuaW1wb3J0IHsgU2NvcGVkRGF0YVdpdGhVcmwgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vY2MtZmllbGRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgT2NjIH0gZnJvbSAnLi4vLi4vb2NjLW1vZGVscyc7XG5pbXBvcnQgeyBPY2NSZXF1ZXN0c09wdGltaXplclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vY2MtcmVxdWVzdHMtb3B0aW1pemVyLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgT2NjUHJvZHVjdEFkYXB0ZXIgaW1wbGVtZW50cyBQcm9kdWN0QWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBodHRwOiBIdHRwQ2xpZW50LFxuICAgIHByb3RlY3RlZCBvY2NFbmRwb2ludHM6IE9jY0VuZHBvaW50c1NlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGNvbnZlcnRlcjogQ29udmVydGVyU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgcmVxdWVzdHNPcHRpbWl6ZXI6IE9jY1JlcXVlc3RzT3B0aW1pemVyU2VydmljZVxuICApIHt9XG5cbiAgbG9hZChwcm9kdWN0Q29kZTogc3RyaW5nLCBzY29wZT86IHN0cmluZyk6IE9ic2VydmFibGU8UHJvZHVjdD4ge1xuICAgIHJldHVybiB0aGlzLmh0dHBcbiAgICAgIC5nZXQodGhpcy5nZXRFbmRwb2ludChwcm9kdWN0Q29kZSwgc2NvcGUpKVxuICAgICAgLnBpcGUodGhpcy5jb252ZXJ0ZXIucGlwZWFibGUoUFJPRFVDVF9OT1JNQUxJWkVSKSk7XG4gIH1cblxuICBsb2FkTWFueShwcm9kdWN0czogU2NvcGVkUHJvZHVjdERhdGFbXSk6IFNjb3BlZFByb2R1Y3REYXRhW10ge1xuICAgIGNvbnN0IHNjb3BlZERhdGFXaXRoVXJsczogU2NvcGVkRGF0YVdpdGhVcmxbXSA9IHByb2R1Y3RzLm1hcCgobW9kZWwpID0+ICh7XG4gICAgICBzY29wZWREYXRhOiBtb2RlbCxcbiAgICAgIHVybDogdGhpcy5nZXRFbmRwb2ludChtb2RlbC5jb2RlLCBtb2RlbC5zY29wZSksXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdHNPcHRpbWl6ZXJcbiAgICAgIC5zY29wZWREYXRhTG9hZDxPY2MuUHJvZHVjdD4oc2NvcGVkRGF0YVdpdGhVcmxzKVxuICAgICAgLm1hcChcbiAgICAgICAgKHNjb3BlZFByb2R1Y3QpID0+XG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIC4uLnNjb3BlZFByb2R1Y3QsXG4gICAgICAgICAgICBkYXRhJDogc2NvcGVkUHJvZHVjdC5kYXRhJC5waXBlKFxuICAgICAgICAgICAgICB0aGlzLmNvbnZlcnRlci5waXBlYWJsZShQUk9EVUNUX05PUk1BTElaRVIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0gYXMgU2NvcGVkUHJvZHVjdERhdGEpXG4gICAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEVuZHBvaW50KGNvZGU6IHN0cmluZywgc2NvcGU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9jY0VuZHBvaW50cy5nZXRVcmwoXG4gICAgICAncHJvZHVjdCcsXG4gICAgICB7XG4gICAgICAgIHByb2R1Y3RDb2RlOiBjb2RlLFxuICAgICAgfSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHNjb3BlXG4gICAgKTtcbiAgfVxufVxuIl19