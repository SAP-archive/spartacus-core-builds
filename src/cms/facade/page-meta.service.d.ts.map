{"version":3,"file":"page-meta.service.d.ts","sources":["page-meta.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Observable } from 'rxjs';\nimport { Page, PageMeta } from '../model/page.model';\nimport { PageMetaResolver } from '../page/page-meta.resolver';\nimport { CmsService } from './cms.service';\nimport { UnifiedInjector } from '../../lazy-loading/unified-injector';\nexport declare class PageMetaService {\n    protected cms: CmsService;\n    protected unifiedInjector?: UnifiedInjector;\n    private resolvers$;\n    constructor(cms: CmsService, unifiedInjector?: UnifiedInjector);\n    /**\n     * The list of resolver interfaces will be evaluated for the pageResolvers.\n     *\n     * TOOD: optimize browser vs SSR resolvers; image, robots and description\n     *       aren't needed during browsing.\n     * TODO: we can make the list of resolver types configurable\n     */\n    protected resolverMethods: {\n        [key: string]: string;\n    };\n    getMeta(): Observable<PageMeta | null>;\n    /**\n     * If a `PageResolver` has implemented a resolver interface, the resolved data\n     * is merged into the `PageMeta` object.\n     * @param metaResolver\n     */\n    protected resolve(metaResolver: PageMetaResolver): Observable<PageMeta>;\n    /**\n     * Return the resolver with the best match, based on a score\n     * generated by the resolver.\n     *\n     * Resolvers match by default on `PageType` and `page.template`.\n     */\n    protected getMetaResolver(page: Page): Observable<PageMetaResolver>;\n}\n"]}