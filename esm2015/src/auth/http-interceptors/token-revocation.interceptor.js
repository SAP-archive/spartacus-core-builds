import { Injectable } from '@angular/core';
import { EMPTY, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { InterceptorUtil, TOKEN_REVOCATION_HEADER, } from '../../occ/utils/interceptor-util';
import * as i0 from "@angular/core";
export class TokenRevocationInterceptor {
    constructor() { }
    intercept(request, next) {
        const isTokenRevocationRequest = this.isTokenRevocationRequest(request);
        if (isTokenRevocationRequest) {
            request = InterceptorUtil.removeHeader(TOKEN_REVOCATION_HEADER, request);
        }
        return next.handle(request).pipe(catchError((error) => {
            if (isTokenRevocationRequest) {
                return EMPTY;
            }
            return throwError(error);
        }));
    }
    isTokenRevocationRequest(request) {
        const isTokenRevocationHeaderPresent = InterceptorUtil.getInterceptorParam(TOKEN_REVOCATION_HEADER, request.headers);
        return Boolean(isTokenRevocationHeaderPresent);
    }
}
TokenRevocationInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function TokenRevocationInterceptor_Factory() { return new TokenRevocationInterceptor(); }, token: TokenRevocationInterceptor, providedIn: "root" });
TokenRevocationInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
TokenRevocationInterceptor.ctorParameters = () => [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4tcmV2b2NhdGlvbi5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvc3JjL2F1dGgvaHR0cC1pbnRlcmNlcHRvcnMvdG9rZW4tcmV2b2NhdGlvbi5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxLQUFLLEVBQWMsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM1QyxPQUFPLEVBQ0wsZUFBZSxFQUNmLHVCQUF1QixHQUN4QixNQUFNLGtDQUFrQyxDQUFDOztBQUcxQyxNQUFNLE9BQU8sMEJBQTBCO0lBQ3JDLGdCQUFlLENBQUM7SUFFaEIsU0FBUyxDQUNQLE9BQXlCLEVBQ3pCLElBQWlCO1FBRWpCLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hFLElBQUksd0JBQXdCLEVBQUU7WUFDNUIsT0FBTyxHQUFHLGVBQWUsQ0FBQyxZQUFZLENBQUMsdUJBQXVCLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDMUU7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUM5QixVQUFVLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtZQUN4QixJQUFJLHdCQUF3QixFQUFFO2dCQUM1QixPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsT0FBTyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFUyx3QkFBd0IsQ0FBQyxPQUF5QjtRQUMxRCxNQUFNLDhCQUE4QixHQUFHLGVBQWUsQ0FBQyxtQkFBbUIsQ0FFeEUsdUJBQXVCLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVDLE9BQU8sT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7SUFDakQsQ0FBQzs7OztZQTVCRixVQUFVLFNBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSHR0cEV2ZW50LFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwUmVxdWVzdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRU1QVFksIE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBJbnRlcmNlcHRvclV0aWwsXG4gIFRPS0VOX1JFVk9DQVRJT05fSEVBREVSLFxufSBmcm9tICcuLi8uLi9vY2MvdXRpbHMvaW50ZXJjZXB0b3ItdXRpbCc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVG9rZW5SZXZvY2F0aW9uSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgaW50ZXJjZXB0KFxuICAgIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgbmV4dDogSHR0cEhhbmRsZXJcbiAgKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIGNvbnN0IGlzVG9rZW5SZXZvY2F0aW9uUmVxdWVzdCA9IHRoaXMuaXNUb2tlblJldm9jYXRpb25SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGlmIChpc1Rva2VuUmV2b2NhdGlvblJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QgPSBJbnRlcmNlcHRvclV0aWwucmVtb3ZlSGVhZGVyKFRPS0VOX1JFVk9DQVRJT05fSEVBREVSLCByZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxdWVzdCkucGlwZShcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGlzVG9rZW5SZXZvY2F0aW9uUmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaXNUb2tlblJldm9jYXRpb25SZXF1ZXN0KHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBib29sZWFuIHtcbiAgICBjb25zdCBpc1Rva2VuUmV2b2NhdGlvbkhlYWRlclByZXNlbnQgPSBJbnRlcmNlcHRvclV0aWwuZ2V0SW50ZXJjZXB0b3JQYXJhbTxcbiAgICAgIHN0cmluZ1xuICAgID4oVE9LRU5fUkVWT0NBVElPTl9IRUFERVIsIHJlcXVlc3QuaGVhZGVycyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oaXNUb2tlblJldm9jYXRpb25IZWFkZXJQcmVzZW50KTtcbiAgfVxufVxuIl19