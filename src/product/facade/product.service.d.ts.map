{"version":3,"file":"product.service.d.ts","sources":["product.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { Product } from '../../model/product.model';\nimport { StateWithProduct } from '../store/product-state';\nimport { ProductLoadingService } from '../services/product-loading.service';\nimport { ProductScope } from '../model/product-scope';\nexport declare class ProductService {\n    protected store: Store<StateWithProduct>;\n    protected productLoading: ProductLoadingService;\n    constructor(store: Store<StateWithProduct>, productLoading: ProductLoadingService);\n    /**\n     * Returns the product observable. The product will be loaded\n     * whenever there's no value observed.\n     *\n     * The underlying product loader ensures that the product is\n     * only loaded once, even in case of parallel observers.\n     *\n     * You should provide product data scope you are interested in to not load all\n     * the data if not needed. You can provide more than one scope.\n     *\n     * @param productCode Product code to load\n     * @param scopes Scope or scopes of the product data\n     */\n    get(productCode: string, scopes?: (ProductScope | string)[] | ProductScope | string): Observable<Product>;\n    /**\n     * Returns boolean observable for product's loading state\n     */\n    isLoading(productCode: string, scope?: ProductScope | string): Observable<boolean>;\n    /**\n     * Returns boolean observable for product's load success state\n     */\n    isSuccess(productCode: string, scope?: ProductScope | string): Observable<boolean>;\n    /**\n     * Returns boolean observable for product's load error state\n     */\n    hasError(productCode: string, scope?: ProductScope | string): Observable<boolean>;\n    /**\n     * Reloads the product. The product is loaded implicetly\n     * whenever selected by the `get`, but in some cases an\n     * explicit reload might be needed.\n     */\n    reload(productCode: string, scope?: ProductScope | string): void;\n}\n"]}