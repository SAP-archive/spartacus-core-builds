{"version":3,"file":"converter.service.d.ts","sources":["converter.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { InjectionToken, OnDestroy } from '@angular/core';\nimport { OperatorFunction, Subscription } from 'rxjs';\nimport { UnifiedInjector } from '../lazy-loading/unified-injector';\n/**\n * Converter is used to convert source data model to target data model.\n * By convention, we distinguish two flows:\n *   - *Normalize* is the conversion from backend models to UI models\n *   - *Serialize* is the conversion of UI models to backend models (in case of submitting data to the backend).\n *\n * Converters can be stacked together to to apply decoupled customizations\n */\nexport interface Converter<S, T> {\n    /**\n     * Convert converts source model to target model. Can use optional target parameter,\n     * used in case of stacking multiple converters (for example, to implement populator pattern).\n     *\n     * @param source Source data model\n     * @param target Optional, partially converted target model\n     */\n    convert(source: S, target?: T): T;\n}\nexport declare class ConverterService implements OnDestroy {\n    protected unifiedInjector: UnifiedInjector;\n    protected subscriptions: Subscription;\n    constructor(unifiedInjector: UnifiedInjector);\n    private converters;\n    private getConverters;\n    /**\n     * Will return true if converters for specified token were provided\n     */\n    hasConverters<S, T>(injectionToken: InjectionToken<Converter<S, T>>): boolean;\n    /**\n     * Pipeable operator to apply converter logic in a observable stream\n     */\n    pipeable<S, T>(injectionToken: InjectionToken<Converter<S, T>>): OperatorFunction<S, T>;\n    /**\n     * Pipeable operator to apply converter logic in a observable stream to collection of items\n     */\n    pipeableMany<S, T>(injectionToken: InjectionToken<Converter<S, T>>): OperatorFunction<S[], T[]>;\n    /**\n     * Apply converter logic specified by injection token to source data\n     */\n    convert<S, T>(source: S, injectionToken: InjectionToken<Converter<S, T>>): T;\n    /**\n     * Apply converter logic specified by injection token to a collection\n     */\n    convertMany<S, T>(sources: S[], injectionToken: InjectionToken<Converter<S, T>>): T[];\n    private convertSource;\n    ngOnDestroy(): void;\n}\n"]}